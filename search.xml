<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读书-图解HTTP-1.了解web及网络基础]]></title>
    <url>%2F2019%2F06%2F24%2F%E8%AF%BB%E4%B9%A6-%E5%9B%BE%E8%A7%A3HTTP-1.%E4%BA%86%E8%A7%A3web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[TCP/IP协议层分为4层 应用层决定向用户提供应用服务时通信活动 (http协议输入该层) 传输层提供处于网络连接时两台计算机之间的数据传输TCP/UDP 请求协议在此层 端口号在此层 网络层用来处理网络上流动的数据包（设定路线传输到对方计算机）需要本机IP和服务器(客户端)IPIP协议：IP协议的作用是把各种数据包传送给对方，为了保证传送正确 需要在数据中携带IP地址和MAC地址 IP地址：节点地址 可变 MAC地址：网卡地址 固定 链路层用于处理连接硬件部分 驱动 网卡 以太网地址硬件上的范畴都在链路层范围 TCP/IP通信传输流发送端从应用层往下走，接收端从链路层往上走应用层提供路径，有传输层包装携带端口号(UDP或TCP)协议请求信息，在网络层进行包装本机IP和接收端IP MAC地址 最后由链路层处理发送到接收端 接收端通过接收到得数据 在链路层从下到上进行拆解获取信息 就完成了一次请求发送端每层要打包首部信息接收端每层拆解首部信息 传输机制路由原则机制 在网络中传播 将通过路由器多次中转，传递到接收端 可靠的TCP协议 TCP协议位于传输层，提供可靠的字节流服务为了方便传输将大块数据分割成以报文段为单位的数据包进行管理 TCP协议采用三次握手策略，即发送端首先发送一个带有SYN标志的数据包给对方，接收端收到后返回一个带有SYN/ACK数据包以传达确认信息，最后发送端再回传一个带有ACK标志的数据包 表示握手结束若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包DNS服务提供从域名到IP地址之间的解析服务将域名通过DNS服务获取反馈到的IP地址值进行访问URL URIURI统一资源标识符URL统一资源定位符URI用字符串标识某一互联网资源 而URL表示资源地点则URL是URI子集]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring 10. Spring Security]]></title>
    <url>%2F2019%2F06%2F18%2FSpring-10.-Spring-Security%2F</url>
    <content type="text"><![CDATA[Spring Security概述Spring Security 是 Spring 项目组中用来提供安全认证服务的框架 “认证”，是为用户建立一个他所声明的主体。主题一般式指用户，设备或可以在你系 统中执行动作的其他系统。 “授权”指的是一个用户能否在你的应用中执行某个操作，在到达授权判断之前，身份的主题已经由 身份验证过程建立了。登录配置Maven1234567891011121314151617181920 &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; web.xml123456789101112131415 &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; spring-security.xml （数据库中配置用户名密码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:s="http://www.springframework.org/schema/security" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt;&lt;!-- 开启jsr250权限控制--&gt; &lt;security:global-method-security jsr250-annotations="enabled"&gt;&lt;/security:global-method-security&gt; &lt;!-- 配置不拦截的资源 --&gt; &lt;security:http pattern="/login.jsp" security="none"/&gt; &lt;security:http pattern="/failer.jsp" security="none"/&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式（没学习过） --&gt; &lt;security:http auto-config="true" use-expressions="false"&gt; &lt;!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" --&gt; &lt;security:intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN,ROLE_STAFF"/&gt; &lt;!-- 定义跳转的具体的页面 login-page 登录界面 login-processing-url 访问路径 authentication-success-forward-url 成功界面 authentication-failure-url 失败界面 username-parameter 用户名 来源于网页 password-parameter 密码 来源于网页 --&gt; &lt;security:form-login login-page="/login.jsp" login-processing-url="/login" authentication-success-forward-url="/main.jsp" authentication-failure-url="/failer.jsp" /&gt; &lt;!-- 关闭跨域请求 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout" logout-success-url="/login.jsp" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt;&lt;!-- 配置关联的实现类--&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- &amp;lt;!&amp;ndash; 配置加密的方式 &amp;ndash;&amp;gt; &lt;security:password-encoder ref="passwordEncoder"/&gt;--&gt;&lt;!-- 以此方法进行解密--&gt; &lt;security:password-encoder ref="passwordEncoder"/&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密类 --&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- 在内存中存入用户名和密码 &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name="admin" password="&#123;noop&#125;admin" authorities="ROLE_USER"/&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; --&gt;&lt;/beans&gt; service创建接口继承UserDetailsService123456789101112131415161718192021222324252627282930313233343536373839** * 继承UserDetailsService接口 * 创建实现类完成方法实现 */public interface UserService extends UserDetailsService &#123; /** * 查询所有用户 * @return * @param page * @param pageSize */ List&lt;UserInfo&gt; findAll(int page, int pageSize); /** * 储存用户 * @param info */ void saveOne(UserInfo info); /** * 根据id查询用户详情 * @return */ UserInfo findById(String id); /** * 查询该用户没有的角色 * @param id * @return */ List&lt;Role&gt; findOtherRolesById(String id); /** * 保存新角色 * @param userId * @param ids */ void addRoleToUser(String userId, String[] ids);&#125; 实现类返回其实现类 User 123456789public class User implements UserDetails, CredentialsContainer &#123;private String password;private final String username;private final Set&lt;GrantedAuthority&gt; authorities;private final boolean accountNonExpired; //帐户是否过期private final boolean accountNonLocked; //帐户是否锁定private final boolean credentialsNonExpired; //认证是否过期private final boolean enabled; //帐户是否可用｝ 1234public class UserServiceImpl implements UserService &#123; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;&#125; &#125; user中需要传入一个 GrantedAuthority集合 来返回给spring-security.xml角色信息，判断是否是ROLE_USER,ROLE_ADMIN 使用实现类SimpleGrantedAuthority完成 该类中的 private final String role; 即我们将数据库获取出的角色信息放在每一个SimpleGrantedAuthority实例中传递给集合即可 1234567891011121314151617@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserInfo info = dao.findByUserName(username); List&lt;Role&gt; roleList = info.getRoles(); List&lt;SimpleGrantedAuthority&gt; authorityList=setAuthority(roleList); return new User(info.getUserName(),info.getPassWord(), info.getStatus()==1, true,true,true,authorityList); &#125; private List&lt;SimpleGrantedAuthority&gt; setAuthority(List&lt;Role&gt; roleList) &#123; List&lt;SimpleGrantedAuthority&gt; authoritys = new ArrayList&lt;SimpleGrantedAuthority&gt;(); for (Role role : roleList) &#123; authoritys.add(new SimpleGrantedAuthority("ROLE_"+role.getRoleName())); &#125; return authoritys; &#125; 密码加密工具类 12345678 public class PassWordUtils &#123; public static void main(String[] args) &#123; PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String ssm = passwordEncoder.encode("ssm"); System.out.println(ssm); &#125;&#125; 权限控制jsr250配置12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt; 1.0&lt;/version&gt;&lt;/dependency&gt; spring-security.xml12&lt;!-- 开启jsr250权限控制--&gt; &lt;security:global-method-security jsr250-annotations="enabled"&gt;&lt;/security:global-method-security&gt; springmvc.xml1&lt;aop:aspectj-autoproxy proxy-target-class="true"&gt;&lt;/aop:aspectj-autoproxy&gt; 使用方法 @RolesAllowed({&quot;ADMIN&quot;,&quot;USER&quot;}) 在每个controller方法上添加&lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER,ROLE_ADMIN&quot; /&gt; 设定的角色访问被该注解修饰的方法]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网面试错题集 2]]></title>
    <url>%2F2019%2F06%2F17%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E8%AF%95%E9%94%99%E9%A2%98%E9%9B%86-2%2F</url>
    <content type="text"><![CDATA[Java编译java MyTest a b cjava后跟类名 后跟arg[ ]数组参数 包 包是类的容器，用于分隔类名空间。java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。 定义在同一个包（package）内的类可以不经过import而直接相互使用。面向对象三大特性继承封装多态java c++所有使用面向对象思想的语言通用数据库执行语句db.executeUpdate(sql); 用于执行sql语句用于返回查询结果是错误的如果是查询返回 也可以执行不返回任何内容的sql语句Integer123456789101112public class a &#123; public static void main(String[] args) &#123; Integer i01 = 59; int i02 = 59; Integer i03 =Integer.valueOf(59); Integer i04 = new Integer(59); System.out.println(i01==i04); System.out.println(i01==i03); System.out.println(i02==i04); System.out.println(i03==i04); &#125;&#125; JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象所以前三个同一个对象 第四个单独新对象第一个为false指向不同对象第二个为true 指向同一个对象第三个为true因为i02是基本类型 所以==比较的是数值 i04自动拆箱第四个为false new是新创建的对象 集合collection 分为set list collection与Map是同级的ArrayList 查询快 增删慢LinkedList查询慢 增删快Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口Hashtable 是一个散列表，Hashtable 类则继承Dictionary，实现Map接口 ClassLoaderJDK中提供了三个ClassLoader，根据层级从高到低为： Bootstrap ClassLoader，主要加载JVM自身工作需要的类。 Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。 Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器 JVM加载类的实现方式，我们称为 双亲委托模型： 得到类加载请求，自己不会加载，让其父类加载器加载，直到反馈到Bootstrop ClassLoader 如果父类加载器反馈了无法加载，子类才会尝试加载 双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。 假设有一个开发者自己编写了一个名为Java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它 垃圾回收器java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。** 方法使用完 是 弹栈 不走垃圾回收器 弹栈完成内存回收 ** 并发编程同步器 Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。 CountDownLatch直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 泛型 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;,List&lt;B&gt;,List&lt;Object&gt; 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范，&lt;?&gt;代表全部范围 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值 List&lt;?&gt;和List 是相等的，都代表最大范围 List既是点也是范围，当表示范围时，表示最大范围1234567891011121314151617public static void main(String[] args) &#123; List&lt;A&gt; a; List list; list = a; //A对，因为List就是List&lt;?&gt;，代表最大的范围，A只是其中的一个点，肯定被包含在内 List&lt;B&gt; b; a = b; //B错，点之间不能相互赋值 List&lt;?&gt; qm; List&lt;Object&gt; o; qm = o; //C对，List&lt;?&gt;代表最大的范围，List&lt;Object&gt;只是一个点，肯定被包含在内 List&lt;D&gt; d; List&lt;? extends B&gt; downB; downB = d; //D对，List&lt;? extends B&gt;代表小于等于B的范围，List&lt;D&gt;是一个点，在其中 List&lt;?extends A&gt; downA; a = downA; //E错，范围不能赋值给点 a = o; //F错，List&lt;Object&gt;只是一个点 downA = downB; //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛 &#125; 集合collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据。jdk1.5版本以前不能传入基本类型jdk1.5版本以后可以 会自动装箱 1234567public static void main(String args[]) &#123; List Listlist1 = new ArrayList(); Listlist1.add(0); List Listlist2 = Listlist1; System.out.println(Listlist1.get(0) instanceof Integer); System.out.println(Listlist2.get(0) instanceof Integer);&#125; 结果为 true MathMath.ceil(d1)如果参数小于0且大于-1.0，结果为 -0 12double d1=-0.5;System.out.println("Ceil d1="+Math.ceil(d1)); 结果为-0.0 构造器 子类不能继承父类构造函数 但可以显示调用父类构造函数 在其他构造器中调用上方已有构造器的方法this(参数)关系数据模型和对象数据模型之间对应关系表对应类记录对应对象表的字段对应类的属性赋值符号没有&lt;&lt;&lt; 只有&gt;&gt;&gt; 无符号右移字符串转码将ISO8859-1字符串转成GB2312编码new String(&quot;需要转换的字符串&quot;.getBytes(&quot;ISO8859- 1&quot;),&quot;GB2312&quot;)局部变量1234public static void main(String[] args)&#123; String s; System.out.println("s="+s);&#125; 局部变量没有默认值编译会失败ze 运算符优先级&gt;，&lt;，&amp;&amp;，|| 多态编译期看左面 运行时看右面 12345678910111213141516171819202122232425262728class Base&#123; public void method() &#123; System.out.println("Base"); &#125; &#125;class Son extends Base&#123; public void method() &#123; System.out.println("Son"); &#125; public void methodB() &#123; System.out.println("SonB"); &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Base base = new Son(); base.method(); base.methodB(); &#125;&#125; 编译期无法通过 因为编译期认为 Base base = new Son();是base对象 base中没有methodB();方法，所以编译期无法通过 成员变量和静态方法：编译期和运行期都看左面 即父类或者父类接口方法：编译器看左面运行期看右面调用子类特有的方法(父类没有 子类有的) 不能使用多态 ASCII码空格的ASCII码值为320–48 A–65 a–97 修饰符访问权限 Sevlet 体系结构 System.out.println()System是java.lang中的一个类out是System内的一个成员变量 这个变量是一个java.io.PrintStream类的对象println是一个方法 余弦值计算正确计算42度（角度）的余弦值double d=Math.cos（Math.toRadians（42））将角度转换为弧度计算 web ServiceWebservice是跨平台，跨语言的远程调用技术它的通信机制实质就是xml数据交换Webservice采用了soap协议（简单对象协议）进行通信WSDL是用于描述 Web Services 以及如何对它们进行访问]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 7. PageHelper分页]]></title>
    <url>%2F2019%2F06%2F16%2FMybatis-7.-PageHelper%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[PageHelper介绍PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本主流与常用的数据库，例如mysql、oracle、mariaDB、DB2、SQLite、Hsqldb等。本项目在 github 的项目地址：https://github.com/pagehelper/Mybatis-PageHelper本项目在 gitosc 的项目地址：http://git.oschina.net/free/Mybatis_PageHelper PageHelper使用引入分页插件有下面2种方式，推荐使用 Maven 方式。 Jar包可以从下面的地址中下载最新版本的 jar 包https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/由于使用了sql 解析工具，你还需要下载 jsqlparser.jar：http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/ Maven12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 配置Mybatis中配置拦截器插件 123456789101112131415 &lt;!--plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:properties?, settings?,typeAliases?, typeHandlers?,objectFactory?,objectWrapperFactory?,plugins?,environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="param1" value="value1"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 在 Spring 配置文件中配置拦截器插件12345678910111213141516171819&lt;!-- 配制SqlSessionFacatory--&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 传入PageHelper的插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;!-- 传入插件的对象 --&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="helperDialect"&gt;oracle&lt;/prop&gt; &lt;prop key="reasonable"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 插件功能介绍 helperDialect ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver2012 , derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012 ，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect ，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero ：默认值为 false ，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit =0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable ：分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum&lt;=0 时会查询第一页， pageNum&gt;pages （超过总数时），会查询最后一页。默认 false 时，直接根据参数进行查询。 *params *：为了支持 startPage(Object params) 方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable ，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero supportMethodsArguments ：支持通过 Mapper 接口参数来传递分页参数，默认值 false ，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和ArgumentsObjTest 。 ** autoRuntimeDialect** ：默认值为 false 。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择 sqlserver2012 ，只能使用 sqlserver ），用法和注意事项参考下面的场景五。 closeConn ：默认值为 true 。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认 true 关闭，设置为false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 功能演示分页查询功能紧贴查询方法 1234567 @Override public List&lt;Orders&gt; findAll(int page,int pageSize) &#123;// 分页查询 PageHelper.startPage(page,pageSize); return dao.findAll(); &#125; 1234567891011 @RequestMapping("/findAll") public ModelAndView findAll(@RequestParam(name = "page",required = true,defaultValue = "1")int page, @RequestParam(name = "pageSize",required = true,defaultValue = "4")int pageSize)&#123; ModelAndView view = new ModelAndView(); List&lt;Orders&gt; ordersList = service.findAll(page,pageSize);// 将集合封装到PageInfo中 PageInfo&lt;Orders&gt; pageInfo=new PageInfo&lt;&gt;(ordersList); view.addObject("pageInfo",pageInfo); view.setViewName("orders-list"); return view; &#125; 123456789101112131415161718192021222324252627282930313233343536&lt;c:forEach items="$&#123;pageInfo.list&#125;" var="orders"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;$&#123;orders.id &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.orderNum &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.product.productName &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.product.productPrice &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.orderTimeStr &#125;&lt;/td&gt; &lt;td class="text-center"&gt;$&#123;orders.orderStatusStr &#125;&lt;/td&gt; &lt;td class="text-center"&gt; &lt;button type="button" class="btn bg-olive btn-xs"&gt;订单&lt;/button&gt; &lt;button type="button" class="btn bg-olive btn-xs" onclick="location.href='$&#123;pageContext.request.contextPath&#125;/orders/findById?id=$&#123;orders.id&#125;'"&gt;详情&lt;/button&gt; &lt;button type="button" class="btn bg-olive btn-xs"&gt;编辑&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;div class="box-tools pull-right"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=1&amp;pageSize=$&#123;pageInfo.pageSize&#125;" aria-label="Previous"&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageInfo.prePage&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;c:forEach begin="1" end="$&#123;pageInfo.pages&#125;" var="pageNum"&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;"&gt;$&#123;pageNum&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageInfo.nextPage&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageInfo.pages&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;" aria-label="Next"&gt;尾页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; PageInfo该类中包含基本功能中所有需要的属性 可以通过该属性在网页端配置翻页功能 功能部分节选 12345678910111213141516171819202122232425262728293031323334353637383940414243private static final long serialVersionUID = 1L; //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中"显示startRow到endRow 共size条数据" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集 private List&lt;T&gt; list; //前一页 private int prePage; //下一页 private int nextPage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //所有导航页号 private int[] navigatepageNums; //导航条上的第一页 private int navigateFirstPage; //导航条上的最后一页 private int navigateLastPage;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo框架下完成的博客]]></title>
    <url>%2F2019%2F06%2F13%2Ftitle_%20Hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E5%AE%8C%E6%88%90%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天完成了Hexo框架下的博客 并且成功部署到Github上运行成功 以后会慢慢把笔记搬运过来 如果需要Java web Java SE jdbc的基础知识请移步到我的简书]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 2.Mybatis CRUD操作]]></title>
    <url>%2F2019%2F06%2F13%2FMybatis-2.Mybatis-CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Mybatis CRUD操作 注意 所有时间除查询以外都要手动提交事务sqlSession.commit();（因为sqlsession执行通过代理创建对象实现类 所以事务也在这一步进行） 在sql语句只有一个参数情况下例如delete form user where id= #{i}占位符里面的内容随便写 多个不允许 建议domain里面是什么就写什么 模糊查询时 要在提供字符串时添加百分号 String name =&quot;%王%&quot; #{}和${} 区别在于 第一种为PreparedStatement事务处理方式 而第二种为Statement 插入数据以后可以通过select last_insert_id();查询当刚生成的数据的id数(自增长情况下) 并且使用 保存方法以后 user中会赋予id值，而不进行此操作没有 由多个对象组成查询条件进行实际查询 创建QueryVo对象 封装User1234567891011121314/** * 封装对象的类 */public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; UserDao.xml 123&lt;select id="findByVo" parameterType="it.test.domain.QueryVo" resultType="it.test.domain.User"&gt; select * from user where username like #&#123;user.username&#125;&lt;/select&gt; Test类 1234567891011 @Testpublic void findByVo() &#123; QueryVo queryVo = new QueryVo(); User user = new User(); user.setUsername("%王%"); queryVo.setUser(user); List&lt;User&gt; userList = dao.findByVo(queryVo); for (User u : userList) &#123; System.out.println(u); &#125;&#125; 当出现类属性与数据库字段对应不一致(select)12345678910&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="it.test.dao.UserDao"&gt; &lt;resultMap id="userMap" type="it.test.domain.User"&gt;&lt;!-- 主键对应字段 property为java类属性 column为sql对应字段--&gt; &lt;id property="uid" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;/resultMap&gt; 通过这种方法声明java类属性与sql字段对应并在执行语句中resultMap 赋值成id名称 `userMap 完成的Mybatis文件操作过程1 主配置文件 resources下SqlMapConfig.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--主配置文件--&gt;&lt;configuration&gt;&lt;!-- 配置环境--&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;&lt;!-- 注解配置--&gt; &lt;mapper class="it.test.dao.UserDao"&gt;&lt;/mapper&gt;&lt;!-- xml配置--&gt; &lt;mapper resource="it/test/dao/UserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1.1 如果调用xml配置 放在resources下与dao包路径名相同的UserDao.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="it.test.dao.UserDao"&gt; &lt;resultMap id="userMap" type="it.test.domain.User"&gt;&lt;!-- 主键对应字段 property为java类属性 column为sql对应字段--&gt; &lt;id property="uid" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;/resultMap&gt;&lt;!-- 传入参数类型 反射相应的属性 sql语句的参数类型及传入参数类型--&gt; &lt;insert id="saveUser" parameterType="it.test.domain.User"&gt;&lt;!--配置插入操作后 获取插入数据的idkeyColumn数据库中的值 keyProperty实体类属性名 resultType数据类型 order操作执行后运行 --&gt;&lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id();&lt;/selectKey&gt; insert into user (username,address,sex,birthday)values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;update id="updateUser" parameterType="it.test.domain.User"&gt; update user set username=#&#123;username&#125;,sex=#&#123;sex&#125; where id=#&#123;id&#125;; &lt;/update&gt; &lt;delete id="deleteUser" parameterType="int"&gt; delete from user where id=#&#123;id&#125;; &lt;/delete&gt; &lt;select id="findById" parameterType="int" resultType="it.test.domain.User"&gt; select * from USER where id =#&#123;uid&#125;; &lt;/select&gt; &lt;!--使用注解开发 --&gt; &lt;!-- &lt;select id="findByName" parameterType="string" resultType="it.test.domain.User"&gt; select * from user where username like #&#123;username&#125;; &lt;/select&gt;--&gt; &lt;select id="findByVo" parameterType="it.test.domain.QueryVo" resultType="it.test.domain.User"&gt; select * from user where username like #&#123;user.username&#125; &lt;/select&gt;&lt;/mapper&gt; 2 User类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package it.test.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private int id; private String username; private String sex; private String address; private Date birthday; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", birthday=" + birthday + '&#125;'; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; 2.1 QueryVo类 12345678910111213141516package it.test.domain;/** * 封装对象的类 */public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 3 UserDao类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package it.test.dao;import it.test.domain.QueryVo;import it.test.domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123; @Select("select* from user ") /** * 查询所有 */ List&lt;User&gt; findAll(); /** * 添加用户 * @param user */ void saveUser(User user); /** * 更新用户 * @param user */ void updateUser(User user); /** * 删除用户 * @param id */ void deleteUser(int id); /** * 通过id查询 * @param id * @return */ User findById(int id); /** * 通过名称模糊查询 * @param name * @return */ @Select(" select * from user where username like #&#123;username&#125;") List&lt;User&gt; findByName(String name); /** * 封装多个实体类组合查询 * @param v * @return */ List&lt;User&gt; findByVo(QueryVo v);&#125; Test类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package it.test.dao;import it.test.domain.QueryVo;import it.test.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class FindTest &#123; InputStream in = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory build = null; SqlSession sqlSession = null; UserDao dao = null; @Before //方法运行前执行 public void init() throws IOException &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml");// 通过SqlSessionFactoryBuilder构建工厂 builder = new SqlSessionFactoryBuilder(); build = builder.build(in);// 通过工厂生产SqlSession对象 功能：动态代理生成实现类 sqlSession = build.openSession(); dao = sqlSession.getMapper(UserDao.class); &#125; @After public void close() throws IOException &#123;// 提交事务 不提交会自动回滚 sqlSession.commit(); in.close(); sqlSession.close(); &#125; @Test /** * 注解配置 */ public void finAll() &#123; List&lt;User&gt; list = dao.findAll(); for (User user : list) &#123; System.out.println(user); &#125; &#125; @Test/** *xml配置 */ public void saveUser() throws IOException &#123; User user = new User(); user.setUsername("于松江"); user.setSex("男"); user.setAddress("吉林省长春市"); user.setBirthday(new Date()); System.out.println("保存以前：" + user); dao.saveUser(user); System.out.println("保存以后：" + user); &#125; /** * 更新操作 * * @throws IOException */ @Test public void updateUser() throws IOException &#123; User user = new User(); user.setUsername("程泽琪"); user.setSex("女"); user.setId(50); dao.updateUser(user); &#125; @Test public void deleteUser() throws IOException &#123; dao.deleteUser(50); &#125; @Test public void findById() throws IOException &#123; User user = dao.findById(48); System.out.println(user.toString()); &#125; @Test public void findByName() &#123; List&lt;User&gt; userList = dao.findByName("%王%"); for (User user : userList) &#123; System.out.println(user); &#125; &#125; @Test public void findByVo() &#123; QueryVo queryVo = new QueryVo(); User user = new User(); user.setUsername("%王%"); queryVo.setUser(user); List&lt;User&gt; userList = dao.findByVo(queryVo); for (User u : userList) &#123; System.out.println(u); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 1.自定义Mybatis框架基本功能]]></title>
    <url>%2F2019%2F06%2F13%2FMybatis-1.%E8%87%AA%E5%AE%9A%E4%B9%89Mybatis%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Mybatis框架的基本使用流程 1234567891011121314151617// 1.创建连接获取配置文件 InputStream in= Resources.getResourceAsStream("sqlMapConfig.xml");// 2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory sessionFactory=builder.build(in);// 3.使用工厂生产SqlSession对象 SqlSession session = sessionFactory.openSession();// 4.使用对象创建Dao接口的代理对象 UserDao dao = session.getMapper(UserDao.class);// 5.使用代理对象执行方法 List&lt;User&gt; users = dao.findAll(); for (User user : users) &#123; System.out.println(user); &#125;// 6.关闭资源 session.close(); in.close(); 其中 创建SqlSessionFactory对象为创造者模式 创建 SqlSession对象为工厂模式 创建UserDao为代理模式 自定义Mybatis准备 public class Resources public class SqlSessionFactoryBuilder public interface SqlSessionFactory public interface SqlSession]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 本地博客转移]]></title>
    <url>%2F2019%2F06%2F07%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo 换电脑 复制博客路径下的如下文件 12345_config.yml package.json scaffolds/ source/ themes/ 新电脑安装Git Node.js 安装Hexo 1npm install hexo-cli -g 将Hexo创建出来到 123hexo init blog进入文件夹npm install 创建Git部署模块 1npm install hexo-deployer-git --save 创建搜索模块 1npm install hexo-generator-searchdb --save hexo clean g d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客网面试错题集 1]]></title>
    <url>%2F2019%2F05%2F31%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E8%AF%95%E9%94%99%E9%A2%98%E9%9B%86-1%2F</url>
    <content type="text"><![CDATA[面向对象的五大基本原则（抽象类原则不是） 单一职责原则（SRP） 开放封闭原则（OCP） 里氏替换原则（LSP） 依赖倒置原则（DIP） 接口隔离原则（ISP） Java语言特性Java致力于检查程序在编译和运行时的错误。Java虚拟机实现了跨平台接口类型检查帮助检查出许多开发早期出现的错误。Java自己操纵内存减少了内存出错的可能性。Java还实现了真数组，避免了覆盖数据的可能。 程序设计语言中，数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，这样的数组称之为“真数组”。实现了真数组为Java语言健壮性的特点之一。 程序运行顺序静态优先 父类优先 类的初始化顺序是： 1、初始化父类中的静态成员变量和静态代码块。 2、初始化子类中的静态成员变量和静态代码块。 3、初始化父类中的普通成员变量和代码块，再执行父类中的构造方法。 4、初始化子类中的普通成员变量和代码块，在执行子类中的构造方法。 静态方法也算静态代码块 如果两个相同等级 则按顺序执行 单例模式基本要点 构造函数私有 唯一实例*静态工厂方法每次产出一个新的实例 * volatile关键字 具有可见性 禁止指令重排序优化 出于运行速度考虑 java编辑器会把经常访问到的变量放到缓存中 读取变量则从缓存中读取 但在多线程中 内存中的值和缓存中的值可能出现不一样(一个线程更改 一个线程读取的还是原来缓存中的数据)。 volatile关键字用于限定变量只能从内存中读取 值一致保证变量安全但是他不能保证线程安全 Java表达式转型规则Java表达式转型规则由低到高转换：1、所有的byte,short,char型的值将被提升为int型；2、如果有一个操作数是long型，计算结果是long型；3、如果有一个操作数是float型，计算结果是float型；4、如果有一个操作数是double型，计算结果是double型；5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。 byte a1 = 2, a2 = 4, a3; short s = 16; a2 = s; a3 = a1 * a2; 3 4错误 char byte short参与运算会自动转换int需要强转 会在编译期报错如果被final修饰 为常量 可以进行赋值 123byte b1=1;final byte b2=2,b3=4;b1=b2+b3; switchcase中不加 break 终止 则会将下面的程序都运行 多线程线程通过使用synchronized关键字可获得对象的互斥锁定线程调度算法是平台独立的线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度多线程使用异常来使线程停止 Callable类的call()方法可以返回值和抛出异常CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程 调用run() 方法不能启动线程 只是普通方法 多线程wait() sleep()sleep是thread方法wait是object方法sleep终止不会释放线程锁wait会释放线程锁 线程安全Vector相当于一个线程安全的ListHashMap是非线程安全的，其对应的线程安全类是HashTableArraylist是非线程安全的，其对应的线程安全类是VectorStringBuffer是线程安全的，相当于一个线程安全的StringBuilderProperties继承了HashTable接口，是线程安全的 ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同切线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。hastable是对整个代码块加锁，而concurrenthasmap是使用分片锁，粒度较小，不用对整个代码块加锁，提高了读写速率。 ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据 。适用于 读取远远大于写入的操作。 CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。 运行题1234567891011121314public class Example&#123; String str = new String("good"); char[ ] ch = &#123; 'a' , 'b' , 'c' &#125;; public static void main(String args[])&#123; Example ex = new Example(); ex.change(ex.str,ex.ch); System.out.print(ex.str + " and "); System.out.print(ex.ch); &#125; public void change(String str,char ch[ ])&#123; str = "test ok"; ch[0] = 'g'; &#125;&#125; string 是引用型变量 引用地址值 所以当局部变量str引用常量池中test ok 后弹栈 原 str地址值不变 想更改需要将原str进行指定 哪些类能被继承 Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader Thread可以被继承，用于创建新的线程 Number类可以被继承，Integer，Float，Double等都继承自Number类 ClassLoader可以被继承，用户可以自定义类加载器 JSPexception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。 errorPage的实质就是JSP的异常处理机制,发生异常时才会跳转到 errorPage指定的页面，没必要给errorPage再设置一个errorPage。所以当errorPage属性存在时， isErrorPage属性值为false为了使用exception对象 所以将 isErrorPage属性值为true &lt;% expression %&gt; JSP脚本(Scriptlet)，是Java代码块。&lt;%= expression %&gt; JSP表达式(expression)，表达式是一个有返回值的式子，它返回的结果将由out.print()进行输出。 数组复制可以看到是native方法：native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。 可以将native方法比作Java程序同Ｃ程序的接口。 copyOf不是System的方法，而是Arrays的方法，可以看到本质上是调用的arraycopy方法。 重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。原则如下： 方法名一定要相同。 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。 如果参数个数不同，就不管它的参数类型了！ 如果参数个数相同，那么参数的类型或者参数的顺序必须不同。 方法的返回类型、修饰符可以相同，也可不同。编译一个以”.java”为后缀的源文件只能有一个与文件名相同的类，可以包含其他类 当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。 –《Java 编程思想》.class文件 生成多个 为内部类 一个源文件具有几个类和接口 javac编译后就有几个class文件 HashMap HashMap实际上是一个链表散列的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 HashMap的实例有俩个参数影响其性能：初始容量 和 装填因子 HashMap实现不同步，线程不安全。 HashTable线程安全 HashMap中的key-value都是存储在Entry中的 HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性 Hashtable 中， key 和 value 都不允许出现 null 值 HashMap是采用拉链法解决哈希冲突的 如图 继承父类为私有变量 可以继承 但不能对其操作 网络编程客户端Socket s = new Socket(“127.0.0.1”,6666);服务器 监听端口9000ServerSocket ss = new ServerSocket(6666); 接口与抽象类抽象方法没有方法体 抽象类特点:1.抽象类中可以构造方法2.抽象类中可以存在普通属性，方法，静态属性和方法。3.抽象类中可以存在抽象方法。4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。6.没有抽象方法的抽象类也不可以实例化 使用此特性创建工具类防止实例化 接口1.在接口中只有方法的声明，没有方法体。2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final3.在接口中的方法，永远都被public来修饰。4.接口中没有构造方法，也不能实例化接口的对象。5.接口可以实现多继承6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法7.则实现类定义为抽象类。 非抽象类实现接口后 两同两小一大原则：方法名相同，参数类型相同子类返回类型小于等于父类方法返回类型，子类抛出异常小于等于父类方法抛出异常，子类访问权限大于等于父类方法访问权限。 关于抽象类JDK 1.8以前，抽象类的方法默认访问权限为protectedJDK 1.8时，抽象类的方法默认访问权限变为default *关于接口JDK 1.8以前，接口中的方法必须是public的JDK 1.8时，接口中的方法可以是public的，也可以是default修饰的默认方法（如果实现类想要覆盖访问修饰符为public） static修饰的静态方法JDK 1.9时，接口中的方法可以是private的 * 声明的变量为 public static final 为全局常量其实现类可以调用** 接口中所有方法都是抽象方法 但抽象类中可以包含非抽象方法 ** 接口是特殊的抽象类为什么只能用public 修饰 （其前的abstract可以省略）因为接口可以被所有类实现 private不行既然被所有类实现 protected也不行static 修饰没有意义 因为变量是全局变量 方法没实现类 抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native、final访问修饰符修饰原因： private： 抽象方法要被实现 所以用private修饰就不能实现了 static：用static修饰 则可以通过接口调用 方法没有实现 调用没有意义 synchronized：该关键字修饰的方法被static修饰 则使用.class锁 修饰类方法使用this锁 抽象方法没有实体类对象 所以没this锁 修饰没用 锁应归其实现类所有 native ：本地方法 表示其底层用其他语言编写 交给本地执行 所以不行 Java关键字sizeofgoto synchronized 内部类静态内部类才可以声明静态方法静态方法不可以使用非静态变量抽象方法不可以有函数体 匿名内部类 ：因为匿名内部类没有名 所以没有办法定义构造器 数组String[] s=new String[10];默认初始化，基本类型是 0 ，布尔类型是 false ，引用类型为null所有 string[0]=null; Java内存区域 类所包含的类型变量 实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型 final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象 基础数据类型 1 2 正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。 float 如果是小数时需要添加f 不会自动转化3 boolean类型不能和任何类型进行转换，会报出类型异常错误4 选项中，byte的取值范围是-128—127。报出异常 基本数据类型 instanceof 对象类型 会编译不通过不会进行自动装箱低精度和高精度比较 会自动向上转换类型 Iterator支持从源集合中安全地删除对象，只需在** Iterator 上调用 remove()** 即可。这样做的好处是可以避免 ConcurrentModifiedException ，当打开 Iterator 迭代集合时，同时又在对集合进行修改。有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的remove() 方法是个安全的做法。 123for(int i=0;i&lt;list.size();i++)&#123; list.remove(...);&#125; 循环过程中list.size()的大小变化了就导致了错误。i在增加 list在减你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。 静态变量静态变量只能在类中定义 不能在方法中定义静态方法输入类 不属于方法 super.getClass().getName()返回包名+类名 Java语言默认字符集Unicode StringStringBuffer是线程安全StringBuilder是线程不安全 WEB 会话技术当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 12345671）.隐藏表单域：&lt;input type=&quot;hidden&quot;&gt;，非常适合不需要大量数据存储的会话应用。2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话 参数传递一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。一个方法可以改变一个对象参数的状态。一个方法不能让对象参数引用一个新的对象。]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSM 3.管理系统项目知识点]]></title>
    <url>%2F2019%2F05%2F30%2FSSM-3.%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[创建数据库表1234567891011121314151617181920212223CREATE TABLE product(id varchar2(32) default SYS_GUID() PRIMARY KEY, -- 如果没给赋值 则会生成uuid唯一编码productNum VARCHAR2(50) NOT NULL,productName VARCHAR2(50),cityName VARCHAR2(50),DepartureTime timestamp,productPrice Number,productDesc VARCHAR2(500),productStatus INT,CONSTRAINT product UNIQUE (id, productNum))insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values ('676C5BD1D35E429A8C2E114939C5685A', 'itcast-002', '北京三日游', '北京', to_timestamp('10-10-2018 10:10:00.000000', 'dd-mm-yyyy hh24:mi:ss.ff'), 1200, '不错的旅行', 1);insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values ('12B7ABF2A4C544568B0A7C69F36BF8B7', 'itcast-003', '上海五日游', '上海', to_timestamp('25-04-2018 14:30:00.000000', 'dd-mm-yyyy hh24:mi:ss.ff'), 1800, '魔都我来了', 0);insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values ('9F71F01CB448476DAFB309AA6DF9497F', 'itcast-001', '北京三日游', '北京', to_timestamp('10-10-2018 10:10:00.000000', 'dd-mm-yyyy hh24:mi:ss.ff'), 1200, '不错的旅行', 1); spring通过.properties连接数据库1234567&lt;context:property-placeholder location="classpath:druid.properties"&gt;&lt;/context:property-placeholder&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 页面跳转saveOne 跳转到 findAll 123456@RequestMapping(value = &quot;saveOne&quot;) public String saveOne(Product product) &#123; ps.saveOne(product); System.out.println(product); return &quot;redirect:findAll&quot;; &#125; pageHelper搜索博客下文章 spring-security搜索博客下文章 pl/sql developer修改数据select * from 表名 for update点小锁 可以手动更改数据 然后保存提交一个是提交 一个是回滚上一步操作 ##]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM 2.项目错误整合]]></title>
    <url>%2F2019%2F05%2F30%2FSSM-2.%E9%A1%B9%E7%9B%AE%E9%94%99%E8%AF%AF%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[oracle中文乱码问题解决 查看服务器端编码select userenv(‘language’) from dual;我实际查到的结果为:AMERICAN_AMERICA.ZHS16GBK 执行语句 select * from V$NLS_PARAMETERS查看第一行中PARAMETER项中为NLS_LANGUAGE 对应的VALUE项中是否和第一步得到的值一样。如果不是，需要设置环境变量.否则PLSQL客户端使用的编码和服务器端编码不一致,插入中文时就会出现乱码. 设置环境变量计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建设置变量名:NLS_LANG,变量值:第1步查到的值， 我的是 AMERICAN_AMERICA.ZHS16GBK 重新启动PLSQL,插入数据正常]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 1.高级管理]]></title>
    <url>%2F2019%2F05%2F29%2FMaven-1.%E9%AB%98%E7%BA%A7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[jar包 依赖maven工程要导入jar包的坐标，就必须要考虑解决jar包冲突。 maven工程是可以分父子依赖关系的。 凡是依赖别的项目后，拿到的别的项目的依赖包，都属于传递依赖。 比如：当前A项目，被B项目依赖。那么我们A项目中所有jar包都会传递到B项目中。 B项目开发者，如果再在B项目中导入一套ssm框架的jar包，对于B项目是直接依赖。 那么直接依赖的jar包就会把我们A项目传递过去的jar包覆盖掉。 如果B版本低 A版本高 就会造成原有A项目的功能不能正常运行 为了防止以上情况的出现。我们可以把A项目中主要jar包的坐标锁住，那么其他依赖该项目的项目中， 即便是有同名jar包直接依赖，也无法覆盖。 解决jar包冲突的方式一：第一声明优先原则：哪个jar包的坐标在靠上的位置，这个jar包就是先声明的。先声明的jar包坐标下的依赖包，可以优先进入项目中。 maven导入jar包中的一些概念：直接依赖：项目中直接导入的jar包，就是该项目的直接依赖包。传递依赖：项目中没有直接导入的jar包，可以通过项目直接依赖jar包传递到项目中去。 解决jar包冲突的方式二：路径近者优先原则。直接依赖路径比传递依赖路径近，那么最终项目进入的jar包会是路径近的直接依赖包。 解决jar包冲突的方式三【推荐使用】： 直接排除法。当我们要排除某个jar包下依赖包，在配置exclusions标签的时候，内部可以不写版本号。因为此时依赖包使用的版本和默认和本jar包一样。 标准ssm框架格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208&lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt; &lt;/properties&gt; &lt;!-- 锁定jar包版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 项目依赖jar包 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 添加tomcat7插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Maven项目模块化工程和模块的区别： 工程不等于完整的项目，模块也不等于完整的项目，一个完整的项目看的是代码，代码完整，就可以说这是一个完整的项目 和此项目是工程和模块没有关系。 工程天生只能使用自己内部资源，工程天生是独立的。后天可以和其他工程或模块建立关联关系。模块天生不是独立的，模块天生是属于父工程的，模块一旦创建，所有父工程的资源都可以使用。 父子工程直接，子模块天生集成父工程，可以使用父工程所有资源。子模块之间天生是没有任何关系的。 父子工程直接不用建立关系，继承关系是先天的，不需要手动建立。平级直接的引用叫依赖，依赖不是先天的，依赖是需要后天建立的]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 2.视图 索引 pl/sql编程语言]]></title>
    <url>%2F2019%2F05%2F28%2FOracle-2.%E8%A7%86%E5%9B%BE-%E7%B4%A2%E5%BC%95-pl-sql%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[视图—视图—视图的概念：视图就是提供一个查询的窗口，所有数据来自于原表。 —查询语句创建表create table emp as select * from scott.emp;select * from emp;—创建视图【必须有dba权限】create view v_emp as select ename, job from emp;—查询视图select * from v_emp;—修改视图[不推荐]update v_emp set job=’CLERK’ where ename=’ALLEN’;commit;—创建只读视图create view v_emp1 as select ename, job from emp with read only;—视图的作用？—第一：视图可以屏蔽掉一些敏感字段。—第二：保证总部和分部数据及时统一。 索引—索引–索引的概念：索引就是在表的列上构建一个二叉树—-达到大幅度提高查询效率的目的，但是索引会影响增删改的效率。—单列索引—创建单列索引create index idx_ename on emp(ename);单列索引触发规则，条件必须是索引列中的原始值。单行函数，模糊查询，都会影响索引的触发。即 索引失效or 如果一个有索引 一个没有索引也导致索引失效 select * from emp where ename=’SCOTT’—复合索引—创建复合索引create index idx_enamejob on emp(ename, job);复合索引中第一列为优先检索列如果要触发复合索引，必须包含有优先检索列中的原始值select * from emp where ename=’SCOTT’ and job=’xx’;—触发复合索引select * from emp where ename=’SCOTT’ or job=’xx’;—不触发索引 可以为每一种都加单列索引select * from emp where ename=’SCOTT’;—触发单列索引。 pl/sql编程语言—pl/sql编程语言—pl/sql编程语言是对sql语言的扩展，使得sql语言具有过程化编程的特性。—pl/sql编程语言比一般的过程化编程语言，更加灵活高效。—pl/sql编程语言主要用来编写存储过程和存储函数等。 —声明方法—赋值操作可以使用:=也可以使用into查询语句赋值declare i number(2) := 10; s varchar2(10) := ‘小明’; ena emp.ename%type;—引用型变量 emprow emp%rowtype;—记录型变量begin dbms_output.put_line(i); dbms_output.put_line(s); select ename into ena from emp where empno = 7788; dbms_output.put_line(ena); select * into emprow from emp where empno = 7788; dbms_output.put_line(emprow.ename || ‘的工作为：’ || emprow.job);end; —pl/sql中的if判断—输入小于18的数字，输出未成年—输入大于18小于40的数字，输出中年人—输入大于40的数字，输出老年人declare i number(3) := &ii;begin if i&lt;18 then dbms_output.put_line(‘未成年’); elsif i&lt;40 then dbms_output.put_line(‘中年人’); else dbms_output.put_line(‘老年人’); end if;end; —pl/sql中的loop循环—用三种方式输出1到10是个数字—while循环declare i number(2) := 1;begin while i&lt;11 loop dbms_output.put_line(i); i := i+1; end loop;end;—exit循环declare i number(2) := 1;begin loop exit when i&gt;10; dbms_output.put_line(i); i := i+1; end loop;end;—for循环declare begin for i in 1..10 loop dbms_output.put_line(i); end loop;end; —游标：可以存放多个对象，多行记录。—输出emp表中所有员工的姓名declare cursor c1 is select * from emp; emprow emp%rowtype;begin open c1; loop fetch c1 into emprow; exit when c1%notfound; dbms_output.put_line(emprow.ename); end loop; close c1;end; —–给指定部门员工涨工资declare cursor c2(eno emp.deptno%type) is select empno from emp where deptno = eno; en emp.empno%type;begin open c2(10); loop fetch c2 into en; exit when c2%notfound; update emp set sal=sal+100 where empno=en; commit; end loop; close c2;end;—-查询10号部门员工信息select * from emp where deptno = 10; 存储过程—存储过程 语法： 12345create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]ASbegin PLSQL 子程序体；End; 或者–存储过程：存储过程就是提前已经编译好的一段pl/sql语言，放置在数据库端——–可以直接被调用。这一段pl/sql一般都是固定步骤的业务。or replace 可以覆盖修改的—-给指定员工涨100块钱create or replace procedure p1(eno emp.empno%type)is begin update emp set sal=sal+100 where empno = eno; commit;end; select * from emp where empno = 7788;—-测试p1declare begin p1(7788);end; 存储函数 语法： 1234567 create or replace function 函数名(Name in type, Name in type, ...) return 数据类型 is 结果变量 数据类型;begin return(结果变量);end 函数名; —-通过存储函数实现计算指定员工的年薪—-存储过程和存储函数的参数都不能带长度—-存储函数的返回值类型不能带长度create or replace function f_yearsal(eno emp.empno%type) return numberis s number(10);begin select sal*12+nvl(comm, 0) into s from emp where empno = eno; return s;end; —-测试f_yearsal—-存储函数在调用的时候，返回值需要接收。declare s number(10);begin s := f_yearsal(7788); dbms_output.put_line(s);end; —out类型参数如何使用—使用存储过程来算年薪create or replace procedure p_yearsal(eno emp.empno%type, yearsal out number)is s number(10); c emp.comm%type;begin select sal*12, nvl(comm, 0) into s, c from emp where empno = eno; yearsal := s+c;end; —测试p_yearsaldeclare yearsal number(10);begin p_yearsal(7788, yearsal); dbms_output.put_line(yearsal);end; —-in和out类型参数的区别是什么？—凡是涉及到into查询语句赋值或者:=赋值操作的参数，都必须使用out来修饰。 存储过程和存储函数的区别—存储过程和存储函数的区别—语法区别：关键字不一样，————存储函数比存储过程多了两个return。—本质区别：存储函数有返回值，而存储过程没有返回值。———-如果存储过程想实现有返回值的业务，我们就必须使用out类型的参数。———-即便是存储过程使用了out类型的参数，起本质也不是真的有了返回值，———-而是在存储过程内部给out类型参数赋值，在执行完毕后，我们直接拿到输出类型参数的值。 —-我们可以使用存储函数有返回值的特性，来自定义函数。—-而存储过程不能用来自定义函数。—-案例需求：查询出员工姓名，员工所在部门名称。—-案例准备工作：把scott用户下的dept表复制到当前用户下。create table dept as select * from scott.dept;—-使用传统方式来实现案例需求select e.ename, d.dnamefrom emp e, dept dwhere e.deptno=d.deptno;—-使用存储函数来实现提供一个部门编号，输出一个部门名称。create or replace function fdna(dno dept.deptno%type) return dept.dname%typeis dna dept.dname%type;begin select dname into dna from dept where deptno = dno; return dna;end;—使用fdna存储函数来实现案例需求：查询出员工姓名，员工所在部门名称。select e.ename, fdna(e.deptno)from emp e; —触发器，就是制定一个规则，在我们做增删改操作的时候，—-只要满足该规则，自动触发，无需调用。—-语句级触发器：不包含有for each row的触发器。—-行级触发器：包含有for each row的就是行级触发器。———–加for each row是为了使用:old或者:new对象或者一行记录。 —语句级触发器—-插入一条记录，输出一个新员工入职create or replace trigger t1afterinserton persondeclare begin dbms_output.put_line(‘一个新员工入职’);end;—触发t1insert into person values (1, ‘小红’);commit;select * from person; —行级别触发器—不能给员工降薪—raise_application_error(-20001~-20999之间, ‘错误提示信息’);create or replace trigger t2beforeupdateon empfor each rowdeclare begin if :old.sal&gt;:new.sal then raise_application_error(-20001, ‘不能给员工降薪’); end if;end;—-触发t2select * from emp where empno = 7788;update emp set sal=sal-1 where empno = 7788;commit; —-触发器实现主键自增。【行级触发器】—分析：在用户做插入操作的之前，拿到即将插入的数据，——给该数据中的主键列赋值。create or replace trigger auidbeforeinserton personfor each rowdeclare begin select s_person.nextval into :new.pid from dual;end;–查询person表数据select * from person;—使用auid实现主键自增insert into person (pname) values (‘a’);commit;insert into person values (1, ‘b’);commit; Java操作oracale 示例—-oracle10g ojdbc14.jar—-oracle11g ojdbc6.jar 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class OracleDemo &#123; @Test public void javaCallOracle() throws Exception &#123; //加载数据库驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //得到Connection连接 Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@192.168.88.6:1521:orcl", "itheima", "itheima"); //得到预编译的Statement对象 PreparedStatement pstm = connection.prepareStatement("select * from emp where empno = ?"); //给参数赋值 pstm.setObject(1, 7788); //执行数据库查询操作 ResultSet rs = pstm.executeQuery(); //输出结果 while(rs.next())&#123; System.out.println(rs.getString("ename")); &#125; //释放资源 rs.close(); pstm.close(); connection.close(); &#125; /** * java调用存储过程 * &#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储函数使用 * &#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储过程使用 * @throws Exception */ @Test public void javaCallProcedure() throws Exception &#123; //加载数据库驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //得到Connection连接 Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@192.168.88.6:1521:orcl", "itheima", "itheima"); //得到预编译的Statement对象 CallableStatement pstm = connection.prepareCall("&#123;call p_yearsal(?, ?)&#125;"); //给参数赋值 pstm.setObject(1, 7788); pstm.registerOutParameter(2, OracleTypes.NUMBER); //执行数据库查询操作 pstm.execute(); //输出结果[第二个参数] System.out.println(pstm.getObject(2)); //释放资源 pstm.close(); connection.close(); &#125; /** * java调用存储函数 * &#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储函数使用 * &#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储过程使用 * @throws Exception */ @Test public void javaCallFunction() throws Exception &#123; //加载数据库驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //得到Connection连接 Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@192.168.88.6:1521:orcl", "itheima", "itheima"); //得到预编译的Statement对象 CallableStatement pstm = connection.prepareCall("&#123;?= call f_yearsal(?)&#125;"); //给参数赋值 pstm.setObject(2, 7788); pstm.registerOutParameter(1, OracleTypes.NUMBER); //执行数据库查询操作 pstm.execute(); //输出结果[第一个参数] System.out.println(pstm.getObject(1)); //释放资源 pstm.close(); connection.close(); &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 1.基本操作]]></title>
    <url>%2F2019%2F05%2F28%2FOracle-1.%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[** Mysql 与Oracle 基本查询方法相同 可以参考 ** Oracle为单独一个数据库 每个用户下有多张表 表分配在表空间中分号不要落下PLSQL Developer DataBase：172.18.139.161:1521/orcl 操作数据库–创建表空间create tablespace testdatafile ‘D:\java\test.dbf’size 100mautoextend onnext 10m;–删除表空间drop tablespace test; –创建用户create user rootidentified by tootdefault tablespace test; –给用户授权–oracle数据库中常用角色connect–连接角色，基本角色resource–开发者角色dba–超级管理员角色–给itheima用户授予dba角色grant dba to root; —切换到itheima用户下 —创建一个person表create table person( pid number(20), pname varchar2(10)); 操作表—修改表结构—添加一列alter table person add (gender number(1));—修改列类型alter table person modify gender char(1);—修改列名称alter table person rename column gender to sex;—删除一列alter table person drop column sex; 操作数据—查询表中记录select * from person;—-添加一条记录insert into person (pid, pname) values (1, ‘小明’);commit;—-修改一条记录update person set pname = ‘小马’ where pid = 1;commit; —-三个删除–删除表中全部记录delete from person;–删除表结构drop table person;–先删除表，再次创建表。效果等同于删除表中全部记录。–在数据量大的情况下，尤其在表中带有索引的情况下，该操作效率高。–索引可以提供查询效率，但是会影响增删改效率。truncate table person; 序列—-序列不真的属于任何一张表，但是可以逻辑和表做绑定。—-序列：默认从1开始，依次递增，主要用来给主键赋值使用。—-dual：虚表，只是为了补全语法，没有任何意义。create sequence s_person;select s_person.nextval from dual;—-添加一条记录insert into person (pid, pname) values (s_person.nextval, ‘小明’);commit;select * from person; 基本函数—-scott用户，密码tiger。–解锁scott用户 需要超级管理员权限alter user scott account unlock;–解锁scott用户的密码【此句也可以用来重置密码】alter user scott identified by tiger;–切换到scott用户下 –单行函数：作用于一行，返回一个值。—字符函数select upper(‘yes’) from dual;–YES 小写变大写select lower(‘YES’) from dual;–yes 大写变小写—-数值函数select round(56.16, -2) from dual;—四舍五入，后面的参数表示保留的位数 -2 小数点向前两位保留 100select trunc(56.16, -1) from dual;—直接截取，不再看后面位数的数字是否大于5. 50select mod(10, 3) from dual;—求余数 1—-日期函数—-查询出emp表中所有员工入职距离现在几天。sysdate系统天数select sysdate-e.hiredate from emp e;—-算出明天此刻select sysdate+1 from dual;—-查询出emp表中所有员工入职距离现在几月。select months_between(sysdate,e.hiredate) from emp e;—-查询出emp表中所有员工入职距离现在几年。select months_between(sysdate,e.hiredate)/12 from emp e;—-查询出emp表中所有员工入职距离现在几周。select round((sysdate-e.hiredate)/7) from emp e;—-转换函数—日期转字符串select to_char(sysdate, ‘fm yyyy-mm-dd hh24:mi:ss’) from dual; – fm 去掉0 4:19:39 hh24 24小时计数法—字符串转日期select to_date(‘2018-6-7 16:39:50’, ‘fm yyyy-mm-dd hh24:mi:ss’) from dual;—-通用函数—算出emp表中所有员工的年薪—-奖金里面有null值，如果null值和任意数字做算术运算，结果都是null。select e.sal*12+nvl(e.comm, 0) from emp e; 条件表达式—条件表达式—条件表达式的通用写法，mysql和oracle通用—给emp表中员工起中文名select e.ename, case e.ename when ‘SMITH’ then ‘曹贼’ when ‘ALLEN’ then ‘大耳贼’ when ‘WARD’ then ‘诸葛小儿’ –else ‘无名’ endfrom emp e;—判断emp表中员工工资，如果高于3000显示高收入，如果高于1500低于3000显示中等收入，—–其余显示低收入select e.sal, case when e.sal&gt;3000 then ‘高收入’ when e.sal&gt;1500 then ‘中等收入’ else ‘低收入’ endfrom emp e;—-oracle中除了起别名，都用单引号。—-oracle专用条件表达式select e.ename, decode(e.ename, ‘SMITH’, ‘曹贼’, ‘ALLEN’, ‘大耳贼’, ‘WARD’, ‘诸葛小儿’, ‘无名’) “中文名”from emp e; 聚合函数–多行函数【聚合函数】：作用于多行，返回一个值。select count(1) from emp;—查询总数量select sum(sal) from emp;—工资总和select max(sal) from emp;—最大工资select min(sal) from emp;—最低工资select avg(sal) from emp;—平均工资 分组查询—分组查询—查询出每个部门的平均工资—分组查询中，出现在group by后面的原始列，才能出现在select后面—没有出现在group by后面的列，想在select后面，必须加上聚合函数。—聚合函数有一个特性，可以把多行记录变成一个值。select e.deptno, avg(e.sal)–, e.enamefrom emp egroup by e.deptno;—查询出平均工资高于2000的部门信息select e.deptno, avg(e.sal) asalfrom emp egroup by e.deptnohaving avg(e.sal)&gt;2000;— 所有条件都不能使用别名来判断。having where 不能用别名–比如下面的条件语句也不能使用别名当条件 where s&gt;1500; 是错的select ename, sal s from emp where sal&gt;1500; —查询出每个部门工资高于800的员工的平均工资select e.deptno, avg(e.sal) asalfrom emp ewhere e.sal&gt;800group by e.deptno;—-where是过滤分组前的数据，having是过滤分组后的数据。—表现形式：where必须在group by之前，having是在group by之后。—查询出每个部门工资高于800的员工的平均工资—然后再查询出平均工资高于2000的部门select e.deptno, avg(e.sal) asalfrom emp ewhere e.sal&gt;800group by e.deptnohaving avg(e.sal)&gt;2000; 多表查询—多表查询中的一些概念—笛卡尔积select * from emp e, dept d;—等值连接select * from emp e, dept dwhere e.deptno=d.deptno;—内连接 和等值连接相同select * from emp e inner join dept don e.deptno = d.deptno;—查询出所有部门，以及部门下的员工信息。【外连接】select * from emp e right join dept don e.deptno=d.deptno;—查询所有员工信息，以及员工所属部门select * from emp e left join dept don e.deptno=d.deptno;—oracle中专用外连接select * from emp e, dept dwhere e.deptno(+) = d.deptno; select * from emp;—查询出员工姓名，员工领导姓名—自连接：自连接其实就是站在不同的角度把一张表看成多张表。select e1.ename, e2.enamefrom emp e1, emp e2where e1.mgr = e2.empno;——查询出员工姓名，员工部门名称，员工领导姓名，员工领导部门名称select e1.ename, d1.dname, e2.ename, d2.dnamefrom emp e1, emp e2, dept d1, dept d2where e1.mgr = e2.empnoand e1.deptno=d1.deptnoand e2.deptno=d2.deptno; 子查询—子查询—子查询返回一个值—查询出工资和SCOTT一样的员工信息 如果子查询条件是主键 确保值唯一 可以使用 = 连接子查询select * from emp where sal in(select sal from emp where ename = ‘SCOTT’)—子查询返回一个集合—查询出工资和10号部门任意员工一样的员工信息select * from emp where sal in(select sal from emp where deptno = 10);—子查询返回一张表—查询出每个部门最低工资，和最低工资员工姓名，和该员工所在部门名称—1，先查询出每个部门最低工资select deptno, min(sal) msalfrom empgroup by deptno;—2，三表联查，得到最终结果。select t.deptno, t.msal, e.ename, d.dnamefrom (select deptno, min(sal) msal from emp group by deptno) t, emp e, dept dwhere t.deptno = e.deptnoand t.msal = e.saland e.deptno = d.deptno; 分页—-oracle中的分页—rownum行号：当我们做select操作的时候，–每查询出一行记录，就会在该行上加上一个行号，–行号从1开始，依次递增，不能跳着走。 —-排序操作会影响rownum的顺序select rownum, e.* from emp e order by e.sal desc—-如果涉及到排序，但是还要使用rownum的话，我们可以再次嵌套查询。select rownum, t.* from(select rownum, e.* from emp e order by e.sal desc) t; —-emp表工资倒叙排列后，每页五条记录，查询第二页。—-rownum行号不能写上大于一个正数。* Oracle分页查询格式 ** select * from( select rownum rn, tt. from( select * from emp order by sal desc ) tt where rownum&lt;11) where rn&gt;5]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机 1.Java内存区域]]></title>
    <url>%2F2019%2F05%2F28%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-1.Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[运行时数据区域 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号提示器 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 分支 循环 跳转 异常处理 线程回鹘等基础功能都需要该计数器完成 每条线程都需要一个独立的程序计数器 计数器间互不影响 独立存储 称他为线程私有的内存 Java虚拟机栈线程私有 生命周期与线程相同每个方法在执行的同时会创建一个栈针用于储存局部变量表 操作数栈 动态链接 方法出口等 每一个方法从调用直到执行完成的过程，就对应一个栈帧入栈到出栈的过程 局部变量表存放编译期可知的各种基本数据类型 对象引用类型(指向地址值) returnAddress类型(指向一条字节码指令的地址) 本地方法栈与虚拟机栈所发挥的作用非常类似 区别碍于虚拟机栈为虚拟机执行java方法 而本地方法栈则为虚拟机使用到的native方法服务 Java堆内存最大的一块Java堆是被线程共享的一块内存区域 存放对象实例所有的对象实例以及数组都在堆上分配]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM 1.SSM框架整合]]></title>
    <url>%2F2019%2F05%2F27%2FSSM-1.SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[SSM框架整合 将其他框架整合到Spring框架上先测试单独的框架是否可用在进行组合 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;!-- 切入点表达式 事务控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring mvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 声明式事务管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc连接池技术--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Springtest123456789public class AccountTest &#123; @Test public void testFindAll()&#123; ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml"); AccountService service = ac.getBean("accountService", AccountService.class); service.findAll(); &#125;&#125; applicationContext.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 扫描的包 不扫描与spring mvc有关的--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;!-- 不扫描该注解--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; AccountService1234567891011121314@Service(value = "accountService")public class AccountServiceImpl implements AccountService &#123; @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层 查询所有用户运行....."); return null; &#125; @Override public void saveAccount(Account account) &#123; System.out.println("业务层 储存用户运行....."); &#125;&#125; 运行结果证明Spring框架搭建完毕 SpringMVC 及 SpringMVC 整合 SpringSpringMVCspringmvc.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 扫描包 不扫描 只扫描controller注解--&gt; &lt;context:component-scan base-package="it.test"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- 前端控制器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 去除拦截静态资源 --&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;&lt;!-- 配置springmvc 注解支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; AccountController1234567891011@Controller@RequestMapping(value = "/account")public class AccountController &#123; @RequestMapping(value = "/findAll") public String findAll()&#123; System.out.println("表现层 findAll方法运行了....."); return "success"; &#125;&#125; web.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 配置文件加载时间为服务器启动即加载--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置拦截器 编码为utf-8--&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; index success 省略不写SpringMVC 整合 Spring我们在web.xml 中配置了 启动服务器加载springmvc.xml 来实现springmvc的功能但我们如何实现 加载 applicationContext.xml 文件来实现整合呢 servletContext对象只有一个监听器已由spring提供 将其监听器配置到web.xml 监听器 ContextLoaderListenerorg.springframework.web.context.ContextLoaderListener该监听器 只能加载WEB-INF目录下的applicationContext.xml的配置文件配置时应手动提供路径 其类中contextInitialized对应着ServletContext 被创建时启动的监听方法其类中 (配置监听器调用的方法)contextDestroyed对应着ServletContext 被销毁时的监听方法 12345678 &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 配置类路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 配置文件加载时间为服务器启动即加载--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置拦截器 编码为utf-8--&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!-- 配置 Spring监听器--&gt;&lt;!-- ContextLoaderListener （只能加载WEB-INF目录下的applicationContext.xml的配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 配置类路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 123456789101112131415161718@Controller@RequestMapping(value = "/account")public class AccountController &#123; @Autowired private AccountService accountService; public void setService(AccountService service) &#123; this.accountService = service; &#125; @RequestMapping(value = "/findAll") public String findAll()&#123; accountService.findAll(); System.out.println("表现层 findAll方法运行了....."); return "success"; &#125;&#125; Mybatis Spring整合可以看作将SqlMapConfig.xml配置到applicationContext.xml中 通过配置文件方式配置 数据库连接所需要的参数 1234567&lt;context:property-placeholder location="classpath:druid.properties"&gt;&lt;/context:property-placeholder&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 步骤1 整合 配置连接池对象 配置sqlSession工厂 引入连接池 配置映射扫描包 需要我们提供数据库连接池文章中使用Spring提供的DriverManagerDataSource引入SqlSessionFactory对象为Spring提供的SqlSessionFactoryBean引入的映射扫描器对象为Spring提供的 MapperScannerConfigurer 配置连接的目的与SqlMapConfig.xml相同引入SqlSessionFactory对象目的是可以获取到代理相应的dao实现类引入的映射扫描器对象目的 提供扫描的包确定使用的接口 将对象放入spring容器中 代码123456789&lt;!--配置sqlSession工厂 引入连接池--&gt; &lt;bean id="sqlSessionFactory " class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 映射扫描配置--&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;!-- 包名--&gt; &lt;property name="basePackage" value="it.test.dao"&gt;&lt;/property&gt; &lt;/bean&gt; 步骤2 声明式事务控制Mybatis默认需要手动提交事务 所以整合到Spring框架以后 我们可以通过AOP切面编程控制事务详细步骤查看Spring 声明式事务控制文章 代码1234567891011121314151617181920212223&lt;!-- mybatis的增删改操作需要手动提交 所谓我们提供声明式事务控制 来进行操作--&gt;&lt;!-- 配置声明式事务控制--&gt;&lt;!-- 配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置事务通知 引用事务管理器--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt;&lt;!-- ropagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 配置aop切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!-- 建立连接--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 代码汇总pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day03_SSM框架整合&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;Day03_SSM框架整合 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;!-- 切入点表达式 事务控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring mvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 声明式事务管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc连接池技术--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;Day03_SSM框架整合&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 配置文件加载时间为服务器启动即加载--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置拦截器 编码为utf-8--&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!-- 配置 Spring监听器--&gt;&lt;!-- ContextLoaderListener （只能加载WEB-INF目录下的applicationContext.xml的配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 配置类路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 扫描的包 不扫描与spring mvc有关的--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;!-- 不扫描该注解--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- 整合 Mybaits--&gt;&lt;!-- 配置连接池对象--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--配置sqlSession工厂 引入连接池--&gt; &lt;bean id="sqlSessionFactory " class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 映射扫描配置--&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;!-- 包名--&gt; &lt;property name="basePackage" value="it.test.dao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- mybatis的增删改操作需要手动提交 所谓我们提供声明式事务控制 来进行操作--&gt;&lt;!-- 配置声明式事务控制--&gt;&lt;!-- 配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置事务通知 引用事务管理器--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt;&lt;!-- ropagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 配置aop切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!-- 建立连接--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; springmvc.xml 123456789101112131415161718192021222324252627282930 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 扫描包 不扫描 只扫描controller注解--&gt; &lt;context:component-scan base-package="it.test"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- 前端控制器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 去除拦截静态资源 --&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;&lt;!-- 配置springmvc 注解支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; Dao123456789101112131415161718192021/** * 通过Mybatis 实现 */@Repositorypublic interface AccountDao &#123; /** * 查询所有用户 * @return List&lt;Account&gt; */ @Select("select * from spring_account") List&lt;Account&gt; findAll(); /** * 储存用户 * @param account */ @Insert("insert into spring_account(name ,money) values (#&#123;name&#125;,#&#123;money&#125;)") void saveAccount(Account account);&#125; service123456789101112131415161718192021222324@Service(value = "accountService")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao dao; public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层 查询所有用户运行....."); return dao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println("业务层 储存用户运行....."); dao.saveAccount(account); &#125;&#125; controller123456789101112131415161718192021222324252627282930313233@Controller@RequestMapping(value = "/account")public class AccountController &#123; @Autowired private AccountService accountService; public void setService(AccountService service) &#123; this.accountService = service; &#125; @RequestMapping(value = "/findAll") public String findAll(Model model)&#123; List&lt;Account&gt; accountList = accountService.findAll(); model.addAttribute("accountList",accountList); System.out.println(accountList); return "success"; &#125; @RequestMapping(value = "/saveAccount") public void saveAccount(Account account, HttpServletRequest request, HttpServletResponse response)&#123; accountService.saveAccount(account); System.out.println("表现层 saveAccount方法运行了....."); try &#123;// 重定向跳转页面 response.sendRedirect(request.getContextPath()+"/account/findAll"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; success.jsp123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;success&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;成功查询！&lt;/h2&gt;&lt;c:forEach items="$&#123;accountList&#125;" var="account"&gt; $&#123;account.name&#125; $&#123;account.money&#125;&lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring /与*]]></title>
    <url>%2F2019%2F05%2F26%2FSpring%E9%80%9A%E9%85%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Serlvet&lt; url-pattern&gt;/*&lt;/ url-pattern&gt;/* 会覆盖掉其他所有的servlet，包括servlet容器提供的，例如default servlet 和 the JSP servlet。因为除去精确匹配，优先级排第二的就是路径匹配，它的优先级要比扩展名匹配和缺省匹配优先级高。一般/*只在过滤器中使用。 &lt; url-pattern&gt;/&lt; /url-pattern&gt;/ 不会覆盖其他的servlet。仅仅会取代servlet容器内置的缺省servlet，它通常会触发静态资源和目录，例如CSS/JS/image/ 等文件。servlet容器内置的缺省servlet同时能够处理HTTP缓存请求，媒体文件流（音频、视频）、和文件下载摘要。通常，你最好不要重写内置缺省的servlet，如果要覆盖重写，你必须实现上面列出的任务。这个模式是最后匹配的，jsp文件都是属于扩展名匹配，优先级高于这个缺省匹配。 即 /不会匹配到.jsp .css 静态文件 不会拦截除静态资源外的所有请求 Interceptor不能以/结尾的原因 因为他没这个功能** interceptor 和 servlet匹配机制不同 ** 详细说明Servlet、Filter、Interceptor的url匹配规则]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>通配符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 6.异常处理&拦截器]]></title>
    <url>%2F2019%2F05%2F26%2FSpringMVC-6.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%26%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[异常处理如果不处理 则会将异常显示在页面上 十分不友好 所以我们需要跳转到指定页面 显示错误 异常处理基本流程 需求需要自定义异常处理器 代码controller12345678910111213141516@Controller@RequestMapping(value = "/test")public class ExceptionController &#123; @RequestMapping(value = "/testException") public String testException() throws MyException &#123;// 捕获异常 try &#123; int a=10/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new MyException("程序出现错误了(ﾟДﾟ*)ﾉ"); &#125; return "success"; &#125;&#125; MyException12345678910111213141516public class MyException extends Exception &#123; private String message; public MyException(String message) &#123; super(message); this.message=message; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; MyExceptionResolver1234567891011121314151617181920212223242526/** * 自定义异常处理器 * 在SpringMVC中配置 */public class MyExceptionResolver implements HandlerExceptionResolver &#123; @Override /** * exception e 为捕获到的异常 */ public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;// 如果异常是MyException则强转 MyException exception = null; if (e instanceof MyException) &#123; exception = (MyException) e; &#125; else &#123; exception = new MyException("ヽ(ｏ`皿′ｏ)ﾉ不清楚什么错误呢 请联系管理员！"); &#125;// 设置跳转错误页面 并将消息显示 ModelAndView view = new ModelAndView(); view.addObject("exception",exception.getMessage()); view.setViewName("error"); return view; &#125;&#125; springmvc.xml12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置自定义异常处理器--&gt; &lt;bean id="myExceptionResolver" class="it.test.exception.MyExceptionResolver"&gt;&lt;/bean&gt;&lt;!-- &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; error123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Exception&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;exception&#125;&lt;/body&gt;&lt;/html&gt; 拦截器以servlet为分界前后 前提jdk1.8版本对接口进行了增强 可以拥有静态方法和default方法，所谓default方法既是使用default关键字来修饰的方法。一个接口可以有多个静态方法和default方法，没有个数限制 如果多个接口出现方法名和参数列表相同的defult方法，这个时候就必须要在实现类里面显式重写default的方法，而关于default的方法的重写,我们在实现类中不需要继续出现default关键字也不能出现default关键字。重写的default方法必须的访问权限必须是public 如果使用则直接调用方法默认值 如果需要自己定义 则复写方法 作用功能Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 区别 过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 要求必须实现：HandlerInterceptor 接口。 实现** 要求必须实现：HandlerInterceptor 接口 **springmvc.xml配置拦截器 123456789101112&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt;&lt;mvc:interceptor&gt;&lt;!-- 哪些方法进行拦截 --&gt;&lt;mvc:mapping path="/user/*"/&gt;&lt;!-- 哪些方法不进行拦截&lt;mvc:exclude-mapping path=""/&gt;--&gt;&lt;!-- 注册拦截器对象 --&gt;&lt;bean class="cn.itcast.demo1.MyInterceptor1"/&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器链流程图 HandlerInterceptor接口中的方法 preHandle方法是controller方法执行前拦截的方法,可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 afterCompletion方法是在JSP执行后执行 request或者response不能再跳转页面了 结果显示： 代码MyInterceptor1 MyInterceptor212345678910111213141516171819202122232425262728293031323334/** * 拦截器 作用于servlet */public class MyInterceptor1 implements HandlerInterceptor &#123; @Override /** * consroller执行前执行 如果false则不放行 true放行 可以跳转页面 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("MyInterceptor1 preHandle执行了......."); // 转发 拦截 不会有后续操作// request.getRequestDispatcher("/WEB-INF/pages/happy.jsp").forward(request,response);// return false; return true; &#125; @Override /** * consroller执行后 jsp跳转执行前执行 */ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("MyInterceptor1 postHandle执行了.......");// 转发 会打印success.jsp 但不会跳转// request.getRequestDispatcher("/WEB-INF/pages/happy.jsp").forward(request,response); &#125; @Override /** * jsp执行后执行 */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("MyInterceptor1 afterCompletion执行了........."); &#125;&#125; 12345678910111213141516171819202122232425262728public class MyInterceptor2 implements HandlerInterceptor &#123; @Override /** * consroller执行前执行 如果false则不放行 true放行 可以跳转页面 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("MyInterceptor2 preHandle执行了......."); return true; &#125; @Override /** * consroller执行后 jsp跳转执行前执行 */ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("MyInterceptor2 postHandle执行了.......");// 转发// request.getRequestDispatcher("/WEB-INF/pages/happy.jsp").forward(request,response); &#125; @Override /** * jsp执行后执行 */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("MyInterceptor2 afterCompletion执行了........."); &#125;&#125; MyController1234567891011@Controller@RequestMapping(value = "/test")public class MyController &#123; @RequestMapping(value = "/testInterceptor") public String testInterceptor()&#123; System.out.println("MyController控制器已运行......"); return "success"; &#125;&#125; springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt;&lt;!-- 对哪些方法拦截 对哪些方法不拦截 mvc:exclude-mapping path=""--&gt; &lt;mvc:mapping path="/test/**"/&gt;&lt;!-- 注册拦截对象--&gt; &lt;bean class="it.test.interceptor.MyInterceptor1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/test/**"/&gt; &lt;bean class="it.test.interceptor.MyInterceptor2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 5.文件上传]]></title>
    <url>%2F2019%2F05%2F21%2FSpringMVC-5.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[** 将项目部署到tomcat服务器下 选择 war 将项目部署在项目目录下用war exploded** 传统方式的文件上传文件上传前提 form 表单的 enctype 取值必须是：multipart/form-data(默认值是:application/x-www-form-urlencoded)enctype:是表单请求正文的类型 realPath(&quot;\upload\&quot;): 代表的路径为类路径 即：target下项目目录C:\Users\CZQYY\IdeaProjects\Mybatis_study1\SpringMVC_study\Day02_SpringMVC文件上传\target\Day02_SpringMVC文件上传\upload\ 导入jar包commons-fileuploadcommons-io 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 代码index.jsp1234&lt;form action="test/testOldUpLoad" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="upload"&gt;&lt;br&gt; &lt;input type="submit" value="上传文件"&gt;&lt;/form&gt; Mycontroller.java1234567891011121314151617181920212223242526272829303132333435363738394041@Controller@RequestMapping(value = "test")public class MyController &#123; @RequestMapping(value = "testOldUpLoad") public String testOldUpLoad(HttpServletRequest request) &#123;// 先获取到想要上传的路径 位于类目录下 String path = request.getSession().getServletContext().getRealPath("/upload/"); File file = new File(path); if (!file.exists()) &#123; boolean mkdirs = file.mkdirs(); if (!mkdirs)&#123; throw new RuntimeException("创建上传路径错误"); &#125; &#125;// 创建文件项工厂 DiskFileItemFactory df=new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(df);// 解析request请求 try &#123; List&lt;FileItem&gt; list = fileUpload.parseRequest(request); for (FileItem item : list) &#123;// 如果文件项不是普通的表格 if (!item.isFormField())&#123;// 获取上传文件名字 String fieldName = item.getName();// 为防止覆盖为名称添加UUID 并把其中的-全改 fieldName = UUID.randomUUID().toString().replace("-", "")+"_"+fieldName;// 上传文件 item.write(new File(path,fieldName)); &#125; &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(path); return "success"; &#125;&#125; 结果： SpringMVC文件上传原理文件提交后 通过request请求 被前端控制器拦截将request请求发送给 配置文件解析器CommonsMultipartResolver通过文件解析器解析返回前端控制器上传文件对象前段控制器将上传文件对象 传递给对应方法作为参数使用 需求1234567 &lt;!-- id 的值是固定的--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;!-- 设置上传文件最大不超过5MB--&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt; 方法参数名必须和name一致 代码index.jsp1234567&lt;h3&gt;SpringMVC上传方式&lt;/h3&gt;&lt;form action="test/testNewUpLoad" method="post" enctype="multipart/form-data"&gt; &lt;%-- name 方法参数名必须和name一致--%&gt; &lt;input type="file" name="upload"&gt;&lt;br&gt; &lt;input type="submit" value="上传文件"&gt;&lt;/form&gt; springmvc.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- id 的值是固定的--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;!-- 设置上传文件最大不超过5MB--&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; MyController.java1234567891011121314151617181920212223242526 @RequestMapping(value = "testNewUpLoad") /** * 传入配置文件解析器 */ public String testNewUpLoad(HttpServletRequest request, MultipartFile upload)&#123; // 先获取到想要上传的路径 位于类目录下 String path = request.getSession().getServletContext().getRealPath("/upload/"); File file = new File(path); if (!file.exists()) &#123; boolean mkdirs = file.mkdirs(); if (!mkdirs)&#123; throw new RuntimeException("创建上传路径错误"); &#125; &#125; String fileName = upload.getOriginalFilename(); fileName = UUID.randomUUID().toString().replace("-", "")+"_"+fileName; System.out.println(fileName);// 上传文件 try &#123; upload.transferTo(new File(path,fileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return "success"; &#125;&#125; 跨服务器上传图片服务器的两个端口号要更改 避免端口冲突 需求http://localhost:9090/uploads/ 在其项目文件target下提供uploads文件夹 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; 正常情况下服务器默认不支持写入 要在conf/web.xml中开启 123456789101112131415161718 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;!-- 添加，解决jersey上传服务器403错误 --&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; java实现123456789101112131415161718 @RequestMapping(value = "testNewUpLoad2") public String testNewUpLoad2(MultipartFile upload) throws IOException &#123;// 定义上传服务器路径 String path = "http://localhost:9090/uploads/"; String fileName = upload.getOriginalFilename(); fileName = UUID.randomUUID().toString().replace("-", "") + "_" + fileName; System.out.println(fileName);// 创建客户端对象 Client client = Client.create();// 连接图片服务器// http://localhost:9090/uploads/xxx.png WebResource resource = client.resource(path + fileName);// 上传文件 resource.put(upload.getBytes()); return "success"; &#125; 结果：]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 4.控制器方法返回值分类]]></title>
    <url>%2F2019%2F05%2F20%2FSpringMVC-4.%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[字符串12345678@RequestMapping(value = "testString") public String testString(Model model)&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); model.addAttribute("user",user); return "success"; &#125; 1$&#123;requestScope.user.uname&#125; 1&lt;a href="test/testVoid"&gt;testVoid&lt;/a&gt;&lt;br&gt; voidServlet 原始 API 可以作为控制器中方法的参数但此方法不会调用视图解析器 123456789101112@RequestMapping("/testVoid")public void testVoid(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); String contextPath = request.getServletPath(); System.out.println(contextPath); &#125; catch (ServletException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; ModelAndViewModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值三个常用方法： modelAndView.addObject() 通过调用ModelMap.addAttribute 向Request域中添加键值对 modelAndView.getModelMap()获取ModelMap对象 modelAndView.setViewName()设置视图声明跳转文件名 否则默认为 请求路径与RequestMapping的值保持一致xxx.jsp1234567891011 public ModelAndView testModelAndView()&#123; ModelAndView modelAndView = new ModelAndView(); User user = new User(); user.setUname("于松江"); user.setAge(13); modelAndView.addObject("user",user);// 内部获取ModelMap方法 modelAndView.getModelMap().addAttribute("user",user); modelAndView.setViewName("success");// 声明跳转文件名 否则默认为 请求路径testModelAndView return modelAndView; &#125; 1$&#123;requestScope.user.uname&#125; 结果： ResponseBody 响应 json 数据该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端 json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包 123456789101112131415 &lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 mvc:resources标签配置不过滤 location元素表示webapp目录下的包下的所有文件 mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b 1234&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt; &lt;!-- 样式 --&gt;&lt;mvc:resources location="/images/" mapping="/images/**"/&gt; &lt;!-- 图片 --&gt;&lt;mvc:resources location="/js/" mapping="/js/**"/&gt; &lt;!-- javascript --&gt; 代码index.jsp1234567891011121314151617181920212223242526272829303132333435&lt;%-- User: CZQYY Date: 2019/5/20 Time: 14:58 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;script&gt; $(function () &#123; $("#btn").click(function () &#123; $.post("test/testJson", &#123;uname:"于松江",age:18&#125;, function (user) &#123; alert(user.uname); alert(user.age); &#125;,"json"); &#125;) &#125;)&lt;/script&gt;&lt;body&gt;&lt;a href="test/testVoid"&gt;testVoid&lt;/a&gt;&lt;br&gt;&lt;a href="test/testString"&gt;testString&lt;/a&gt;&lt;br&gt;&lt;a href="test/testModelAndView"&gt;ModelAndView&lt;/a&gt;&lt;br&gt;&lt;button id="btn"&gt;Json请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; web.xml123456789101112131415161718192021222324252627282930&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; success.jsp123456789101112131415161718&lt;%-- User: CZQYY Date: 2019/5/20 Time: 14:57 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; 成功！！！！&lt;/h1&gt;$&#123;requestScope.user.uname&#125;&lt;/body&gt;&lt;/html&gt; CommonAnno123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import it.test.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;@Controller@RequestMapping(value = "/test")public class CommonAnno &#123; /** * 无返回值 */ @RequestMapping("/testVoid") public void testVoid(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); String contextPath = request.getServletPath(); System.out.println(contextPath); &#125; catch (ServletException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @RequestMapping(value = "testString") public String testString(Model model)&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); model.addAttribute("user",user); return "success"; &#125; @RequestMapping(value = "testModelAndView") /** * ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。 */ public ModelAndView testModelAndView()&#123; ModelAndView modelAndView = new ModelAndView(); User user = new User(); user.setUname("于松江"); user.setAge(13); modelAndView.addObject("user",user);// 内部获取ModelMap方法 modelAndView.getModelMap().addAttribute("user",user); modelAndView.setViewName("success");// 声明跳转文件名 否则默认为 请求路径testModelAndView return modelAndView; &#125; @RequestMapping(value = "testJson") public @ResponseBody User testJson( User user)&#123;/* try &#123;// 后台通过 URLDecoder.decode解码 String s = URLDecoder.decode(body, "UTF-8"); System.out.println(s); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;*/ System.out.println(user); user.setUname("程泽琪"); return user; &#125;&#125; springmvc.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置扫描--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt;&lt;!-- 配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置忽略解析路径 可以加载静态解析--&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 3.常用注解]]></title>
    <url>%2F2019%2F05%2F15%2FSpringMVC-3.%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Model接口 是将键值对存入request域中取值调用其实现类modelMap 常用注解RequestParam把请求中指定名称的参数给控制器中的形参赋值。作用于参数上value：请求参数中的名称。required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。defaultValue：默认值 如果没有提供 则自定传入默认值@RequestParam(name = &quot;page&quot;, required = true, defaultValue = &quot;1&quot;)例： 如果不用该注解修饰 对应不上则打印null结果： 1&lt;a href="test/testRequestParam?username=于松江"&gt;testRequestParam&lt;/a&gt; 12345@RequestMapping(value = "/testRequestParam") public String testRequestParam(@RequestParam(value = "username") String userName)&#123; System.out.println(userName); return "success"; &#125; RequestBody用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。例：结果： 12345&lt;form action="test/testRequestBody" method="post"&gt; 账号：&lt;input type="text" name="userName"&gt;&lt;br&gt; 密码：&lt;input type="text" name="passWord"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 12345@RequestMapping(value = "/testRequestBody") public String testRequestBody(@RequestBody String spring)&#123; System.out.println(spring); return "success"; &#125; PathVaribale用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。value：用于指定 url 中占位符名称。required：是否必须提供占位符。结果： 12345@RequestMapping(value = "/testPathVariable/&#123;sid&#125;") public String testPathVariable(@PathVariable("sid") int id)&#123; System.out.println(id); return "success"; &#125; 1&lt;a href="test/testPathVariable/10"&gt;pathVariable&lt;/a&gt; RequestHeader用于获取请求消息头。value：提供消息头名称required：是否必须有此消息头结果： 12345@RequestMapping(value = "/testRequestHeader") public String testRequestHeader(@RequestHeader(value = "Accept-Language")String header)&#123; System.out.println(header); return "success"; &#125; 1&lt;a href="test/testRequestHeader"&gt;RequestHeader&lt;/a&gt; CookieValue用于把指定 cookie 名称的值传入控制器方法参数。value：指定 cookie 的名称。required：是否必须有此 cookie。结果： 12345@RequestMapping(value = "/testCookieValue") public String testCookieValue(@CookieValue(value="JSESSIONID") String value)&#123; System.out.println(value); return "success"; &#125; 1&lt;a href="test/testCookieValue"&gt;CookieValue&lt;/a&gt; ModelAttribute出现在方法上 会将返回值保存到Request域中该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。出现在参数上，获取指定的数据给参数赋值。value：用于获取数据的 key。key 可以是 JavaBean 的属性名称，也可以是 map 结构的 key 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。 有返回值： 结果：会覆盖掉原有的值 但没有添加的值 保留 12345&lt;form action="test/testModelAttribute" method="post"&gt; 姓名：&lt;input type="text" name="uname"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 1234567891011121314@RequestMapping(value = "/testModelAttribute") public String testModelAttribute(User user)&#123; System.out.println(user); return "success"; &#125; @ModelAttribute public User createUser()&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); user.setBirthday(new Date()); return user; &#125; 无返回值： 123456789101112131415@RequestMapping(value = "/testModelAttribute") public String testModelAttribute(@ModelAttribute(value = "用户1") User user)&#123; System.out.println(user); return "success"; &#125; @ModelAttribute public void createUser(Map&lt;String,User&gt; map)&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); user.setBirthday(new Date()); map.put("用户1",user); &#125;` SessionAttribute作用在类上用于多次执行控制器方法间的参数共享。value：用于指定存入的属性名称type：用于指定存入的数据类型 结果：清除session后结果： 1234567891011@RequestMapping(value = "/test")@SessionAttributes(value = &#123;"abc"&#125;)public class CommonAnno &#123; @RequestMapping(value = "/testSessionAttributes") public String testSessionAttribute(Model model)&#123;// 会存储到request域中 model.addAttribute("abc","美美"); return "success"; &#125;&#125; 将结果显示到success.jsp页面 12$&#123;requestScope.abc&#125;$&#123;sessionScope&#125; 清除 123456 @RequestMapping(value = "/testRemoveSessionAttributes") public String testRemoveSessionAttributes(SessionStatus status)&#123;// 清除session status.setComplete(); return "success"; &#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 2.组件介绍 RequestMapping 参数绑定]]></title>
    <url>%2F2019%2F05%2F15%2FSpringMVC-2.%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D-RequestMapping-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A1%2F</url>
    <content type="text"><![CDATA[组件介绍DispatcherServlet 前端控制器用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 HandlerMapping 处理器映射器HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式例如：配置文件方式，实现接口方式，注解方式等。 Handler 处理器它就是我们开发中要编写的具体业务控制器。DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 HandlAdapter 处理器适配器通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver 视图解析器View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 &lt;mvc:annotation-driven&gt; 说明在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。使 用 mvc:annotation-driven 自动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用mvc:annotation-driven替代注解处理器和适配器的配置。 RequestMapping用于建立请求 URL 和处理请求方法之间的对应关系。源码头 说明可以作用于类和方法 12345@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping 出现在类上请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。它出现的目的是为了使我们的 URL 可以按照模块化管理 出现在方法上请求 URL 的第二级访问目录属性： value：用于指定请求的 URL。它和 path 属性的作用是一样的。 method：用于指定请求的方式。RequestMethod.POST只支持POST提交方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。例如：params = {“accountName”}，表示请求参数必须有 accountNameparams = {“moeny!100”}，表示请求参数中 money 不能是 100。headers：用于指定限制请求消息头的条件。注意：以上四个属性只要出现 2 个或以上时，他们的关系是与&amp;的关系。 参数绑定解决POST请求参数中文乱码问题 添加过滤器为所有目录下的请求配置UTF-8 web.xml 12345678910111213&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 基本类型和String类型：Controller类：12345@RequestMapping("/testParam") public String testParam(String userName)&#123; System.out.println(userName); return "success"; &#125; JavaBean类型Param.jsp1234567&lt;form action="param/testAccount" method="post"&gt; 账号：&lt;input type="text" name="userName"&gt;&lt;br&gt; 密码：&lt;input type="text" name="passWord"&gt;&lt;br&gt; 姓名：&lt;input type="text" name="user.uname"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="user.age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller类：12345@RequestMapping("/testAccount")public String testAccount(Account account)&#123; System.out.println(account); return "success";&#125; Account类123456public class Account &#123; private String userName; private String passWord; private User user; ... &#125; 集合类型Account类123456puprivate String userName; private String passWord; private Map&lt;String,User&gt; map; private List&lt;User&gt; list; ... &#125; Param.jsp 123456789 &lt;form action="param/testAccount" method="post"&gt; 账号：&lt;input type="text" name="userName"&gt;&lt;br&gt; 密码：&lt;input type="text" name="passWord"&gt;&lt;br&gt; List姓名：&lt;input type="text" name="list[0].uname"&gt;&lt;br&gt; List年龄：&lt;input type="text" name="list[0].age"&gt;&lt;br&gt; Map姓名：&lt;input type="text" name="map['于松江'].uname"&gt;&lt;br&gt; Map年龄：&lt;input type="text" name="map['于松江'].age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 结果显示： 1.实体类中加日期格式化注解12@DateTimeFormat(pattern="yyyy-MM-dd HH:mm")private Date creationTime; 2.属性编辑器spring3.1之前 在Controller类中通过@InitBinder完成 12345678910111213141516171819202122/** * 在controller层中加入一段数据绑定代码 * @param webDataBinder */ @InitBinder public void initBinder(WebDataBinder webDataBinder) throws Exception&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm"); simpleDateFormat.setLenient(false); webDataBinder.registerCustomEditor(Date.class , new CustomDateEditor(simpleDateFormat , true)); &#125; 备注：自定义类型转换器必须实现PropertyEditor接口或者继承PropertyEditorSupport类写一个类 extends propertyEditorSupport（implements PropertyEditor）&#123; public void setAsText(String text)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy -MM-dd hh:mm"); Date date = simpleDateFormat.parse(text); this.setValue(date); &#125; public String getAsTest()&#123; Date date = (Date)this.getValue(); return this.dateFormat.format(date); &#125;&#125; 自定义类型转换器例如日期类 springmvc框架可以转换yyyy/MM/dd 但不能转换yyyy-MM-dd我们就要手动实现这个功能 首先继承Converter&lt;S, T&gt;接口 S:表示接受的类型，T：表示目标类型 自己实现日期转换12345678910111213141516171819202122public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; if (StringUtils.isEmpty(source))&#123; throw new NullPointerException("请输入日期"); &#125; DateFormat format=null; if (source.contains("/")) &#123; format = new SimpleDateFormat("yyyy/MM/dd"); &#125; if (source.contains("-"))&#123; format = new SimpleDateFormat("yyyy-MM-dd"); &#125; try &#123; Date date = format.parse(source); return date; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 在 spring 配置文件中配置类型转换器配置类型转换器工厂 注入自定义类型转换器 在注解支持中引用类型转换器 123456789101112&lt;!-- 配置类型转换器工厂--&gt; &lt;bean id="conversionServiceFactoryBean" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;&lt;!-- 注入自定义类型转换器--&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;!-- 也可以使用array list--&gt;&lt;!-- 配置自定义转换器--&gt; &lt;bean class="it.test.utils.StringToDateConverter"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启mvc注解支持 引用自定义类型转换器--&gt; &lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean"&gt;&lt;/mvc:annotation-driven&gt; 获取原生request response请求方法参数中 之间填入HttpServletRequest HttpServletResponse]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 1.SpringMVC快速入门]]></title>
    <url>%2F2019%2F05%2F14%2FSpringMVC-1.SpringMVC%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[SpringMVC相关基本概念MVC及三层架构基于B/S架构系统标准的三层架构包括：表现层、业务层、持久层MVC 全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写，一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职： Model（模型）：通常指的就是我们的数据模型。作用一般情况下用于封装数据。 View（视图）：通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。 Controller（控制器）：是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。它相对于前两个不是很好理解，这里举个例子：例如：我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充到模型之中。此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做的。当校验失败后，由控制器负责把错误页面展示给使用者。如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。SpringMVC概念 SpringMVC优势 清晰的角色划分：前端控制器（DispatcherServlet）请求到处理器映射（HandlerMapping）处理器适配器（HandlerAdapter）视图解析器（ViewResolver）处理器或页面控制器（Controller）验证器（ Validator）命令对象（Command 请求参数绑定到的对象就叫命令对象）表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。 分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。 强大的 JSP 标签库，使 JSP 编写更容易。还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。SpringMVC入门 基本流程图 配置文件pom.xml除了Spring-context核心以外还要导入spring-web spring-webmvc servlet-api如果使用JSP还需要导入jsp-api 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day01_SpringMVC快速入门&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;Day01_SpringMVC快速入门 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;Day01_SpringMVC快速入门&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 控制器类HelloController 创建该实例并用方法接受请求 返回页面名称 123456789101112@Controllerpublic class HelloController &#123; @RequestMapping(path = "/hello") public String sayHello() &#123; System.out.println("Hello SpringMVC！！");// 返回的是文件名 return "success"; &#125;&#125; springmvc.xml配置该xml文件需要实例化控制器类 并配置视图解析器确定视图所在路径 文件名后缀 并开启mvc注解支持 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置要扫描的包--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt;&lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;!-- 包路径--&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt;&lt;!-- 文件后缀名--&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启mvc注解支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; web.xml配置前端控制器拦截访问路径并配置servle初始化参数，t创建时会加载springmvc.xml文件否则不被使用 无法启动功能 12345678910111213141516171819202122232425&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt;&lt;!-- 配置前端控制器拦截请求--&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置dispatcherServlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置servlet启动时加载对象 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp 12345678910 &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="hello"&gt;hello&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 9.声明式事务控制]]></title>
    <url>%2F2019%2F05%2F14%2FSpring-9.Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[声明式事务控制 TransactionManager接口需要引入tx 即Spring事务控制部分 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 由Spring框架给出的事务控制（事务管理器） 不需要自己手动实现使用的实现类DataSourceTransactionManager 1.配置事务管理器因为是数据库连接池事务管理器 事务主要为手动提交 回滚 和关闭连接所以配置时要注入DataSource 123&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; 2.配置事务通知创建一个事务通知 并给事务通知一个管理器引用 并向其中配置属性 由&lt;tx:advice&gt;进行配置 配置事务属性&lt;tx:advice&gt; 内部嵌套 &lt;tx:attributes&gt; 内部嵌套 &lt;tx:method&gt; isolation :用于指定事务隔离级别 默认值DEFAULT 表示使用数据库的默认隔离级别 no-rollback-for：用于指定一个异常 出现异常不回滚 其他异常回滚 没有默认值 表示任何异常回滚 propagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS read-only:用于指定是否只读 查询方法设置为true 其他为false rollback-for：用于指定一个异常 出现异常回滚 其他异常不回滚 没有默认值 表示任何异常回滚 timeout：用于指定超时时间 默认-1 表示永远不超时 指定数值以S作单位1234567 &lt;tx:attributes&gt;&lt;!-- 配置所有指定范围内方法--&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt;&lt;!-- 配置以find开头的方法--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 3.配置AOP切面装载通知建立事务通知和切入点表达式的联系&lt;aop:advisor&gt; 12345 &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!--3.1建立事务通知和切入点表达式的联系--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 代码pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day06_Spring声明式事务控制&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; bean.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;!-- aop 切面增强 tx 声明式事务控制--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="accountService" class="it.test.service.impl.AccountServiceImpl"&gt; &lt;property name="dao" ref="accountDao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--声明式事务控制--&gt;&lt;!--1.配置事务管理器 因为需要connection 配置事务 所以注入DataSource--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--2.配置事务通知 给事务通知一个管理器引用--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;!--2.1配置事务属性 isolation :用于指定事务隔离级别 默认值DEFAULT 表示使用数据库的默认隔离级别 no-rollback-for：用于指定一个异常 出现异常不回滚 其他异常回滚 没有默认值 表示任何异常回滚 propagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS read-only:用于指定是否只读 查询方法设置为true 其他为false rollback-for：用于指定一个异常 出现异常回滚 其他异常不回滚 没有默认值 表示任何异常回滚 timeout：用于指定超时时间 默认-1 表示永远不超时 指定数值以S作单位 --&gt; &lt;tx:attributes&gt;&lt;!-- 配置所有指定范围内方法--&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt;&lt;!-- 配置以find开头的方法--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!--3.配置AOP切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!--3.1建立事务通知和切入点表达式的联系--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; AccountDao12345678910111213141516171819202122/** * 实现类 继承JdbcDaoSupport */public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; @Override public List&lt;Account&gt; findAll() &#123; return getJdbcTemplate().query("select * from spring_account",new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); &#125; @Override public Account findByName(String name) &#123; String sql ="select * from spring_account where name = ?"; Account account = getJdbcTemplate().query(sql,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),name).get(0); return account; &#125; @Override public void update(Account account) &#123; String sql ="update spring_account set money = ? where id = ?"; getJdbcTemplate().update(sql,account.getMoney(),account.getId()); &#125;&#125; AccountService1234567891011121314151617181920212223242526272829303132333435363738394041public class AccountServiceImpl implements AccountService &#123;// set注入 private AccountDao dao; public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; @Override public List&lt;Account&gt; findAll() &#123; return dao.findAll(); &#125; /** * 每天都是单独的事务控制 进行操作 出现问题没有办法没有办法回滚 * 所以开启手动提交 * 为线程安全问题 为每个线程指定单独的connection对象 * @param fromName * @param toName * @param money */ @Override public void transferByName(String fromName, String toName, double money) &#123;// 1.查询转账用户名字 Account fromUser= dao.findByName(fromName);// 2.查询接收用户名字 Account toUser = dao.findByName(toName);// 3.转账用户减钱 fromUser.setMoney(fromUser.getMoney()-money);// 4.接收用户加钱 toUser.setMoney(toUser.getMoney()+money);// 5.更新转账用户 dao.update(fromUser); int i =1/0;// 6.更新接收用户 dao.update(toUser); &#125;&#125; Test12345678910111213141516171819202122@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:bean.xml")public class Test &#123; @Autowired private AccountService accountService; @org.junit.Test public void accountTest() &#123; List&lt;Account&gt; accountList = accountService.findAll(); for (Account account : accountList) &#123; System.out.println(account); &#125; &#125; @org.junit.Test public void accountTest1() &#123; accountService.transferByName("于松江", "程泽琪", 200); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 8.SpringAOP注解开发&JDBCTemplate]]></title>
    <url>%2F2019%2F05%2F13%2FSpring-8.SpringAOP%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[SpringAOP注解开发如果使用SpringAOP注解通知 则使用环绕通知一般情况下 最终通知会优先于后置通知先执行 是一种错误最好使用XML配置 LogFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 模拟日志功能 并通过aop xml配置添加前置通知 */@Component("log")@Aspect //表示当前为切面类public class LogFactory &#123; @Pointcut("execution(* it.test.service.impl.*.*(..))") public void log()&#123;&#125; @Before("log()") public void beforePrintLog() &#123; System.out.println("前置通知日志信息开始记录："); &#125; @AfterReturning("log()") public void afterReturningPrintLog() &#123; System.out.println("后置通知日志信息开始记录："); &#125; @AfterThrowing("log()") public void afterThrowingPrintLog() &#123; System.out.println("异常通知日志信息开始记录："); &#125; @After("log()") public void afterPrintLog() &#123; System.out.println("最终通知日志信息开始记录："); &#125; /** * 类似于动态代理的方式手动实现通知配置 * 通知方法可以换成上面的方法 * * @param point * @return */ public Object aroundPrintLog(ProceedingJoinPoint point) &#123; Object revalue = null; Object[] args = point.getArgs();//获取方法参数 try &#123; System.out.println("前置通知"); revalue = point.proceed(args); //切入点方法运行 System.out.println("后置通知"); &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125; finally &#123; System.out.println("最终通知"); &#125; return revalue; &#125;&#125; AccountServiceImpl123456789101112131415161718@Service("accountService")public class AccountServiceImpl implements AccountService &#123; @Override public void updateAccount(int i) &#123; System.out.println("更新了账户"+i); &#125; @Override public void findAll() &#123; System.out.println("查询到了所有账户"); &#125; @Override public int count() &#123; System.out.println("查询到了a条记录"); return 0; &#125;&#125; bean.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; JDBCTemplate数据库连接池工具此文中使用的数据库连接池DriverManagerDataSource为Spring内置连接池技术需要加载的类为 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; JdbcDaoSupportdao层如果有多个文件处理 则需要整合重复代码public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao当类继承jdbcDaoSupport则可以使用其内部方法 123&lt;bean id="accountDao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; 当我们为相应子类注入时 因为是继承关系 所以自动调用父类方法进行注入获取到JDBCTemplate实例我们也可以直接注入DataSource 在该里中也存在如下方法 123456public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; 所谓如果使用xml的方法配置文件 我们可以通过这种方法提高复用 pom.xml1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ### bean.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; AccountDaoImpl1234567891011public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; @Override public List&lt;Account&gt; findByName(String name) &#123; System.out.println(super.getDataSource()); List&lt;Account&gt; accountList = super.getJdbcTemplate().query("select * from spring_account where name like ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), "%" + name + "%"); return accountList; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 7.Spring面向切面编程AOP]]></title>
    <url>%2F2019%2F05%2F11%2FSpring-7.Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP%2F</url>
    <content type="text"><![CDATA[** 单独配置环绕配置 或者组合配置 ** AOP编程术语 连接点 ：业务层与增强方法中共同拥有的方法 即业务层实现的方法 切入点 ：被增强过的方法。（如果一个方法没有被增强过。过程 产生结果均相同 则不是切入点） 通知 ：业务层的公共方法 进行封装 统一处理成为通知（例如：事务操作类就是通知 将所有事务操作方法提取出来 封装成 ServiceFactory类进行处理） 环绕通知：动态代理中invoke方法实现的就是环绕通知 通知种类：按照环绕通知中明确的切入点调用划分 （执行操作方法method.invoke(dao, args)） 前置通知：代理方法中执行前的通知方法 （例如开启手动提交） 后置通知：代理方法执行后的通知方法（例如提交事务） 异常通知：代理方法出现异常时进行的通知方法 （例如回滚事务） 最终通知：无论代理方法是否正常执行都会执行的通知方法 (connection释放资源) 目标对象：被代理的对象 AOP两个阶段 1. 开发阶段 编写核心业务代码(开发主线) 要求熟悉业务需求 把公用代码抽取出来，做成通知（开发阶段后期操作） 在配置文件中 声明切入点和通知的关系 即切面 ** 2.运行阶段（Spring框架完成）** Spring框架监控切入点的方法执行。一旦监控到切入点方法被执行 使用代理机制 动态创建目标对象的代理对象，根据通知种类，在代理对象的对应位置 将通知对应功能织入 完成完整代码逻辑 SpringAOP XML配置标签 把通知对象交给Spring进行管理1&lt;bean id="logFactory" class="it.test.factory.LogFactory"&gt;&lt;/bean&gt; ** 以下标签均为嵌套使用 ** 使用aop:config 标签表明开始配置AOP 使用aop:aspect标签表明配置切面 id属性：给切面提供唯一标识 ref属性：提供切面的通知对象实例 四种标签对应四种通知种类 aop:before 前置通知 aop:after-returning 后置通知 aop:after-throwing 异常通知 aop:after 最终通知 四种标签内部值：(以前置通知为例)method：用于指定通知对象实例中哪个方法作为前置通知 pointcut切入点表达式及其配置12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; 以上代码可以解析切入点表达式pointcut：指定切入点表达式 该表达式含义是指对业务成哪些方法进行增强 格式为execution（关键字 返回值 全类名.方法名(参数类型)）标准表达式:public void it.test.service.AccountService.findAll()省略形式： 关键字可以省略 返回值可以使用*作为通配符代替 包名可以用*.表示一级包的通配*..表示当前包及其子包通配 类名和方法名可以用 * 通配 参数列表 基础类名可以直接写名称int 全类名写引用类型java.jang.String 可以使用(..)表示任意类型有无参数 * 实际应用 切换到业务层实现所有方法 ** ` it.test.service.impl..(..)` 例： 1&lt;aop:before method="printLog" pointcut="execution( public void it.test.service.AccountService.findAll())"&gt;&lt;/aop:before&gt; 当出现多条通知时 可以在aop:aspect配置 作用于为当前切面 1&lt;aop:pointcut id="service" expression="execution(* it.test.service.impl.*.*(..)))"/&gt; 并通过pointcut-ref引入 1&lt;aop:after method="afterPrintLog" pointcut-ref="service"&gt;&lt;/aop:after&gt; ** 如果向作用于整个aop 将aop:pointcut写在所有aop:aspect之前 ** 环绕通知 aop：around 当我们配置环绕通知以后 切入点方法没有执行 环绕通知执行了 通过对比动态代理中的环绕通知代码 发现其中存在切入点方法的调用 而我们的配置中没有 解决：将ProceedingJoinPoint作为参数传入环绕方法中。该接口有一个方法proceed();此方法就相当于明确切入点方法 程序执行时 Spring框架会为我们提供此接口的实现类使用 12345678910111213141516171819202122/** * 类似于动态代理的方式手动实现通知配置 * 通知方法可以换成上面的方法 * @param point * @return */public Object aroundPrintLog(ProceedingJoinPoint point)&#123; Object revalue =null; Object[] args = point.getArgs();//获取方法参数 try &#123; System.out.println("前置通知"); revalue = point.proceed(args); //切入点方法运行 System.out.println("后置通知"); &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; return revalue; &#125; pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day05_SpringAop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 解析切入点表达式配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt; junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; bean.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 创建AccountServiceImpl对象--&gt; &lt;bean id="accountService" class="it.test.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt; &lt;!-- 创建logFactory对象--&gt; &lt;bean id="logFactory" class="it.test.factory.LogFactory"&gt;&lt;/bean&gt; &lt;!--配置切面 指定通知和切入点之间的关系--&gt; &lt;aop:config&gt; &lt;!-- 指定通过哪个类中方法配置通知 并命名--&gt; &lt;aop:aspect id="log" ref="logFactory"&gt; &lt;!-- 配置前置通知方法 指定切入点(要增强的方法)--&gt; &lt;!-- &lt;aop:before method="printLog" pointcut="execution( public void it.test.service.AccountService.findAll())"&gt;&lt;/aop:before&gt;--&gt; &lt;!-- 前置通知--&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="service"&gt;&lt;/aop:before&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after-returning method="afterReturningPrintLog" pointcut-ref="service"&gt;&lt;/aop:after-returning&gt; &lt;!-- 异常通知--&gt; &lt;aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="service"&gt;&lt;/aop:after-throwing&gt; &lt;!-- 最终通知 --&gt; &lt;aop:after method="afterPrintLog" pointcut-ref="service"&gt;&lt;/aop:after&gt; &lt;aop:around method="aroundPrintLog" pointcut-ref="service"&gt;&lt;/aop:around&gt;&lt;!-- 整合pointcut--&gt; &lt;aop:pointcut id="service" expression="execution(* it.test.service.impl.*.*(..)))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; AccountServiceImpl123456789101112131415161718192021package it.test.service.impl;import it.test.service.AccountService;public class AccountServiceImpl implements AccountService &#123; @Override public void updateAccount(int i) &#123; System.out.println("更新了账户"+i); &#125; @Override public void findAll() &#123; System.out.println("查询到了所有账户"); &#125; @Override public int count() &#123; System.out.println("查询到了a条记录"); return 0; &#125;&#125; LogFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445 package it.test.factory;import org.aspectj.lang.ProceedingJoinPoint;/** * 模拟日志功能 并通过aop xml配置添加前置通知 */public class LogFactory &#123; public void beforePrintLog()&#123; System.out.println("前置通知日志信息开始记录："); &#125; public void afterReturningPrintLog()&#123; System.out.println("后置通知日志信息开始记录："); &#125; public void afterThrowingPrintLog()&#123; System.out.println("异常通知日志信息开始记录："); &#125; public void afterPrintLog()&#123; System.out.println("最终通知日志信息开始记录："); &#125; /** * 类似于动态代理的方式手动实现通知配置 * 通知方法可以换成上面的方法 * @param point * @return */ public Object aroundPrintLog(ProceedingJoinPoint point)&#123; Object revalue =null; Object[] args = point.getArgs();//获取方法参数 try &#123; System.out.println("前置通知"); revalue = point.proceed(args); //切入点方法运行 System.out.println("后置通知"); &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; return revalue; &#125;&#125; Test1234567891011121314151617import it.test.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; @org.junit.Test public void test1() &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml"); AccountService service = ac.getBean("accountService", AccountService.class); service.findAll(); System.out.println("----------------------"); service.count(); System.out.println("----------------------"); service.updateAccount(1); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 5.Spring案例注解]]></title>
    <url>%2F2019%2F05%2F09%2FSpring-5.Spring%E6%A1%88%E4%BE%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[案例需求 使用Spring开发Dao层 Service层 实现数据库功能 需要dbunits c3p0 spring-test 注解配置不需要通过set方法 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day03_Spring案例注解&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt; mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; UserTest.java 应用程序的入口：main方法junit单元测试中 没有main方法也能执行该方法就会判断当前测试类中哪些方法有@Test注解junit就让有注解的方法执行 Spring 整合junit配置 导入spring整合junit的jar 使用Junit提供的一个注解把原main方法替换改成Spring提供的注解：@Runwith:替换main方法提供@ContextConfiguration：告知Spring运行器 Springioc基于xml还是注解配置并且无需通过代码指定注入文件locations：指定xml文件位置 加上classpath表示在类路径下classes：指定注解位置 12345678910111213141516171819202122232425@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class UserTest &#123; @Autowired UserServiceImpl service=null; @Test public void findAll() &#123;// ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);// service = ac.getBean("userService", UserServiceImpl.class); List&lt;User&gt; userList = service.findAll(); for (User user : userList) &#123; System.out.println(user); &#125; &#125; @Test public void findOne() &#123;// ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);// service = ac.getBean("userService", UserServiceImpl.class); User one = service.findOne(51); System.out.println(one); &#125;&#125; configSpringConfiguration该类是配置类 作用和bean.xml效果一样 @Configuration:指定该文件是一个配置类 被注解的类作为AnnotationConfigApplicationContext对象创建参数时 该注解可以不写@ComponentScan：spring创建容器时要扫描的范围 basePackages和value一样就是配置扫描范围@Bean:用于把当前方法的返回值作为bean对象存入spring容器中 不存入容器无法注入name默认为当前方法名会查找是否有相关属性的配置 如果出现多个则按照方法名和name名是否匹配查找@Import:用于导入其他的配置类 作为被该注解修饰类的子配置类@Qualifier:在方法参数时可以直接使用 指定匹配的id 1234567@Configuration@ComponentScan(basePackages = "it.test")@Import(value = JdbcConfig.class)@PropertySource(value = "classpath:jdbc.properties")public class SpringConfiguration &#123;&#125; jdbcConfig** @Value:**:将数据库的值通过EL表达式形式注入 (普通类型 String类型) 12345678910111213141516171819202122232425262728293031public class JdbcConfig &#123;// @Value将数据库的值通过EL表达式形式注入 (普通类型 String类型) @Value("$&#123;driver&#125;") private String driver; @Value("$&#123;url&#125;") private String url; @Value("$&#123;user&#125;") private String user; @Value("$&#123;password&#125;") private String passWord; // 为保证线程安全 数据库连接池创建多例对象 每个线程独有 @Bean(name = "queryRunner") //返回结果值到Spring容器 连接UserDaoImpl @Scope(value = "prototype") public QueryRunner getQueryRunner(@Qualifier(value = "dataSource") DataSource dataSource) &#123; return new QueryRunner(dataSource); &#125; @Bean(name = "dataSource") public DataSource getDataSoure() &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); try &#123; ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(user); ds.setPassword(passWord); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; return ds; &#125;&#125; Dao层UserDao12345public interface UserDao &#123; List&lt;User&gt; findAll(); User findOne(int id);&#125; UserDaoImpl12345678910111213141516171819202122232425262728293031@Repository("userDao")public class UserDaoImpl implements UserDao &#123;// 通过JdbcConfig文件创建的Spring容器中的实例注入 @Resource(name = "queryRunner") private QueryRunner queryRunner; /* public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125;*/ @Override public List&lt;User&gt; findAll() &#123; try &#123; return queryRunner.query("select * from user", new BeanListHandler&lt;User&gt;(User.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; public User findOne(int id) &#123; try &#123; return queryRunner.query("select * from user where id = ?", new BeanHandler&lt;User&gt;(User.class), id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; Service层UserService1234public interface UserService &#123; List&lt;User&gt; findAll(); User findOne(int id);&#125; UserServiceImpl123456789101112131415161718192021222324252627@Service(value = "userService")public class UserServiceImpl implements UserService &#123; /** * 自动注入 * @Autowired：注入默认 默认为bean对象类名首字母小写 * 将id为userDao的userDao类注入 * */ @Resource(name = "userDao") private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public List&lt;User&gt; findAll() &#123; return userDao.findAll(); &#125; public User findOne(int id) &#123; return userDao.findOne(id); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 6.Spring银行案例事务处理]]></title>
    <url>%2F2019%2F05%2F09%2FSpring-6.Spring%E9%93%B6%E8%A1%8C%E6%A1%88%E4%BE%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[** connection 存在多线程安全问题 如果为单例对象 那么事务操作 一个线程开启事务 一个线程提交 会造成结果影响** ** 连接工具类：实现数据源中获取一个连接 并实现和线程绑定Spring通过ThreadLocal将现有状态的变量（如Connection等）本地线程化， 达到另一个层面是的“线程无关”，从而实现线程安全。** 动态代理 在不修改源码的基础上对方法进行增强 基于接口的动态代理 import java.lang.reflect.Proxy; 顾客通过代理商购买厂商产品 12345678910111213141516171819202122232425262728293031 /** * 买产品 */public class Buyer &#123; public static void main(String[] args) &#123; /** 动态代理：不修改源码的情况下对方法进行增强 */ final ProducerImpl producerImpl = new ProducerImpl();// 需要用其接口类型接收 Producer newProducer = (Producer) Proxy.newProxyInstance( producerImpl.getClass().getClassLoader(), producerImpl.getClass().getInterfaces(), new InvocationHandler() &#123; Object invoke = null; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; double money = (double) args[0]; if ("sell".equals(method.getName())) &#123;// 方法调用需要被代理类对象 和方法参数 invoke = method.invoke(producerImpl, money * 0.8); &#125; return invoke; &#125; &#125;);// 调用代理对象方法实现功能 newProducer.sell(10000); &#125;&#125; Producer接口 1234public interface Producer &#123; void sell(double money);&#125; 实现类 123456 public class ProducerImpl implements Producer &#123; @Override public void sell(double money) &#123; System.out.println("厂商销售 获取："+money); &#125;&#125; 事务分析12345678910111213141516 @Override public void transferByName(String fromName, String toName, double money) &#123;// 1.查询转账用户名字 Account fromUser= dao.findByName(fromName);// 2.查询接收用户名字 Account toUser = dao.findByName(toName);// 3.转账用户减钱 fromUser.setMoney(fromUser.getMoney()-money);// 4.接收用户加钱 toUser.setMoney(toUser.getMoney()+money);// 5.更新转账用户 dao.update(fromUser); int i =1/0;// 6.更新接收用户 dao.update(toUser); &#125; 如代码所示 如果转账操作中出现错误 那不利用事务回滚会造成 数据不准确 而为了数据安全 我们将dbuntils声明为 多例对象 此时运行每一个功能，产生多个connection 即使开启手动提交事务 也无法回滚。 所以此时我们应将同一线程下保持相同的connection对象,即多个功能方法使用的同一个connection对象 可以回滚事务。即通过ThreadLocal&lt;connectnion&gt;来获取连接对象 保证了同一线程的唯一性 ConnectionUtils工具类获取connection封装到本地线程中 并对清除jdbc资源事务的对象提供解绑功能 并重新获取 123456789101112131415161718192021222324252627282930313233343536373839/** * 连接工具类：实现数据源中获取一个连接 并实现和线程绑定 * Spring通过ThreadLocal将现有状态的变量（如Connection等）本地线程化， * 达到另一个层面是的“线程无关”，从而实现线程安全。 */public class ConnectionUtils &#123; private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;();// c3p0获取数据库连接池 private DataSource dataSource; public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; // 获取当前线程上的连接 public Connection getConnection() &#123; Connection connection = threadLocal.get(); if (connection == null) &#123;// 如果为null则从数据库连接池中获取一个连接 try &#123;// 获取connection 将connection加入ThreadLocal connection = dataSource.getConnection(); threadLocal.set(connection); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return connection; &#125; public void close() &#123;// 解绑已经close掉的connection对象 重新获取 threadLocal.remove(); &#125;&#125; TransactionManager事务管理工具类管理事务 通过ConnectionUtils方法获取当前线程上的connection 并通过获取到的connection管理当前线程上的事务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TransactionManager &#123; private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 开启事务 */ public void beginTransaction() &#123; try &#123; connectionUtils.getConnection().setAutoCommit(false); System.out.println("开启手动提交"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 回滚事务 */ public void rollBack() &#123; try &#123; connectionUtils.getConnection().rollback(); System.out.println("回滚事务"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ public void commit() &#123; try &#123; connectionUtils.getConnection().commit(); System.out.println("提交事务"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 释放资源 */ public void release() &#123; try &#123;// 关闭以后 线程上还有连接 只不过该connection对象已经被放回连接池中了(消除事务和jdbc连接) 无法使用了// 所以需要解除绑定 重新从连接池中获取一个存在jdbc连接的connection对象 connectionUtils.getConnection().close(); connectionUtils.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; serviceFactory 动态代理增强service方法增强accountService类中的每一个方法该类中提供getAccountService返回增强后的类实例为每一个原类中的方法提供事务控制 并返回新的proxyAccountService进行实例调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class serviceFactory &#123; /** * 注入 */ private AccountService dao; private TransactionManager tm; public void setTm(TransactionManager tm) &#123; this.tm = tm; &#125; public final void setDao(AccountService dao) &#123; this.dao = dao; &#125; public AccountService getAccountService() &#123; return (AccountService) Proxy.newProxyInstance(dao.getClass().getClassLoader(), dao.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// 开启事务 Object invoke = null; try &#123;// 开启手动提交 tm.beginTransaction();// 执行操作 System.out.println("运行方法名为："+method.getName()); invoke = method.invoke(dao, args);// 提交事务 tm.commit();// 返回结果 return invoke; &#125; catch (Exception e) &#123;// 回滚事务 tm.rollBack(); throw new RuntimeException(e); &#125; finally &#123;// 释放连接 tm.release(); &#125; &#125; &#125;); &#125;&#125; AccountDaoImpl 去除原来queryRunner中的connection为每一个功能手动添加同一线程下的connection方法 保证多个功能使用同一数据库连接 才能回滚 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class AccountDaoImpl implements AccountDao &#123; //set注入 private QueryRunner queryRunner; private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; @Override public List&lt;Account&gt; findAll() &#123; try &#123; return queryRunner.query(connectionUtils.getConnection(),"select * from spring_account", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override public Account findByName(String name) &#123; String sql="select * from spring_account where name = ?"; List&lt;Account&gt; accountList = null; try &#123; accountList = queryRunner.query(connectionUtils.getConnection(),sql, new BeanListHandler&lt;Account&gt;(Account.class), name); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; if (accountList==null ||accountList.size()==0)&#123; return null; &#125; if (accountList.size()&gt;1)&#123; throw new RuntimeException("结果不唯一"); &#125; Account account = accountList.get(0); return account; &#125; @Override public void update(Account account) &#123; try &#123; queryRunner.update(connectionUtils.getConnection(),"update spring_account set money = ? where id = ?", account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Test为方法指定增强后的service实例 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations ="classpath:bean.xml" )public class AccountTest &#123; @Qualifier("proxyAccountService") @Autowired private AccountService service = null; @Test public void findAll()&#123; List&lt;Account&gt; accounts = service.findAll(); for (Account account : accounts) &#123; System.out.println(account); &#125; &#125; @Test public void transferByName()&#123; service.transferByName("于松江","程泽琪",500); &#125;&#125; bean.xml部署类实例创建和相关注入 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;!-- 由工厂方法提供新的accountService对象--&gt; &lt;bean id="proxyAccountService" factory-bean="serviceFactory" factory-method="getAccountService"&gt;&lt;/bean&gt; &lt;bean id="accountService" class="it.test.service.impl.AccountServiceImpl"&gt; &lt;property name="dao" ref="dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="dao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="queryRunner" ref="queryRunner"&gt;&lt;/property&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="connectionUtils" class="it.test.utils.ConnectionUtils"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="it.test.utils.TransactionManager"&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="serviceFactory" class="it.test.factory.serviceFactory"&gt; &lt;property name="dao" ref="accountService"&gt;&lt;/property&gt; &lt;property name="tm" ref="transactionManager"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;It.test&lt;/groupId&gt; &lt;artifactId&gt;Day04_Spring事务&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 4.Spring案例XML]]></title>
    <url>%2F2019%2F05%2F09%2FSpring-4.Spring%E6%A1%88%E4%BE%8BXML%2F</url>
    <content type="text"><![CDATA[案例需求 使用Spring开发Dao层 Service层 实现数据库功能 需要dbunits c3p0 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day03_Spring案例&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;!-- Spring框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt; 5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; UserTest.java1234567891011121314public class UserTest &#123; @Test public void findAll() &#123;// 扫描bean.xml 创建所需实体类对象 并载入Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");// 获取Spring容器中的UserServiceImpl UserServiceImpl service = ac.getBean("userService", UserServiceImpl.class); List&lt;User&gt; userList = service.findAll(); for (User user : userList) &#123; System.out.println(user); &#125; &#125;&#125; Bean.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=&quot;dateSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置queryRunner--&gt; &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;!-- 注入数据源--&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dateSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;it.test.dao.impl.UserDaoImpl&quot;&gt;&lt;!-- 创建数据库连接池--&gt; &lt;property name=&quot;queryRunner&quot; ref=&quot;queryRunner&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;it.test.service.impl.UserServiceImpl&quot;&gt;&lt;!-- 创建该类所需要的UserDaoImpl对象--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Dao层UserDao.java1234public interface UserDao &#123; List&lt;User&gt; findAll();&#125; UserDaoImpl.java1234567891011121314151617public class UserDaoImpl implements UserDao &#123;// bean.xml 通过set注入实体类 private QueryRunner queryRunner; public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; public List&lt;User&gt; findAll() &#123; try &#123; return queryRunner.query("select * from user",new BeanListHandler&lt;User&gt;(User.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; Service层UserService123public interface UserService &#123; List&lt;User&gt; findAll();&#125; UserServiceImpl1234567891011121314151617public class UserServiceImpl implements UserService &#123; private UserDao userDao; /** * Spring配置userDao方法 * * @param userDao */ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public List&lt;User&gt; findAll() &#123; return userDao.findAll(); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 1.Spring入门思想 Bean]]></title>
    <url>%2F2019%2F05%2F06%2FSpring%201.Spring%E5%85%A5%E9%97%A8%E6%80%9D%E6%83%B3%20Bean%2F</url>
    <content type="text"><![CDATA[Spring 体系结构Spring简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ![](https://i.loli.net/2019/05/06/5ccfe88cdd826.png) `Core Container` Spring核心容器 IOC 耦合耦合：类或者方法之间存在编译依赖数据库连接：DriverManager.registerDriver(new com.mysql.jdbc.Driver())如果不添加驱动 则会报出编译时异常 证明了类之间的依赖关系很大如果使用Class.forName()注册驱动 则可以降低程序间耦合 解耦解耦思想： ** 降低程序间的依赖关系** 实际开发中应做到：*编译期不依赖 运行期依赖 *类之间耦合通过反射来创建对象 避免出现new关键字通过读取配置文件来获取创建的对象的全限定类名 在之间的旅游网项目中 三层架构的逻辑处理方式 界面层 通过new调用 业务逻辑层 业务逻辑层 通过new调用 数据访问层 存在类之间的耦合 解耦方法 模拟Spring 通过工厂模式 解耦 在静态代码块中完成创建properties 通过获取键值对将 每一个对象创建出来并将名称和实例存储到准备好的Map&lt;String,Object&gt;集合中 通过getInstance(String s)方法获取到调用者需要的key将value 即已保存好的实例返回给外界调用者保证了调用者调用的是唯一的实例化对象 （单例）单例存在线程问题 所以尽量不要定义类成员变量 Bean：在计算机英语中 有可重用组件的含义 IOC控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。 作用： 削减计算机程序的耦合（解除我们代码中的依赖关系） pom.xml 配置spring-context spring配置文件标题 查看 Spring FrameWork官方文档 core中的xmlns123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt; 类视图： 核心容器的两个接口引发的问题： ApplicationContext： 单例对象适用他在构建核心容器时，创建对象采取的策略是采取立即加载的形式。也就是说只要一读取完配置文件马上就常见配置文件中配置的对象 BeanFactory：多例对象适用他在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说什么时候根据id获取对象 什么时候创建对象 ApplicationContext的三个常用实现类： ClassPathXmlApplicationContext:可以加载类路径下的配置文件要求配置文件必须在类路径下 FileSystemXmlApplicationContext：可以加载磁盘任意路径下的配置文件（需要有访问权限） AnnotationConfigApplicationContext：用于读取注解创建的容器 获取对象的三种配置 默认构造函数配置 123&lt;!-- 默认构造函数配置 即无参构造函数--&gt;&lt;bean id="UserServiceImpl" class="it.test.service.impl.UserServiceImpl"&gt;&lt;/bean&gt; 工厂方法获取配置 12345 &lt;!-- 使用普通工厂中的方法创建对象(使用某个类中的方法创建并存入Spring容器) factory-bean 工厂来源 factory-method工厂方法--&gt; &lt;bean id="UserServiceFactory" class="it.test.factory.UserServiceFactory"&gt;&lt;/bean&gt; &lt;bean id="getUserServiceImpl" factory-bean="UserServiceFactory" factory-method="getUserServiceImpl"&gt;&lt;/bean&gt; 静态工厂方法获取配置 123&lt;!--静态工厂方法创建对象--&gt; &lt;bean id="getUserServiceImpl" class="it.test.factory.StaitcUserServiceFactory" factory-method="getUserServiceImpl"&gt;&lt;/bean&gt; 程序：UserServlet 12345678910111213public class UserServlet &#123; public static void main(String[] args) &#123; ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml");// 获取实例方式 二选一 UserService userService = (UserServiceImpl) ac.getBean("getUserServiceImpl");// UserServiceImpl userServiceImpl1 = ac.getBean("UserServiceImpl", UserServiceImpl.class); userService.getUser(); String s="Java程序员"; System.out.println(s.getBytes().length); &#125;&#125; UserService 12345678package it.test.service;public interface UserService &#123; /** * 模拟获取User(); */ void getUser();&#125; UserServiceImpl 12345678910111213package it.test.service.impl;import it.test.service.UserService;public class UserServiceImpl implements UserService &#123; public UserServiceImpl() &#123; System.out.println("UserServiceImpl方法被创建了"); &#125; public void getUser() &#123; System.out.println("获取User"); &#125;&#125; UserServiceFactory 123456789101112package it.test.factory;import it.test.service.impl.UserServiceImpl;/** * 模拟工厂模式获取UserServiceImpl jar中方法 不可更改 */public class UserServiceFactory &#123; public UserServiceImpl getUserServiceImpl()&#123; return new UserServiceImpl(); &#125;&#125; StaitcUserServiceFactory 123456789101112package it.test.factory;import it.test.service.impl.UserServiceImpl;/** * 模拟工厂模式静态获取UserServiceImpl jar中方法 不可更改 */public class StaitcUserServiceFactory &#123; public static UserServiceImpl getUserServiceImpl()&#123; return new UserServiceImpl(); &#125;&#125; Bean标签作用范围bean标签的scope属性 作用：指定bean作用范围 取值：常用单例多例 singleton(单例模式 默认值) prototype 多例 不调用不创建 request web项目的请求 session web项目会话范围 global-session 作用于集群环境的会话技术(全局会话技术) 不是集群环境是 为session1&lt;bean id="UserServiceImpl" class="it.test.service.impl.UserServiceImpl" scope="prototype"&gt;&lt;/bean&gt; 123UserService userService1 = (UserServiceImpl) ac.getBean("UserServiceImpl"); UserService userService2 = ac.getBean("UserServiceImpl", UserServiceImpl.class); userService1.getUser(); System.out.println(userService1==userService2); 最后结果为 创建两个对象 Bean对象声明周期bean标签下可以使用init-method destroy-method开启 生成对象时调用方法 销毁对象时调用方法 ApplicationContext没有关闭容器方法 其子类ClassPathXmlApplicationContext有 单例对象 出生：当核心容器创建时对象出生 活着：当核心容器还在 对象就一直活着 死亡：容器销毁 对象消亡 总结：单例对象的生命周期和容器相同 多例对象 出生：使用对象时spring为我们创建 活着：对象只要是在使用过程中就一直活着 死亡：java垃圾回收]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 3.Spring注解开发]]></title>
    <url>%2F2019%2F05%2F06%2FSpring-3.Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[@Component用于将当前类实例存储到Spring容器中 value 值为xml文件中bean的id 如果不配置默认为类名首字母小写 @Controller:用于表现层 @Service：用于业务层 @Repository：用于持久层 以上三个注解和@Component 一样 用于三层架构的每一层 @Autowired 自动类型注入 会查询Spring容器中的值(容器以Map形式封装数据)进行连接 如果发现值有相同时 在查找和变量名相同的键值 图解： @Qualifier 确定注入的对象 (不能单独工作需要和Autowired一起) 单独使用时可以指定@Bean对应id @Resource 可以使用 @Resource(name = “userDao1”) 指定bean的id 需要配置 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt; javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 以上三个注入只能注入其他bean类型的数据 基本类型String不法使用 集合类型只能通过xml实现 @Value 可以添加基本数据类型的值 @Scopevalue改变作用范围 单例多例 代码pom.xml 12345678910111213141516&lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day02_Spring常用注解&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt; javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; bean.xml 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置所需要的标签不是在beans的约束中在名为context名称空间和约束中 context:component-scan 告知Spring在创建容器时要扫描的包--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; UserServlet 1234567891011public class UserServlet &#123; public static void main(String[] args) &#123; ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml");// 获取实例方式 二选一 UserService userService = ac.getBean("userServiceImpl", UserServiceImpl.class); userService.getUser(); &#125;&#125; UserServiceImpl 12345678910111213141516171819202122232425package it.test.service.impl;import it.test.dao.UserDao;import it.test.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.ImportResource;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component@Scope(value = "singleton")public class UserServiceImpl implements UserService &#123;// @Autowired //自动类型注入// @Qualifier("userDao2") @Resource(name = "userDao1") private UserDao dao = null; public void getUser() &#123; dao.getUser(); &#125;&#125; UserService 123456public interface UserService &#123; /** * 模拟获取User(); */ void getUser();&#125; UserDao 123public interface UserDao &#123; void getUser();&#125; UserDaoImpl 12345678910import it.test.dao.UserDao;import org.springframework.stereotype.Component;@Component("userDao1")public class UserDaoImpl implements UserDao &#123; public void getUser() &#123; System.out.println("UserDaoImpl获取User"); &#125;&#125; UserDaoImpl2 12345678910import it.test.dao.UserDao;import org.springframework.stereotype.Component;@Component("userDao2")public class UserDaoImpl2 implements UserDao &#123; public void getUser() &#123; System.out.println("UserDaoImpl2获取User"); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 2.Spring注入]]></title>
    <url>%2F2019%2F05%2F06%2FSpring-2.Spring%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Spring注入在反射实例化时调用方法(构造方法 或者set方法赋值) 构造函数注入 构造函数注入： 使用标签：constructor-arg 标签出现的位置 bean标签内部 标签中属性： type:指定要注入的数据类型 该类型也是构造函数中某个或者某些参数类型 index：指定注入数据的索引从0开始 name：用于给构造函数中指定名称的参数赋值(构造函数形参 不是属性) value：基本数据类型 和String类型 ref：用于指定其他bean类型数据 指定在springIOC容器中出现过的bean对象 123456789private String name;private int age;private Date birthday;public UserServiceImpl(String name, int age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday;&#125; xml配置 1234567&lt;bean id="birthday" class="java.util.Date"&gt;&lt;/bean&gt;&lt;bean id="UserServiceImpl" class="it.test.service.impl.UserServiceImpl"&gt; &lt;constructor-arg name="name" value="瓜皮"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="13"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="birthday"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 结果： set注入set注入 使用标签：property 标签出现的位置：bean标签内部 标签中属性： name：用于set方法属性 (不是成员变量) value：基本数据类型 和String类型 ref：用于指定其他bean类型数据 指定在springIOC容器中出现过的bean对象 优势：可以调用空参构造函数劣势: 可能存在调用默认构造函数时 对象已经用完销毁没有注入xml 1234567&lt;bean id="birthday" class="java.util.Date"&gt;&lt;/bean&gt; &lt;bean id="UserServiceImpl2" class="it.test.service.impl.UserServiceImpl2"&gt; &lt;property name="name" value="程大傻"&gt;&lt;/property&gt; &lt;property name="age" value="15"&gt;&lt;/property&gt; &lt;property name="birthday" ref="birthday"&gt;&lt;/property&gt; &lt;/bean&gt; UserServiceImpl2 1234567891011121314private String name; private int age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; 结果： 集合注入同结构集合 标签可以互换 12345678910111213141516171819202122232425262728293031323334private String[] myArray; private List&lt;String&gt; myList; private Set&lt;Date&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProperties; public void setMyArray(String[] myArray) &#123; this.myArray = myArray; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;Date&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProperties(Properties myProperties) &#123; this.myProperties = myProperties; &#125; public void getUser() &#123; System.out.println(Arrays.toString(myArray)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProperties); &#125; xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;/bean&gt; &lt;bean id="UserServiceImpl3" class="it.test.service.impl.UserServiceImpl3"&gt; &lt;property name="myArray"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="myList"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="mySet"&gt; &lt;set&gt; &lt;ref bean="birthday"&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="myMap"&gt; &lt;map&gt; &lt;entry key="aaa" value="bbbb"&gt;&lt;/entry&gt; &lt;entry key="ccc" value="dddd"&gt;&lt;/entry&gt; &lt;entry key="eee" value="ffff"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="myProperties"&gt; &lt;props&gt; &lt;prop key="aaa"&gt;bbb&lt;/prop&gt; &lt;prop key="ccc"&gt;bbb&lt;/prop&gt; &lt;prop key="ddd"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 结果：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 6.Mybatis注解开发]]></title>
    <url>%2F2019%2F05%2F06%2FMybatis-6.Mybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[注解开发补充 如果存在实体类和数据库名称不统一时 使用以下方式Results中id指定唯一标识 其他方法引用 可以使用@ResultMap引用id即可 多表查询及延迟加载延迟加载不用在主配置文件配置 FetchType中声明即可@Result注解中有one和many属性 一对一选择one 一对多选择many@one注解中有个FetchType枚举 LAZY EAGER 分别是延迟加载和立即加载column 对应通过account的哪个属性作为第二个查找方法的值select对应方法的全限定方法名 二级缓存主配置文件中进行配置 1&lt;setting name="cacheEnabled" value="true"/&gt; 通过其他方法 获取封装1234567@Select("select * from orders where id = #&#123;id&#125;") @Results(value = &#123; @Result(column = "productId",property = "product",javaType = Product.class,one = @One(select = "it.test.dao.ProductDao.findById")), @Result(column = "memberId",property = "member",javaType = Member.class,one = @One(select = "it.test.dao.MemberDao.findById")), @Result(column = "id",property = "travellers",javaType = List.class,many = @Many(select = "it.test.dao.TravellerDao.findByOrdersId")) &#125;) Orders findById(String id);]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 5.Mybatis延迟加载，缓存]]></title>
    <url>%2F2019%2F05%2F05%2FMybatis-5.Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[延迟加载与立即加载延迟加载：在真正使用数据时发起查询 不用时不查询 按需加载(懒查询)立即加载：不管用不用 调用方法时立即加载 在四种对应关系中：一对多 多对多 通常情况下采取延迟加载多对一 一对一 通常情况下使用立即加载 一对一延迟加载UserDao.xml方法中添加根据id查询信息的方法 123&lt;select id="findById" parameterType="int" resultType="user"&gt; select * from user where id =#&#123;id&#125; &lt;/select&gt; 在AccountDao.xml更改为 1234567891011121314 &lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt;&lt;!-- select 属性指定内容 查询用户的唯一标识 column 为在account表中 用户查询id所需要的值 对应account表中的uid--&gt; &lt;association property="user" column="uid" javaType="user" select="it.test.dao.UserDao.findById"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findByOneToOne" resultMap="accountUserMap"&gt; select * from account &lt;/select&gt; 此时就是立即加载 123456789public void findByOneToOne()&#123; List&lt;Account&gt; list = dao.findByOneToOne(); /* for (Account account : list) &#123; System.out.println("============================="); System.out.println(account); System.out.println(account.getUser()); &#125;*/&#125; 无论我们是否查询逐条数据 只要加载 就会全部查询在主配置文件中添加如下配置 12345 &lt;settings&gt;&lt;!-- 开启延迟加载功能 并关闭按需加载--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt; 结果为延迟加载 注释后 只运行了查询account操作 多对一和一对一方法相同UserDao.xml 1234567&lt;collection property="accounts" ofType="account" column="id" select="it.test.dao.AccountDao.findById"&gt; &lt;id property="id" column="aid"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt; Mybatis缓存概念：存在于内存中的临时数据使用缓存的原因：减少和数据库的交互次数 提高执行效率适用于缓存： 经常查询并且不经常改变的 数据的正确与否与最终结果影响不大的 不适用于缓存： 经常改变的数据 数据的正确与否对最终结果影响很大的例如 银行汇率 股市数据 Mybatis一级缓存指在Mybatis中Sqlsession对象中的缓存当我们执行查询疑惑 查询的结果会同时存入到SqlSession为我们提供一块区域中该区域的结构是一个Map 当我们再次查询同样的数据 Mybaits会先去SqlSession中查询是否有 有的话直接调用当SqlSession对象消失时,Mybatis一级缓存也会消失 通过Sqlsession创建两个对象进行查询方法两个对象相同 因为第二次从缓存中获取关闭后重新获取 对象不同 因为缓存消失调用sqlSession.clearCache();方法清空缓存效果相同 操作数据操作数据后 调用数据SqlSession的修改，添加，删除commit();提交，关闭操作时，清空一级缓存 所有重新执行Sql语句查询 Mybatis二级缓存Mybatis中SqlSessionFactory中对象的缓存 由同一个SqlSessionFactory对象创建的SqlSession共享其缓存(数据缓存) sqlSession创建新对象 但共享数据 步骤 让Mybaits框架支持二级缓存（SqlMapConfig.xml中配置）settings中设置属性cacheEnabled 为true 让当前映射文件支持二级缓存（userDao.xml中配置）&lt;Mapper&gt;标签下添加&lt;cacahe/&gt; 让当前操作支持二级缓存&lt;select&gt;标签中添加useCache=&quot;true&quot;属性 缓存效果 映射语句文件中的所有 SELECT 语句将会配缓存。映射语句文件中的所有 INSERT、UPDATE、DELETE 语句会刷新缓存。 缓存会使用 Least Recently Used （LRU，最近最少使用的）算法来回收。 根据时间表（如 no Flush Interval，没有刷新时间），缓存不会以任何时间顺序来刷新。 缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024个引用。 缓存会被视为 read/write（可读/可写）的，意味着对象检索不是共享的，而且可以安全的被调用者修改，而不干扰其他调用者或线程所做的潜在修改。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 4.Mybatis中连接池以及事务控制，多表操作]]></title>
    <url>%2F2019%2F05%2F04%2FMybatis-4.Mybatis%E4%B8%AD%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[SQL语句中如果出现同名字段 在配置文件中 通过起别名处理 防止匹配不正确容器是一个集合 线程安全 所以添加同步 Mybatis连接池的三种配置Mybatis连接池提供了3种方式的配置 配置位置：主配置文件SqlMapConfig.xml中的DataSource标签 type表示的就是采用何种连接池方式连接 type取值： POOLED 采用传统的javax.sql.DataSource规范中的连接池。Mybatis中有针对的规范实现 对应PooledDataSource UNPOOLED 采用传统的获取连接的方式,虽然也实现了Javax.sql.DataSource接口，但没有使用池的思想 对应UnPooledDataSource JNDI 采用服务器提供的JNDI技术实现来获取DataSource对象 不同的服务器所能拿到的DataSource是不一样的 如果不是web或maven的war工程，是不能使用的 tomcat采用的连接池是dbcp连接池下图为mybatis中pooled连接方法原理 事务提交在SqlSessionFactory中的OpenSession(true)可以开启事务自动提交 Mybatis映射文件中的动态sql条件查询**在判断条件test中 使用 and 禁止使用 &amp;&amp; 符号(不支持) ** 1234select * from user where 1=1&lt;if test="username!=null"&gt; and username=#&#123;username&#125; &lt;/if&gt; 判断条件或传入参数要和java中domain包下的属性名保持一致sql语句中可以不注意大小写(window)， 实体类中不可以如果在if标签外添加&lt;where&gt;标签 就不需要 where 1=1 UserDao.xml 123456789101112&lt;!-- 动态sql--&gt; &lt;select id="findAll" parameterType="User" resultType="User"&gt; select * from user &lt;where&gt; &lt;if test="username!=null"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test="sex!=null and sex='男'"&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; UserDao.java 1List&lt;User&gt; findAll(User user); Test 12345678910public void finAll() &#123; User user1 = new User(); user1.setUsername("老王"); user1.setSex("男"); List&lt;User&gt; list = dao.findAll(user1); for (User user : list) &#123; System.out.println(user); &#125; &#125; 范围查询 collection 集合 open 语句起始close 语句末尾 item 内部填充元素 separator 隔断元素 #{} java填充数据 与item中元素名保持一致 123&lt;foreach collection="list" open="and id in (" close=")" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; UserDao.xml 1234567891011&lt;select id="findByIds" parameterType="list" resultType="User"&gt; select * from user &lt;where&gt; &lt;if test="list!=null and list.size()&gt;0"&gt; &lt;foreach collection="list" open="and id in (" close=")" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; UserDao 1List&lt;User&gt; findByIds(List&lt;Integer&gt; list); Test 1234567891011@Testpublic void findByIds() &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(46); list.add(45); list.add(48); List&lt;User&gt; userList = dao.findByIds(list); for (User u : userList) &#123; System.out.println(u); &#125;&#125; 多表查询Mybatis中的关系：一对多多对一一对一多对多 一对一 一对多一个用户可以有多个账号 建立两张表 一张用户表一张账号表 即连接两张表在账号表中添加外键 建立两个实体类 用户类 账号类 并且让他们之间体现一对多关系 建立两张配置文件 当我们查询用户时 可以获取用户下所包含的账号信息当我们查询账号时 可以获取账户所属的用户信息 配置文件：SqlMapConfig.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--主配置文件--&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;!-- 默认是类名小写--&gt; &lt;package name="it.test.domain"/&gt; &lt;/typeAliases&gt; &lt;environments default="sql"&gt; &lt;environment id="sql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;&lt;!-- 配置包 可以加载所有的xml类配置文件--&gt; &lt;package name="it.test.dao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 一对一Account.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package it.test.domain;public class Account &#123; private int id; private int uid; private int money; private User user; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + ", user=" + user + '&#125;'; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public int getMoney() &#123; return money; &#125; public void setMoney(int money) &#123; this.money = money; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; AccountDao.java 123456789package it.test.dao;import it.test.domain.Account;import java.util.List;public interface AccountDao &#123; List&lt;Account&gt; findByOneToOne();&#125; AccountDao.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="it.test.dao.AccountDao"&gt; &lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;association property="user" column="uid"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findByOneToOne" resultMap="accountUserMap"&gt; select * from user,account where user.id = account.uid; &lt;/select&gt;&lt;/mapper&gt; AccountDaoTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package it.test.dao;import it.test.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class AccountDaoTest &#123; InputStream in = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory build = null; SqlSession sqlSession = null; AccountDao dao = null; @Before //方法运行前执行 public void init() throws IOException &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml");// 通过SqlSessionFactoryBuilder构建工厂 builder = new SqlSessionFactoryBuilder(); build = builder.build(in);// 通过工厂生产SqlSession对象 功能：动态代理生成实现类 sqlSession = build.openSession(); dao = sqlSession.getMapper(AccountDao.class); &#125; @After public void close() throws IOException &#123;// 提交事务 不提交会自动回滚 sqlSession.commit(); in.close(); sqlSession.close(); &#125; @Test public void findByOneToOne()&#123; List&lt;Account&gt; list = dao.findByOneToOne(); for (Account account : list) &#123; System.out.println("============================="); System.out.println(account); System.out.println(account.getUser()); &#125; &#125;&#125; 一对多User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package it.test.domain;import java.util.Date;import java.util.List;public class User &#123; private int id; private String userName; private String sex; private String address; private Date birthday; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", userName='" + userName + '\'' + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", birthday=" + birthday + '&#125;'; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; UserDao.java 123456789package it.test.dao;import it.test.domain.User;import java.util.List;public interface UserDao &#123; List&lt;User&gt; finaOneToMore();&#125; UserDao.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;it.test.dao.UserDao&quot;&gt; &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;finaOneToMore&quot; resultMap=&quot;userAccountMap&quot;&gt; select * ,account.id as aid from user left outer join account on user.id = account.uid &lt;/select&gt;&lt;/mapper&gt; UserDaoTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package it.test.dao;import it.test.domain.Account;import it.test.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class UserDaoTest &#123; InputStream in = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory build = null; SqlSession sqlSession = null; UserDao dao = null; @Before //方法运行前执行 public void init() throws IOException &#123; in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);// 通过SqlSessionFactoryBuilder构建工厂 builder = new SqlSessionFactoryBuilder(); build = builder.build(in);// 通过工厂生产SqlSession对象 功能：动态代理生成实现类 sqlSession = build.openSession(); dao = sqlSession.getMapper(UserDao.class); &#125; @After public void close() throws IOException &#123;// 提交事务 不提交会自动回滚 sqlSession.commit(); in.close(); sqlSession.close(); &#125; @Test public void finaOneToMore()&#123; List&lt;User&gt; list = dao.finaOneToMore(); for (User u : list) &#123; System.out.println(&quot;=============================&quot;); System.out.println(u); System.out.println(u.getAccounts()); &#125; &#125;&#125; 多对多一个用户可以有多个角色一个角色可以赋予给多个用户 建立两张表 用户表 角色表让用户表和角色表形成多对多的关系 需要中间表 中间表中包含各自的主键 在中间表中是外键 建立两个实体类 用户类和角色类 两个配置文件 当我们查询用户时 可以同时得到用户下所包含的账户信息当我们查询账户时 可以同时得到账户的所属信息 Role.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="it.test.dao.RoleDao"&gt; &lt;resultMap id="RoleUserMap" type="role"&gt; &lt;id property="id" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="ROLE_NAME"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="ROLE_DESC"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findMoreToMore" resultMap="RoleUserMap"&gt; SELECT u.* ,r.id AS rid,r.role_name,r.role_desc FROM role r LEFT OUTER JOIN user_role ON r.`ID` = user_role.rid LEFT OUTER JOIN USER u ON user_role.`UID` = u.`id` &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 3.实现Dao层开发]]></title>
    <url>%2F2019%2F05%2F03%2FMybatis-3.%E5%AE%9E%E7%8E%B0Dao%E5%B1%82%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[源码流程分析 insert delete update三个方法在DefaultSession中 最后都调用的是update方法，所以在session方法中可以使用update实现CUD操作 使用动态代理会先创建代理实例，根据方法和sql语句判断执行哪一种方法 sqlSession.insert delete update select将获取到的结果，作为方法的返回值传递出去。 配置功能优化 properties属性： 主配置中定义属性标签 可以在标签内配置连接数据库信息 也可以通过属性引用外部配置文件 resource属性：用于指定配置文件位置 是按照类路径的写法来写,并且必须存在于类路径下 url属性：统一资源定位符 唯一表示资源位置 写法 协议 主机 端口 uri http://localhost:8080/mybase/index.html uri :统一资源标识符 应用中可以确定资源的唯一位置 file开头为文件协议 Window系统有省略 1234 &lt;properties resource="JdbcConfig.properties"&gt;&lt;!-- &lt;properties url="file:///C:/Users/CZQYY/IdeaProjects/Mybatis_study1/Day03_MybatisDao%E5%B1%82%E6%93%8D%E4%BD%9C/src/main/resources/JdbcConfig.properties"&gt;--&gt; &lt;/properties&gt; 配置环境中的代码更改为 1234567891011&lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 使用typeAlias配置别名 他只能配置domain中类的别名通过包配置 可以省略包括子配置文件中的全类名 别名为全小写类名 123&lt;typeAliases&gt; &lt;package name="it.test.domain"/&gt; &lt;/typeAliases&gt; UserDaoImpl类 12345678910111213141516171819202122232425262728package it.test.impl;import it.test.dao.UserDao;import it.test.domain.User;import org.apache.ibatis.session.SqlSession;import java.util.List;public class UserDaoImpl implements UserDao &#123; SqlSession session=null; public UserDaoImpl(SqlSession session) &#123; this.session = session; &#125; public List&lt;User&gt; findAll() &#123;// 参数是获取配置信息的key nameSpace.id List&lt;User&gt; list = session.selectList("it.test.dao.UserDao.findAll"); return list; &#125;// insert delete update @Override public int count() &#123; Object o = session.selectOne("it.test.dao.UserDao.count"); return (int) o; &#125;&#125; JdbcConfig.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/testusername=rootpassword=root SqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--主配置文件--&gt;&lt;configuration&gt; &lt;!--主配置中定义属性标签--&gt; &lt;!--可以在标签内配置连接数据库信息 也可以通过属性引用外部配置文件 resource属性：用于指定配置文件位置 是按照类路径的写法来写,并且必须存在于类路径下 url属性：统一资源定位符 唯一表示资源位置 写法 协议 主机 端口 uri http://localhost:8080/mybase/index.html uri :统一资源标识符 应用中可以确定资源的唯一位置 file开头为文件协议 Window系统有省略--&gt; &lt;properties resource="JdbcConfig.properties"&gt;&lt;!-- &lt;properties url="file:///C:/Users/CZQYY/IdeaProjects/Mybatis_study1/Day03_MybatisDao%E5%B1%82%E6%93%8D%E4%BD%9C/src/main/resources/JdbcConfig.properties"&gt;--&gt; &lt;/properties&gt;&lt;!-- 使用typeAlias配置别名 他只能配置domain中类的别名通过包配置 可以省略包括子配置文件中的全类名 只是用类名即可--&gt; &lt;typeAliases&gt; &lt;package name="it.test.domain"/&gt; &lt;/typeAliases&gt;&lt;!-- 配置环境--&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;&lt;!-- 注解配置--&gt; &lt;mapper class="it.test.dao.UserDao"&gt;&lt;/mapper&gt;&lt;!-- xml配置--&gt; &lt;mapper resource="it/test/dao/UserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置]]></title>
    <url>%2F2019%2F05%2F03%2FHexo%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[首先 学会Hexo下的MarkDown的语法 因为MarkDown下的语法和Hexo框架下支持的语法有所差别，所以对Hexo进行相关语言的了解 语法： https://www.jianshu.com/p/5e9af02c36b3更改默认头信息位于该目录D:\java\blog\scaffolds下的post.md文中 使用HexoEditor编辑 坚持使用Hexo记笔记！！！！！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
