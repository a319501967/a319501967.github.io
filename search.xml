<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringCloud 2.Hystix Fiegn Zuul]]></title>
    <url>%2F2019%2F07%2F12%2FSpringCloud-2.Hystix-Fiegn%2F</url>
    <content type="text"><![CDATA[Hystix熔断器 (电路短路 立刻熔断 防止发生用电火灾) 一般作用于消费者Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 雪崩问题分析正常的微服务项目如果出现了其中一个服务故障 则会出现阻塞服务器现象如果好多人同时访问这个功能 则会造成服务器饱和 服务器就不工作了 Hystix功能防止任何单个依赖项耗尽所有容器（如Tomcat）用户线程。甩掉包袱，快速失败而不是排队在任何可行的地方提供回退，以保护用户不受失败的影响。使用隔离技术（如隔离板、泳道和断路器模式）来限制任何一个依赖项的影响。通过近实时的度量、监视和警报来优化发现时间。通过配置的低延迟传播来优化恢复时间。支持对Hystrix的大多数方面的动态属性更改，允许使用低延迟反馈循环进行实时操作修改。避免在整个依赖客户端执行中出现故障，而不仅仅是在网络流量中。 Hystix如何实现 线程隔离和服务降级线程隔离是内部实现的 服务降级 需要提供失败后降级执行的方法用一个HystrixCommand或者 HystrixObservableCommand （这是命令模式的一个例子）包装所有的对外部系统（或者依赖）的调用，典型地它们在一个单独的线程中执行调用超时时间比你自己定义的阈值要长。有一个默认值，对于大多数的依赖项你是可以自定义超时时间的。为每个依赖项维护一个小的线程池(或信号量)；如果线程池满了，那么该依赖性将会立即拒绝请求，而不是排队。调用的结果有这么几种：成功、失败（客户端抛出异常）、超时、拒绝。在一段时间内，如果服务的错误百分比超过了一个阈值，就会触发一个断路器来停止对特定服务的所有请求，无论是手动的还是自动的。当请求失败、被拒绝、超时或短路时，执行回退逻辑。具体原理查询 作者：废物大师兄 Hystrix是如何工作的 熔断器熔断原理总请求失败 或者出现异常 则会出现熔断现象熔断器开始时 该服务会直接调用错误方法HystrixCommandProperties文件中我们可以查看到default_circuitBreakerErrorThresholdPercentage 请求连接失败率 默认为50default_circuitBreakerSleepWindowInMilliseconds 熔断时间 默认5000毫秒default_circuitBreakerRequestVolumeThreshold 触发熔断个数 20个 （查看20个内熔断比例）同样我们搜索以后 可以在方法中 或者 配置文件中进行配置配置文件表 作者：佳716 熔断机制HYSTRIX Hystix代码实现（基本使用）1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; CustomerApplication正常情况下添加注解 @EnableCircuitBreaker但是我们Spring对Erueda springboot Hystix整合注解成为SpringCloudApplication() 12345678910111213141516//@EnableCircuitBreaker//@EnableDiscoveryClient//@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@SpringCloudApplication()public class CustomerApplication &#123; @Bean @LoadBalanced //添加负载均衡标识 erueka jar包中 包含 ribbon public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(CustomerApplication.class); &#125;&#125; CustomerController第一种 @DefaultProperties(defaultFallback = &quot;fallbackMethod&quot;)为在类所有方法提供统一的失败方法 该方法参数列表必须为空第二种 @HystrixCommand 为单独方法提供 此时我们需要配置单独的失败方法 返回值类型和参数列表必须和 方法一致 12345678910111213141516171819202122232425262728293031323334@Controller@DefaultProperties(defaultFallback = "fallbackMethod") //默认方法为空参数public class CustomerController &#123; @Autowired private RestTemplate restTemplate; // @HystrixCommand(fallbackMethod = "fallbackMethod") 配置单独的熔断错误方法 @RequestMapping("/findById") @ResponseBody public Seller findById(@RequestParam(name = "id", defaultValue = "1") Integer id) &#123; // url 中间为服务名 String url = "http://seller-provide/findById?id=" + id;// 默认为Json Seller seller = restTemplate.getForObject(url, Seller.class); System.out.println(seller); return seller; &#125; /** * 错误方法必须与成功方法 返回值 和参数类型完全一致 * * @param * @return *//* public String fallbackMethod(Integer id) &#123; return "抱歉 服务器拥挤 请稍后再试"; &#125;*/ public String fallbackMethod() &#123; return "抱歉 服务器拥挤 请稍后再试"; &#125;&#125; Hystix代码实现(高级使用)我们可以在方法的@HystrixCommand中添加commandProperties 属性控制单个方法的熔断时间默认为1s 123@HystrixCommand(fallbackMethod = "fallbackMethod",commandProperties = &#123; @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "2000") //默认熔断时间设置为2s &#125;) 值我们去hystrix包中去找HystrixCommandProperties其中 default_executionTimeoutInMilliseconds为默认熔断时间通过搜索栏 可以找到默认的key值 1234567hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix全局的超时时间为6000ms 如果我们需要获得单独某个服务的超时时间 在default 处改为某个服务名即可 FeignFeign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 默认支持 Ribbon轮询功能 熔断Hystrix需要手动开启 Feign中的Ribbon配置方法和单独引用ribbon配置方法相同 1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 Feign中的Hystix开启Hystix 默认关闭 123feign: hystrix: enabled: true # 开启Feign的熔断功能 代码实现1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 启动类添加注解 123456789@SpringCloudApplication@EnableFeignClients //开启Feignpublic class CustomerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CustomerApplication.class); &#125;&#125; fallback 配置的是 失败方法 需要实现当前的SellerClient接口 123feign: hystrix: enabled: true # 开启Feign的熔断功能 12345678@FeignClient(value = "seller-provide",fallback = SellerFallBack.class)public interface SellerClient &#123; @RequestMapping("/findById?id=&#123;id&#125;") // 添加 RequestParam 就可以 获取值 Seller querySellerById(@RequestParam(name = "id") Integer id);&#125; 实现类 123456789@Componentpublic class SellerFallBack implements SellerClient &#123; @Override public Seller querySellerById(Integer id) &#123; Seller seller = new Seller(); seller.setSname("服务器正忙 请稍后再试"); return seller; &#125;&#125; controller 12345678910111213@Controllerpublic class CustomerController &#123; @Autowired private SellerClient client; @RequestMapping("/findById") @ResponseBody public Seller findById(@RequestParam(name = "id", defaultValue = "1") Integer id) &#123; // feign 默认配置了负载均衡 ribbon return client.querySellerById(id); &#125;&#125; Zuul Zuul 加入后的架构形式不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 过滤器ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 内置过滤器： 使用场景请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了异常处理：一般会在error类型和post类型过滤器中结合来处理。服务调用时长统计：pre和post结合使用。 代码实现pom.xml引入erueka zuul依赖 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;zuul_service&lt;/artifactId&gt;&lt;!-- zuul--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- erueka 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- apache 提供的工具类 例如 SpringUtils--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ZuulApplication启用@EnableDiscoveryClient @EnableZuulProxy注解 12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class); &#125;&#125; application.ymlribbon 重试时间应该小于 熔断等待时间 因为默认熔断时间为1s所以我们需要重新配置默认情况下:ribbon的超时时长 真实值为(read+connect)* 2 必须小于Hystrix 时长ribbonTimeOut = (readTimeout+ribbonConnectout)*(maxAutoRetries+1)*(maxAutoRetriesNextServer+1)ribbon和Hystrix配置属性模版（参数按照公式配制）： 123456789101112131415zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms 12345678910111213141516171819202122232425262728293031323334server: port: 9000zuul: routes: seller-customer: /seller-customer/** # seller-customer: # 这里是路由id，随意写 # path: /seller-customer/** # 这里是映射路径 # service-id: seller-customer # 指定服务名称 # strip-prefix: false # 去除前缀 false 就不用写 网关代理路径 ignored-services: # 集合形式 不进入网关同一的服务 - seller-provideeureka: client: registry-fetch-interval-seconds: 5 # 5s拉去一次列表 service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:9999/eurekaspring: application: name: zuul-servicehystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000msribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) 过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import org.apache.commons.lang3.StringUtils;import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;@Componentpublic class LoginFilter extends ZuulFilter &#123; @Override /** * 声明拦截器触发事件 * pre：请求在被路由之前执行 * routing：在路由请求时调用 * post：在routing和errror过滤器之后调用 * error：处理请求时发生错误调用 */ public String filterType() &#123; return FilterConstants.PRE_TYPE; &#125; /** * 通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 * * @return */ @Override public int filterOrder() &#123; return FilterConstants.PRE_DECORATION_FILTER_ORDER; &#125; /** * 返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 * * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /** * 拦截器业务逻辑 * * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123;// 获取请求上下文 RequestContext context = RequestContext.getCurrentContext();// 获取request HttpServletRequest request = context.getRequest();// 获取请求参数 access String access = request.getParameter("access"); if (StringUtils.isBlank(access)) &#123;// 不存在 未登录 则拦截 context.setSendZuulResponse(false);// 返回相应的状态码 context.setResponseStatusCode(HttpStatus.FORBIDDEN.value()); &#125; System.out.println(access); return null; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL 知识杂谈2]]></title>
    <url>%2F2019%2F07%2F12%2FSQL-%E9%94%99%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[MySQL 索引组合索引最左优先原则组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到。只要组合索引最左边第一个字段出现在Where中，那么不管后面的字段出现与否或者出现顺序如何，MySQL引擎都会自动调用索引来优化查询效率。 根据最左匹配原则可以知道B-Tree建立索引的过程，比如假设有一个3列索引(col1,col2,col3),那么MySQL只会会建立三个索引(col1),(col1,col2),(col1,col2,col3)。题目会创建三个索引（plat_order_id）（plat_order_id与plat_game_id的组合索引）（plat_order_id、plat_game_id与plat_id的组合索引）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 1.入门 Erueka Ribbon]]></title>
    <url>%2F2019%2F07%2F11%2FSpring-Cloud-1.%E5%85%A5%E9%97%A8-Erueka-Ribbon%2F</url>
    <content type="text"><![CDATA[分布式** 垂直拆分 ** 代码耦合，开发维护困难无法针对不同模块进行针对性优化无法水平扩展单点容错率低，并发能力差** 分布式 ** 将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。即让服务调用服务 完成功能 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点：系统间耦合度变高，调用关系错综复杂，难以维护 服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键但依旧存在许多问题服务间会有依赖关系，一旦某个环节出错会影响较大服务关系复杂，运维、测试部署困难，不符合DevOps思想 微服务微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立：服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 远程调用方式 RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，** 速度快，效率高。**早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。现在热门的Rest风格，就可以通过http协议来实现。 我们采用的是Spring RestTemplate实现 Spring Cloud主要组件 ** Eureka：注册中心 ** ** Zuul：服务网关 ** ** Ribbon：负载均衡 ** ** Feign：服务调用 ** ** Hystix：熔断器 ** Eureka注册中心我们直接使用RestTemplate 会直接将 URL暴漏出来 如果ip地址 端口更换 我们需要自己手动改变 不好所以我们需要注册中心 将所有服务注册到 注册中心 进行统一的调用的 和 控制同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。这就实现了服务的自动注册、发现、状态监控。Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址提供者：启动后向Eureka注册自己信息（地址，提供什么服务）消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 负载均衡器 Ribbon如果我们为了防止因为服务器宕机造成项目失效 则需要准备多个服务器启动 这时我们为了让多个同项目实例 分担压力 我们就使用负载均衡算法 让 Eureka 给消费者提供合理的服务器进行使用，减小各个服务器压力 代码分析Eureka名字： 无论是 提供者 注册中心 消费者 都需要在yml配置文件中配置名字 不能用下划线 可以用中划线 下划线Ribbon 无法识别** 注册地址 **：如果存在多台 eureka 则 消费者和提供者都要绑定多台 eureka建立集群也需要绑定多台 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。即注册中心形成集群 12345678910111213server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 # defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 绑定自己 defaultZone: http://127.0.0.1:9998/eureka # 绑定9998 注册中心 （9998绑定9999） # 消费者需要绑定多台注册中心 defaultZone: http://127.0.0.1:9999/eureka,http://127.0.0.1:9998/eureka 服务提供者1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 服务消费者 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 我们可以不修改 失效剔除和自我保护我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 我们关停一个服务，就会在Eureka面板看到一条警告：触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。关闭方法 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） Ribbon实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个默认情况下 选择的是轮询的负载均衡方法SpringBoot也帮我们提供了修改负载均衡规则的配置入口： 123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 实例代码 包含POM.XML配置父工程POM.XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 三个子工程--&gt; &lt;modules&gt; &lt;module&gt;seller_provide&lt;/module&gt; &lt;module&gt;erueka_service&lt;/module&gt; &lt;module&gt;seller_customer&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt;&lt;!--父工程引用--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.M4&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt;&lt;!--版本锁定 以后 org.springframework.cloud 都是用此版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.2.0.M4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;!--通用Mapper--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt;&lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt; 5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;!-- 插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; erueka_servicePOM.XML1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;erueka_service&lt;/artifactId&gt;&lt;!--添加eureka支持--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml123456789server: port: 9999spring: application: name: erueka-seviceeureka: client: service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka EruakaApplication123456789101112import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) @EnableEurekaServer // EurekaServer 服务器端public class EruakaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EruakaApplication.class); &#125;&#125; seller_providePOM.XML12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;seller_provide&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt; spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- eureka 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml12345678910111213141516server: port: 8081spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/travel username: root password: root application: name: seller-providemybatis: type-aliases-package: "it.test.domain"eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:9999/eureka ProvideApplication12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import tk.mybatis.spring.annotation.MapperScan;@EnableDiscoveryClient //eruaka服务端 因为这个注解spring提供 支持多种注册中心@SpringBootApplication@MapperScan("it.test.dao")public class ProvideApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProvideApplication.class); &#125;&#125; ProvideController1234567891011121314151617181920import it.test.dao.SellerDao;import it.test.domain.Seller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class ProvideController &#123; @Autowired private SellerDao dao; @RequestMapping("/findById") @ResponseBody public Seller findById(@RequestParam(name = "id",defaultValue = "1") Integer id) &#123; return dao.selectByPrimaryKey(id); &#125;&#125; SellerDao12345678import it.test.domain.Seller;import org.springframework.stereotype.Repository;import tk.mybatis.mapper.common.Mapper;@Repositorypublic interface SellerDao extends Mapper&lt;Seller&gt; &#123;&#125; Seller123456789101112131415161718import lombok.Data;import tk.mybatis.mapper.annotation.KeySql;import javax.persistence.Id;import javax.persistence.Table;import javax.persistence.Transient;@Data@Table(name = "tab_seller") // 对应的表public class Seller &#123; @Id // 主键 @KeySql(useGeneratedKeys = true) // 自增 private Integer sid; private String sname; private String consphone; private String address; @Transient // 不需要持久化 private String sex;&#125; seller_customerPOM.XML12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;seller_ customer&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml12345678910server: port: 8082spring: application: name: seller-customereureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:9999/eureka CustomerApplication123456789101112131415161718192021import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@EnableDiscoveryClient@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)public class CustomerApplication &#123; @Bean @LoadBalanced //添加负载均衡标识 erueka jar包中 包含 ribbon public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(CustomerApplication.class); &#125;&#125; CustomerController1234567891011121314151617181920212223242526272829import it.test.domain.Seller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.client.RestTemplate;@Controllerpublic class CustomerController &#123; @Autowired private RestTemplate restTemplate; @RequestMapping("/findById") @ResponseBody public Seller findById(@RequestParam(name = "id", defaultValue = "1") Integer id) &#123; // url 中间为服务名 String url = "http://seller-provide/findById?id=" + id; Seller seller = restTemplate.getForObject(url, Seller.class); System.out.println(url); seller.setSex("男"); return seller; &#125;&#125; seller和提供者相同]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 1.SpringBoot入门 -实现版]]></title>
    <url>%2F2019%2F07%2F09%2FSpringBoot-1.SpringBoot%E5%85%A5%E9%97%A8--%E5%AE%9E%E7%8E%B0%E7%89%88%2F</url>
    <content type="text"><![CDATA[spring boot 版本号 2.0.4 常用注解@SpringBootApplicationSpringBoot主配置类 配置后Spring会扫描当前包及子包的文件并加入Spring容器中所以主配置类不要放入单独的包中 @MapperScan(&quot;it.test.mapper&quot;) 配置扫描Mapper对象 即没有实现类 只有接口的Dao对象 @Configuration配置类注解 Spring加载到时会识别他为配置类@RunWith(SpringRunner.class)@SpringBootTesttest类注解 使用后才能引入spring 容器对象进行注入 完整pom.xmlmapper中自带mybatis和spring-boot-jdbc 连接池如果添加mapper则不用添加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;SpringBoot完整项目搭建&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池--&gt; &lt;!-- &lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/dependency&gt;--&gt; &lt;!-- 数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;--&gt; &lt;!-- &lt;version&gt; 2.0.1&lt;/version&gt;--&gt; &lt;!-- &lt;/dependency&gt;--&gt; &lt;!-- 通用Mapper--&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yamlspring 配置的是 HikariCP 数据库连接池 1234567891011121314151617# 配置端口号server: port: 8080# 日志等级logging: level: it.test: info org.springframework: infospring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/travel username: root password: root# 指定自定义javaBean引用mybatis: type-aliases-package: it.test.domain MySpringBootApplication 核心配置类123456789101112import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@SpringBootApplication@MapperScan("it.test.mapper")public class MySpringBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MySpringBootApplication.class,args); &#125;&#125; 主配置文件配置Mapper扫描 当主配置文件加载时 扫描Mapper 生成dao代理对象 MyInterceptor 自定义拦截器使用lombok @Slf4j不用手动创建对象 12345678910111213141516171819202122232425262728import lombok.extern.slf4j.Slf4j;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Slf4jpublic class MyInterceptor implements HandlerInterceptor &#123;// private static final Logger log = LoggerFactory.getLogger(MyInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info("preHandle is running"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info("preHandle is running"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info("preHandle is running"); &#125;&#125; MvcConfig 注册拦截器12345678910111213141516import it.test.interceptor.MyInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 注册拦截器 */@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**"); &#125;&#125; UserMapper继承Mapper即可以实现所有的单表操作功能 不需要自己写 12345import it.test.domain.Seller;import tk.mybatis.mapper.common.Mapper;public interface UserMapper extends Mapper&lt;Seller&gt; &#123;&#125; domain123456789101112131415161718import lombok.Data;import tk.mybatis.mapper.annotation.KeySql;import javax.persistence.Id;import javax.persistence.Table;import javax.persistence.Transient;@Data@Table(name = "tab_seller") // 对应的表public class Seller &#123; @Id // 主键 @KeySql(useGeneratedKeys = true) // 自增 private Integer sid; private String sname; private String consphone; private String address; @Transient // 不需要持久化 private String sex;&#125; 静态文件或者命名为public]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea 插件]]></title>
    <url>%2F2019%2F07%2F09%2Fidea-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[lombok默认为javabean生成如下 1234567* @see Getter* @see Setter* @see RequiredArgsConstructor* @see ToString* @see EqualsAndHashCode* @see lombok.Value* 使用方法 setting-&gt; Plugins-&gt;搜索lombok 下载 重启idea &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt; 1.18.8&lt;/version&gt; &lt;/dependency&gt;]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F07%2F08%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[元字符 描述 \ 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 \$ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，\$也匹配“\n”或“\r”之前的位置。 \* 匹配前面的子表达式任意次。例如，zo\*能匹配“z”，也能匹配“zo”以及“zoo”。\*等价于o{0,} + 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 ['o', 'o', 'o', 'o'] .点 匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身. [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持 \D 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何可见字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的&quot;单词&quot;字符使用Unicode字符集。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础-2.链表]]></title>
    <url>%2F2019%2F07%2F04%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-2.%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表单链表链表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class Node &#123; int val; Node next; public Node(int val) &#123; this.val = val; &#125;&#125;class MyLinkedList &#123; int size; // 链表长度 Node head; //头 /** * Initialize your data structure here. */ public MyLinkedList() &#123; &#125; /** * 检验索引是否正确 * * @param index * @return */ private boolean checkIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) return false; return true; &#125; /** * 根据索引索取Node * * @param index * @return */ private Node getNode(int index) &#123; if (index == 0) return head; Node temp = head.next; for (int i = 1; i &lt; index; i++) &#123; temp = temp.next; &#125; return temp; &#125; /** * get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 */ public int get(int index) &#123; if (checkIndex(index) == false) return -1; Node node = getNode(index); return node.val; &#125; /** * addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 */ public void addAtHead(int val) &#123; Node newNode = new Node(val); if (size == 0) &#123; head = newNode; size++; &#125; else &#123; newNode.next = head; head = newNode; size++; &#125; &#125; /** * addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 */ public void addAtTail(int val) &#123; if (size-1&lt;0)&#123; addAtHead(val); return; &#125; Node node = getNode(size - 1); node.next = new Node(val); size++; &#125; /** * addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。 * 如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。 */ public void addAtIndex(int index, int val) &#123; if (index &gt; size) return; if (index &lt;= 0) &#123; addAtHead(val); return; &#125; Node newNode = new Node(val); Node frontNode = getNode(index - 1); newNode.next = frontNode.next; frontNode.next = newNode; size++; &#125; /** * deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 */ public void deleteAtIndex(int index) &#123; if (checkIndex(index) == false) return; if (index == size) return; if (size == 0) return; if (index == 0) &#123; head = head.next; size--; return; &#125; Node frontNode = getNode(index - 1); frontNode.next = frontNode.next.next; size--; &#125;&#125; 排序1234567891011121314151617181920public int sortNode()&#123; if (size==0)return -1; if (size==1) return head.val; Node frondNode = head; Node backNode = null; int change = 0; while (frondNode.next!=null)&#123; backNode = frondNode.next; while (backNode!=null)&#123; if (frondNode.val&lt;backNode.val)&#123; change= frondNode.val; frondNode.val =backNode.val; backNode.val =change; &#125; backNode = backNode.next; &#125; frondNode =frondNode.next; &#125; return head.val; &#125; 查找倒数第n个元素查找倒数第n个元素 一次循环 设定两个指针 第一个指针先前进 n-1 步 然后两个指针同时移动到第一个指针next为空时 第二个指针就是要查找的元素 123456789101112131415161718192021222324252627282930313233package 链表.单链表;class ListNode1 &#123; int val; ListNode1 next; ListNode1(int x) &#123; val = x; &#125;&#125;public class Solution1 &#123; public ListNode1 findNode(ListNode1 head, int n) &#123; if (head == null) return null; int length = 0; ListNode1 lengthNode = head; while (lengthNode != null) &#123; lengthNode = lengthNode.next; length++; &#125; if (n &lt;= 0 | n &gt; length) return null; if (n == length) &#123; head = head.next; &#125; ListNode1 node1 = head; ListNode1 node2 = head; for (int i = 0; i &lt; n-1; i++) &#123; node1 = node1.next; &#125; while (node1.next != null) &#123; node1 = node1.next; node2 = node2.next; &#125; return head; &#125;&#125; 链表反转123456789101112131415161718class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null) return null; if (head.next == null) return head; ListNode nowNode = head; // 当前节点 ListNode beforeNode = null; // 前节点 while (nowNode != null) &#123; ListNode afterNode = nowNode.next; // 后节点 nowNode.next = beforeNode; // 前一个节点作为现在节点的下一个节点 // 为下一次 前一个节点作为现在节点的next节点做准备 beforeNode = nowNode; // 向后移动前节点 nowNode = afterNode; // 向后移动当前节点 &#125; return beforeNode; &#125; &#125; 链表是否有环1234567891011121314151617181920/** * 快慢指针 */public class 链表是否有环 &#123; public boolean checkHoop(Node head)&#123; Node firstNode = head; Node slowNode = head; if (firstNode == null)&#123; return false; &#125; while (firstNode!=null&amp;&amp;firstNode.next!=null)&#123; firstNode = firstNode.next.next; slowNode = slowNode .next; if (firstNode==slowNode)&#123; return true; &#125; &#125; return !(firstNode==null||firstNode.next==null); &#125;&#125; 删除第n个节点12345678910111213141516171819202122232425262728293031 /** * 删除倒数第n个节点 */ public Node removeNthFromEnd(Node head, int n) &#123; if (head == null) return null; int length = 0; Node lengthNode = head; while (lengthNode != null) &#123; lengthNode = lengthNode.next; length++; &#125; if (n &lt;= 0 | n &gt; length) return null; Node node1 = head; Node node2 = head; if (n == length) &#123; head = head.next; &#125;// 搜索要删除的前一个节点 for (int i = 0; i &lt; n; i++) &#123; node1 = node1.next; &#125; while (node1.next != null) &#123; node1 = node1.next; node2 = node2.next; &#125; node2.next = node2.next.next; return head; &#125; 从尾到头输出单链表元素123456789101112/** * 使用递归的方法从后往前输出 */public class 从尾到头输出单链表元素 &#123; public void printReversely(Node node) &#123; if (node!=null)&#123; printReversely(node.next); System.out.println(node.val); &#125; &#125;&#125; 两个链表是否相交123456789101112131415161718/** * 如果两个链表相交 * 判断尾节点是否相等 */public class 两个链表是否相交 &#123; public boolean crossNode(Node n1,Node n2)&#123; if (n1==null||n2==null)&#123; return false; &#125; if (n1.next!=null)&#123; n1 = n1.next; &#125; if (n2.next!=null)&#123; n2 = n2.next; &#125; return n1 == n2; &#125;&#125; 判断相交的第一个节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 判断从哪个点开始相交的 * 需要先判断是否相交 */public class 判断相交的第一个节点 &#123; public Node getNodeInCross(Node node1, Node node2) &#123;// 先判断是否相交 if (node1 == null || node2 == null) return null; Node checkNode1 = node1; int checkLength1= 0 ; if (checkNode1.next != null) &#123; checkNode1 = checkNode1.next; checkLength1++; &#125; Node checkNode2 = node2; int checkLength2= 0; if (checkNode2.next != null) &#123; checkNode2 = checkNode2.next; checkLength2++; &#125; // 如果不相交直接返回 if (checkNode1 != checkNode2) &#123; return null; &#125; Node n1 = node1; Node n2 = node2; if (checkLength1&gt;checkLength2)&#123; int d = checkLength1-checkLength2; while (d!=0)&#123; n1 = n1.next; d--; &#125; &#125;else if (checkLength1&lt;checkLength2)&#123; int d = checkLength2-checkLength1; while (d!=0)&#123; n2 = n2.next; d--; &#125; &#125; while (n1!=n2)&#123; n1 = n1.next; n2 = n2.next; &#125; return n1; &#125;&#125; 不知道头节点情况下删除指定节点12345678910111213141516/** * 将该节点和后节点值进行交换 然后将该节点.next = 后节点的.next 上 */public class 不知道头节点情况下删除指定节点 &#123; public boolean deleteNode(Node node)&#123; /** * 后置节点没办法删除 因为无法找到对应的前置节点 */ if (node==null||node.next==null)&#123; return false; &#125; node.val = node.next.val; node.next = node.next.next; return true; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛客网面试错题集 3]]></title>
    <url>%2F2019%2F07%2F04%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E8%AF%95%E9%94%99%E9%A2%98%E9%9B%86-3%2F</url>
    <content type="text"><![CDATA[Servlet如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。 JDBCJava数据库连接库JDBC用到哪种设计模式?桥接模式 异常在try语句块或catch语句块中执行到System.exit(0)直接退出程序 finally不会执行运行时异常 包括：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。非运行时异常（编译异常） 包括：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常 finally() 不是object 方法如果catch中有return finally 也有return 执行 finally中的 运算符运算顺序%``*同级 虚拟机运行参数-Xmx：最大堆大小-Xms：初始堆大小-Xmn:年轻代大小-XXSurvivorRatio：年轻代中Eden中所占份数 -Xmn5120m -XXSurvivorRatio=3 年轻代 Eden和两块一样大小的Survivor 即 3x+x+x= 5120 所以survivor两块共同的大小为2048m Java 编码 Java默认使用Unioncode编码，即不论什么语言都是一个字符占两个字节 Java的class文件编码为UTF-8，而虚拟机JVM编码为UTF-16 实现国际化应用常用的手段是利用ResourceBundle类 Java 体系结构 Java编程语言 Java类文件格式 Java API JVM web.xml 使用Servlet过滤器，需要在web.xml中配置 &lt;filter&gt; &lt;filter-mapping&gt; Object任何一种数据类型的变量赋给Object类型的变量。基本数据类型会** 自动装箱** 赋值给Object 语言种类强类型 弱类型 动态语言 静态语言 static在类方法中调用实例方法是可以的 例如main方法创建对象 并调用方法]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法基础 1.稀疏数组，队列]]></title>
    <url>%2F2019%2F07%2F02%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-1.%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[稀疏数组基本介绍当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。稀疏数组的处理方法是: 记录数组一共有几行几列，有多少个不同的值把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模稀疏数组第一行记录 行 列 有效数接下来每行记录他所在的位置 及 所对应的值 举例说明有左图转换为右图 压缩数组 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package 稀疏数组;/** * 创建11*11的数组 1 黑子 2白子 */public class SparseArr &#123; public static void main(String[] args) &#123; int[][] oldArr = new int[11][11];// 在第二行 第三列填黑子 oldArr[1][2] = 1;// 在第三行 第四列填白子 oldArr[2][3] = 2; System.out.println("原始数组"); for (int[] ints : oldArr) &#123; for (int anInt : ints) &#123; System.out.print(anInt + "\t"); &#125; System.out.println(); &#125;// 获取稀疏数组 int[][] sparseArr = getSparseArr(oldArr); System.out.println("稀疏数组"); for (int[] ints : sparseArr) &#123; for (int anInt : ints) &#123; System.out.print(anInt + "\t"); &#125; System.out.println(); &#125;// 将稀疏数组 改成原始数组 int[][] getOldArr = getOldArr(sparseArr); System.out.println("稀疏数组转换原始数组"); for (int[] ints : getOldArr) &#123; for (int anInt : ints) &#123; System.out.print(anInt + "\t"); &#125; System.out.println(); &#125; &#125; /** * 返回稀疏数组 * * @param oldArr * @return */ private static int[][] getSparseArr(int[][] oldArr) &#123;// 获取有效数组个数,获取行数列数 int sum = 0; // 有效数 int row = oldArr.length; //行数 int col = oldArr[1].length; //列数// 获取有效数 for (int[] ints : oldArr) &#123; for (int anInt : ints) &#123; if (anInt != 0) &#123; sum++; &#125; &#125; &#125;// 创建稀疏数组 int[][] sparseArr = new int[sum + 1][3];// 第一行储存数组几行几列 有几个有效值 sparseArr[0][0] = row; sparseArr[0][1] = col; sparseArr[0][2] = sum;// 将 值 和所对应的的行列填入 稀疏数组// 创建指针确定存入稀疏数组的行数 int a = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (oldArr[i][j] != 0) &#123; a++; sparseArr[a][0] = i; sparseArr[a][1] = j; sparseArr[a][2] = oldArr[i][j]; &#125; &#125; &#125; return sparseArr; &#125; /** * 获取原始数组 * * @param sparseArr * @return */ private static int[][] getOldArr(int[][] sparseArr) &#123;// 根据稀疏数组存储的行列 创建新数组 int[][] ordArr = new int[sparseArr[0][0]][sparseArr[0][1]];// 根据有效值个数决定 循环几次 复制给原始数组// 从第二行开始循环 对相应位置的原始数组进行赋值 for (int i = 1; i &lt;= sparseArr[0][2]; i++) &#123; ordArr[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2]; &#125; return ordArr; &#125;&#125; 输出结果 队列队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，行删除操作的端称为队头。** 队列中没有元素时，称为空队列。** ** 每次添加操作 要判断一次 数组是否满 每次获取时 要判断数组是否为空 ** 非循环队列数组添加 尾部指针 p_back判断空队列：如果尾部指针等于 p_start 则数组为空 ** **添加元素移动头部指针 获取元素移动尾指针** 头指针+1 等于 数组长度时 数组满** ArrayList只需要一个头指针 因为ArrayList 是可变数组。不会造成满的情况因为长度可变 判断是否为空的方法是判断** 头指针是否大于等于集合长度如果头指针长度大于等于 则说明输入的数据都取出 无数据可取如果头指针小于 则说明还有数组未取出 ** 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package 队列入门.非循环队列;/* 数组情况 添加 尾部指针 p_back 如果尾部指针等于 p_start 则数组为空 添加元素动头部指针 获取元素动尾指针 头指针+1 等于 数组长度时 数组满* */import java.util.ArrayList;import java.util.List;public class CreateQueue &#123; public static void main(String[] args) &#123; MyQueue q = new MyQueue(); q.addQueue(5); q.addQueue(3); if (q.isEmpty() == false) &#123;// 此时指针是0 获取 第一个元素5 System.out.println(q.Front()); &#125;// 删除元素 -指针后移 q.deQueue(); if (q.isEmpty() == false) &#123;// 此时指针是1 获取第二个元素 System.out.println(q.Front()); &#125;// q.deQueue(); if (q.isEmpty() == false) &#123; System.out.println(q.Front()); &#125; &#125;&#125;class MyQueue &#123; private List&lt;Integer&gt; data; // 设定一个开始指针 private int p_start; /** * 构造方法创建一个ArrayList实例 给指针赋值0 */ public MyQueue() &#123; data = new ArrayList&lt;Integer&gt;(); p_start = 0; &#125; /** 添加元素 */ public boolean addQueue(int x) &#123; data.add(x); return true; &#125;; /** 去掉一个元素 * 其实并没有真的删除元素 只是操作指针向前移动 */ public boolean deQueue() &#123; if (isEmpty() == true) &#123; return false; &#125; p_start++; System.out.println("此时指针变为"+p_start); return true; &#125; /** 获取元素. */ public int Front() &#123; return data.get(p_start); &#125; /** 如果指针数大于等于队列长度 对列为空 */ public boolean isEmpty() &#123; boolean flag= p_start &gt;= data.size(); if (flag==true)&#123; System.out.println("集合中没有数据"); &#125;else &#123; System.out.println("集合有数据 可以取出"); &#125; return flag; &#125;&#125;; 结果 循环队列判断空 当头指针和尾指针相等判断满 满的时候尾指针一定走完一圈 所以(尾指针+1)%maxSize=头指针如果一圈放六个 头指针在第1个 尾指针在第6个 满足公式]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL知识杂谈]]></title>
    <url>%2F2019%2F07%2F01%2FSQL%E7%9F%A5%E8%AF%86%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[** 知识来源《SQL必知必会》进行知识补充 ** Mysql 中的 LIMIT SELECT * FROM table LIMIT 5,10; 可以记成前面有5个 往后检索10个 即检索的是6-15 ORDER BY 默认升序 降序DESCselect * from product order by name DESC 可以按照 单列 进行字母排序select * from product order by name ** 注：ORDER BY 子句一定要放在sql语句最后面** 可以按照 多列 进行字母排序优先考虑 靠近ORDER BY子句的列名进行排序 如果第一列相同 再考虑第二列 如果想在多列进行排序 则需要在每个列后面加DESC 优先级AND 比OR优先级高 如果需要改变优先级 请添加括号 性能IN 操作符运算速度高于 OR尽量少使用通配符 % _ 拼接SELECT * FROM tab_sellerSELECT CONCAT(sname,&#39;(&#39;,address,&#39;)&#39;) FROM tab_seller 别名最好使用AS 不要使用 空格SELECT CONCAT(sname,&#39;(&#39;,address,&#39;)&#39;) AS PINJIE FROM tab_seller 计算可以直接使用select 3*2 计算可以使用select now() 查看当前时间 函数upper() 提升为大写SELECT UPPER(bigPic) FROM tab_route_img count（）count（*） 不论行值是否为null 都会记录进来]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 1.SpringBoot入门 -详解版]]></title>
    <url>%2F2019%2F06%2F30%2FSpringBoot-1.SpringBoot%E5%85%A5%E9%97%A8--%E8%AF%A6%E8%A7%A3%E7%89%88%2F</url>
    <content type="text"><![CDATA[0.学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 1. 了解SpringBoot在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.3.SpringBoot的特点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 2.1.创建工程我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： 2.2.添加依赖前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 2.2.1.添加父工程坐标12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 2.2.2.添加web启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.2.3.管理jdk版本默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 2.2.4.完整pom123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.启动类Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 2.4.编写controller接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 2.5.启动测试接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： 1）监听的端口是8080 2）SpringMVC的映射路径是：/ 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ 3.Java配置在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt; 现在该怎么做呢？ 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @value：属性注入 @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 创建一个jdbc.properties文件，编写jdbc属性： 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 然后编写代码： 1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明我们JdbcConfig是一个配置类 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： 1234567891011@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("hello") public String hello() &#123; return "hello, spring boot!" + dataSource; &#125;&#125; 然后Debug运行并查看： 属性注入成功了！ 3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： 123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： 1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123; @Bean public DataSource dataSource(JdbcProperties jdbc) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; &#125;&#125; 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式注入JdbcProperties： @Autowired注入 12@Autowiredprivate JdbcProperties prop; 构造函数注入 1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop)&#123; this.prop = prop;&#125; 声明有@Bean的方法参数注入 1234@Beanpublic Datasource dataSource(JdbcProperties prop)&#123; // ...&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 ​ 3.4、更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfig &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 4.自动配置原理使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： 注解：@SpringBootApplication run方法：SpringApplication.run() 我们分别来研究这两个部分。 4.1.了解@SpringBootApplication点击进入，查看源码： 这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 4.1.1.@SpringBootConfiguration我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 4.1.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明： The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly. 简单翻译以下： 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 4.1.3.@ComponentScan我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 4.2.默认配置原理4.2.1默认配置类通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是在哪里定义的呢？ 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 4.2.2.默认配置属性另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 4.3.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 5.SpringBoot实践接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 5.1.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 5.1.1.修改端口查看SpringBoot的全局属性可知，端口通过以下方式配置： 12# 映射端口server.port=80 重启服务后测试： 5.1.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 5.1.3.添加拦截器拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 首先我们定义一个拦截器： 12345678910111213141516171819public class LoginInterceptor implements HandlerInterceptor &#123; private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.debug("preHandle method is now running!"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.debug("postHandle method is now running!"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.debug("afterCompletion method is now running!"); &#125;&#125; 然后，我们定义配置类，注册拦截器： 123456789101112131415161718192021@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123; /** * 通过@Bean注解，将我们定义的拦截器注册到Spring容器 * @return */ @Bean public LoginInterceptor loginInterceptor()&#123; return new LoginInterceptor(); &#125; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 registry.addInterceptor(this.loginInterceptor()).addPathPatterns("/**"); &#125;&#125; 结构如下： 接下来运行并查看日志： 你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 12# 设置com.leyou包的日志级别为debuglogging.level.com.leyou=debug 再次运行查看： 1232018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : afterCompletion method is now running! 5.2.整合jdbc和事务spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： 1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 5.3.整合连接池其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=123# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 5.4.整合mybatis5.4.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的： 1234# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; 5.4.2.通用mapper通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 不需要做任何配置就可以使用了。 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 5.5.启动测试将controller进行简单改造： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private UserService userService; @GetMapping("/hello") public User hello() &#123; User user = this.userService.queryById(8L); return user; &#125;&#125; 我们启动项目，查看： 6.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 6.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 6.2.编写接口编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染 123456789@GetMapping("/all")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute("users", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return "users";&#125; 6.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 6.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center"&gt; &lt;span style="color: darkslategray; font-size: 30px"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class="list"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;1&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;张三&lt;/td&gt; &lt;td th:text="$&#123;user.userName&#125;"&gt;zhangsan&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;20&lt;/td&gt; &lt;td th:text="$&#123;user.sex&#125; == 1 ? '男': '女'"&gt;男&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"&gt;1980-02-30&lt;/td&gt; &lt;td th:text="$&#123;user.note&#125;"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 6.5.测试接下来，我们打开页面测试一下： 6.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： ​ 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 ​ eclipse中没有测试过。 我们可以修改页面，测试一下。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题1.厄拉多塞筛法求质数]]></title>
    <url>%2F2019%2F06%2F29%2F%E7%AE%97%E6%B3%95%E9%A2%981.%E5%8E%84%E6%8B%89%E5%A4%9A%E5%A1%9E%E7%AD%9B%E6%B3%95%E6%B1%82%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[厄拉多塞筛法求质数0~N 范围内 如果 此数为质数 则其倍数一定不是质数 12345678910111213141516171819202122232425 public int countPrimes(int n) &#123; // 创建一个范围内数组 0是质数 1不是质数 int[] a=new int[n];// 前两个数 0 1 不需要计算从2 开始 for(int i=2;i&lt;n;i++)&#123; // 循环如果他是质数 则它的倍数都不是质数 if(a[i]==0)&#123; for(int j=2;j*i&lt;n;j++)&#123; a[j*i]=1; &#125; &#125; &#125; // 获取数组中是质数的标记 int c=0; for(int i=2;i&lt;n;i++)&#123; if(a[i]==0)&#123; c++; &#125; &#125; return c; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 1.内存模型 对象创建过程 垃圾回收机制]]></title>
    <url>%2F2019%2F06%2F29%2FJVM-1.%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[笔记整理节选了《深入理解Java虚拟机》和 JavaGuide 部分内容 侵删 Java 内存区域Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同 ** JDK 1.8之前 *： * JDK 1.8之后 **： 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。** 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。** 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 ** 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。** Java 虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。） 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 ** Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。** StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 那么方法/函数如何调用Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。 Java方法有两种返回方式： return 语句。抛出异常。不管哪种返回方式都会导致栈帧被弹出。 本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native (调用其他语言) 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。 堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组在这里分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 方法区方法区与 Java 堆一样，是各个** 线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆），目的应该是与 Java 堆区分开来。 方法区也被称为永久代。 方法区和永生代关系《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。 运行时常量池运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 ** JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。** 直接内存** 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。** JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 Java对象的创建过程 类加载检查虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有** “指针碰撞” 和 “空闲列表”** 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。** 内存分配的两种方式：（补充内容，需要掌握）** 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的** 内存分配并发问题（补充内容，需要掌握）** 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： TLAB： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用下述的CAS进行内存分配 ** CAS+失败重试 ： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 设置对象头初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行 init 方法 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;init&gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书-图解HTTP-1.了解web及网络基础]]></title>
    <url>%2F2019%2F06%2F24%2F%E8%AF%BB%E4%B9%A6-%E5%9B%BE%E8%A7%A3HTTP-1.%E4%BA%86%E8%A7%A3web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[TCP/IP协议层分为4层 应用层决定向用户提供应用服务时通信活动 (http协议输入该层) 传输层提供处于网络连接时两台计算机之间的数据传输TCP/UDP 请求协议在此层 端口号在此层 网络层用来处理网络上流动的数据包（设定路线传输到对方计算机）需要本机IP和服务器(客户端)IPIP协议：IP协议的作用是把各种数据包传送给对方，为了保证传送正确 需要在数据中携带IP地址和MAC地址 IP地址：节点地址 可变 MAC地址：网卡地址 固定 链路层用于处理连接硬件部分 驱动 网卡 以太网地址硬件上的范畴都在链路层范围 TCP/IP通信传输流发送端从应用层往下走，接收端从链路层往上走应用层提供路径，有传输层包装携带端口号(UDP或TCP)协议请求信息，在网络层进行包装本机IP和接收端IP MAC地址 最后由链路层处理发送到接收端 接收端通过接收到得数据 在链路层从下到上进行拆解获取信息 就完成了一次请求发送端每层要打包首部信息接收端每层拆解首部信息 传输机制路由原则机制 在网络中传播 将通过路由器多次中转，传递到接收端 可靠的TCP协议 TCP协议位于传输层，提供可靠的字节流服务为了方便传输将大块数据分割成以报文段为单位的数据包进行管理 TCP协议采用三次握手策略，即发送端首先发送一个带有SYN标志的数据包给对方，接收端收到后返回一个带有SYN/ACK数据包以传达确认信息，最后发送端再回传一个带有ACK标志的数据包 表示握手结束若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包DNS服务提供从域名到IP地址之间的解析服务将域名通过DNS服务获取反馈到的IP地址值进行访问URL URIURI统一资源标识符URL统一资源定位符URI用字符串标识某一互联网资源 而URL表示资源地点则URL是URI子集]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring 10. Spring Security]]></title>
    <url>%2F2019%2F06%2F18%2FSpring-10.-Spring-Security%2F</url>
    <content type="text"><![CDATA[Spring Security概述Spring Security 是 Spring 项目组中用来提供安全认证服务的框架 “认证”，是为用户建立一个他所声明的主体。主题一般式指用户，设备或可以在你系 统中执行动作的其他系统。 “授权”指的是一个用户能否在你的应用中执行某个操作，在到达授权判断之前，身份的主题已经由 身份验证过程建立了。登录配置Maven1234567891011121314151617181920 &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; web.xml123456789101112131415 &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; spring-security.xml （数据库中配置用户名密码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:s="http://www.springframework.org/schema/security" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt;&lt;!-- 开启jsr250权限控制--&gt; &lt;security:global-method-security jsr250-annotations="enabled"&gt;&lt;/security:global-method-security&gt; &lt;!-- 配置不拦截的资源 --&gt; &lt;security:http pattern="/login.jsp" security="none"/&gt; &lt;security:http pattern="/failer.jsp" security="none"/&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式（没学习过） --&gt; &lt;security:http auto-config="true" use-expressions="false"&gt; &lt;!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" --&gt; &lt;security:intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN,ROLE_STAFF"/&gt; &lt;!-- 定义跳转的具体的页面 login-page 登录界面 login-processing-url 访问路径 authentication-success-forward-url 成功界面 authentication-failure-url 失败界面 username-parameter 用户名 来源于网页 password-parameter 密码 来源于网页 --&gt; &lt;security:form-login login-page="/login.jsp" login-processing-url="/login" authentication-success-forward-url="/main.jsp" authentication-failure-url="/failer.jsp" /&gt; &lt;!-- 关闭跨域请求 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout" logout-success-url="/login.jsp" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt;&lt;!-- 配置关联的实现类--&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- &amp;lt;!&amp;ndash; 配置加密的方式 &amp;ndash;&amp;gt; &lt;security:password-encoder ref="passwordEncoder"/&gt;--&gt;&lt;!-- 以此方法进行解密--&gt; &lt;security:password-encoder ref="passwordEncoder"/&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密类 --&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- 在内存中存入用户名和密码 &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name="admin" password="&#123;noop&#125;admin" authorities="ROLE_USER"/&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; --&gt;&lt;/beans&gt; service创建接口继承UserDetailsService123456789101112131415161718192021222324252627282930313233343536373839** * 继承UserDetailsService接口 * 创建实现类完成方法实现 */public interface UserService extends UserDetailsService &#123; /** * 查询所有用户 * @return * @param page * @param pageSize */ List&lt;UserInfo&gt; findAll(int page, int pageSize); /** * 储存用户 * @param info */ void saveOne(UserInfo info); /** * 根据id查询用户详情 * @return */ UserInfo findById(String id); /** * 查询该用户没有的角色 * @param id * @return */ List&lt;Role&gt; findOtherRolesById(String id); /** * 保存新角色 * @param userId * @param ids */ void addRoleToUser(String userId, String[] ids);&#125; 实现类返回其实现类 User 123456789public class User implements UserDetails, CredentialsContainer &#123;private String password;private final String username;private final Set&lt;GrantedAuthority&gt; authorities;private final boolean accountNonExpired; //帐户是否过期private final boolean accountNonLocked; //帐户是否锁定private final boolean credentialsNonExpired; //认证是否过期private final boolean enabled; //帐户是否可用｝ 1234public class UserServiceImpl implements UserService &#123; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;&#125; &#125; user中需要传入一个 GrantedAuthority集合 来返回给spring-security.xml角色信息，判断是否是ROLE_USER,ROLE_ADMIN 使用实现类SimpleGrantedAuthority完成 该类中的 private final String role; 即我们将数据库获取出的角色信息放在每一个SimpleGrantedAuthority实例中传递给集合即可 1234567891011121314151617@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserInfo info = dao.findByUserName(username); List&lt;Role&gt; roleList = info.getRoles(); List&lt;SimpleGrantedAuthority&gt; authorityList=setAuthority(roleList); return new User(info.getUserName(),info.getPassWord(), info.getStatus()==1, true,true,true,authorityList); &#125; private List&lt;SimpleGrantedAuthority&gt; setAuthority(List&lt;Role&gt; roleList) &#123; List&lt;SimpleGrantedAuthority&gt; authoritys = new ArrayList&lt;SimpleGrantedAuthority&gt;(); for (Role role : roleList) &#123; authoritys.add(new SimpleGrantedAuthority("ROLE_"+role.getRoleName())); &#125; return authoritys; &#125; 密码加密工具类 12345678 public class PassWordUtils &#123; public static void main(String[] args) &#123; PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String ssm = passwordEncoder.encode("ssm"); System.out.println(ssm); &#125;&#125; 权限控制jsr250配置12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt; 1.0&lt;/version&gt;&lt;/dependency&gt; spring-security.xml12&lt;!-- 开启jsr250权限控制--&gt; &lt;security:global-method-security jsr250-annotations="enabled"&gt;&lt;/security:global-method-security&gt; springmvc.xml1&lt;aop:aspectj-autoproxy proxy-target-class="true"&gt;&lt;/aop:aspectj-autoproxy&gt; 使用方法 @RolesAllowed({&quot;ADMIN&quot;,&quot;USER&quot;}) 在每个controller方法上添加&lt;security:intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER,ROLE_ADMIN&quot; /&gt; 设定的角色访问被该注解修饰的方法]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网面试错题集 2]]></title>
    <url>%2F2019%2F06%2F17%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E8%AF%95%E9%94%99%E9%A2%98%E9%9B%86-2%2F</url>
    <content type="text"><![CDATA[Java编译java MyTest a b cjava后跟类名 后跟arg[ ]数组参数 包 包是类的容器，用于分隔类名空间。java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。 定义在同一个包（package）内的类可以不经过import而直接相互使用。 面向对象三大特性继承封装多态java c++所有使用面向对象思想的语言通用 数据库执行语句db.executeUpdate(sql); 用于执行sql语句用于返回查询结果是错误的如果是查询返回 也可以执行不返回任何内容的sql语句 集合collection 分为set list collection与Map是同级的ArrayList 查询快 增删慢LinkedList查询慢 增删快Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口Hashtable 是一个散列表，Hashtable 类则继承Dictionary，实现Map接口 1.普通for循环：可以删除 注意每次删除之后索引要–2.Iterator遍历：可以删除 不过要使用Iterator类中的remove方法，如果用List中的remove方法会报错3.增强for循环foreach：不能删除 强制用List中的remove方法会报错 collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据。jdk1.5版本以前不能传入基本类型jdk1.5版本以后可以 会自动装箱 1234567public static void main(String args[]) &#123; List Listlist1 = new ArrayList(); Listlist1.add(0); List Listlist2 = Listlist1; System.out.println(Listlist1.get(0) instanceof Integer); System.out.println(Listlist2.get(0) instanceof Integer);&#125; 结果为 true ConcurrentHashMap 使用的分段加锁机制Arrays.asList方法返回 这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！ ClassLoaderJDK中提供了三个ClassLoader，根据层级从高到低为： Bootstrap ClassLoader，主要加载JVM自身工作需要的类。 Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。 Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器 JVM加载类的实现方式，我们称为 双亲委托模型： 得到类加载请求，自己不会加载，让其父类加载器加载，直到反馈到Bootstrop ClassLoader 如果父类加载器反馈了无法加载，子类才会尝试加载 双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。 假设有一个开发者自己编写了一个名为Java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它 垃圾回收器java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。** 方法使用完 是 弹栈 不走垃圾回收器 弹栈完成内存回收 ** 并发编程同步器 Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。 CountDownLatch直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 泛型 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;,List&lt;B&gt;,List&lt;Object&gt; 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范，&lt;?&gt;代表全部范围 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值 List&lt;?&gt;和List 是相等的，都代表最大范围 List既是点也是范围，当表示范围时，表示最大范围1234567891011121314151617public static void main(String[] args) &#123; List&lt;A&gt; a; List list; list = a; //A对，因为List就是List&lt;?&gt;，代表最大的范围，A只是其中的一个点，肯定被包含在内 List&lt;B&gt; b; a = b; //B错，点之间不能相互赋值 List&lt;?&gt; qm; List&lt;Object&gt; o; qm = o; //C对，List&lt;?&gt;代表最大的范围，List&lt;Object&gt;只是一个点，肯定被包含在内 List&lt;D&gt; d; List&lt;? extends B&gt; downB; downB = d; //D对，List&lt;? extends B&gt;代表小于等于B的范围，List&lt;D&gt;是一个点，在其中 List&lt;?extends A&gt; downA; a = downA; //E错，范围不能赋值给点 a = o; //F错，List&lt;Object&gt;只是一个点 downA = downB; //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛 &#125; MathMath.ceil(d1)如果参数小于0且大于-1.0，结果为 -0.0 12double d1=-0.5;System.out.println("Ceil d1="+Math.ceil(d1)); 结果为-0.0 构造器 子类不能继承父类构造函数 但可以显示调用父类构造函数 在其他构造器中调用上方已有构造器的方法this(参数) 关系数据模型和对象数据模型之间对应关系表对应类记录对应对象表的字段对应类的属性 赋值符号没有&lt;&lt;&lt; 只有&gt;&gt;&gt; 无符号右移 字符串转码将ISO8859-1字符串转成GB2312编码new String(&quot;需要转换的字符串&quot;.getBytes(&quot;ISO8859- 1&quot;),&quot;GB2312&quot;) 局部变量1234public static void main(String[] args)&#123; String s; System.out.println("s="+s);&#125; 局部变量没有默认值编译会失败ze 运算符优先级&gt;，&lt;，&amp;&amp;，|| 多态编译期看左面 运行时看右面 12345678910111213141516171819202122232425262728class Base&#123; public void method() &#123; System.out.println("Base"); &#125; &#125;class Son extends Base&#123; public void method() &#123; System.out.println("Son"); &#125; public void methodB() &#123; System.out.println("SonB"); &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Base base = new Son(); base.method(); base.methodB(); &#125;&#125; 编译期无法通过 因为编译期认为 Base base = new Son();是base对象 base中没有methodB();方法，所以编译期无法通过 成员变量和静态方法：编译期和运行期都看左面 即父类或者父类接口方法：编译器看左面运行期看右面调用子类特有的方法(父类没有 子类有的) 不能使用多态 ASCII码空格的ASCII码值为320–48 A–65 a–97 修饰符访问权限default 不能修饰变量 Sevlet 体系结构 System.out.println()System是java.lang中的一个类out是System内的一个成员变量 这个变量是一个java.io.PrintStream类的对象println是一个方法 余弦值计算正确计算42度（角度）的余弦值double d=Math.cos（Math.toRadians（42））将角度转换为弧度计算 web ServiceWebservice是跨平台，跨语言的远程调用技术它的通信机制实质就是xml数据交换Webservice采用了soap协议（简单对象协议）进行通信WSDL是用于描述 Web Services 以及如何对它们进行访问 变量命名规范不能以数字做首写首写字母可以为下划线不能与&amp;相组合来命名不能以关键字命名 Json属性值 必须以引号包括 {&quot;company&quot;:{&quot;name&quot;:4399}}json对象必须由一组有序的键值对组成。 Servlet包常用的servlet包的名称javax.servletjavax.servlet.http ResultSet第一列索引从1开始 内存回收算法复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象 Serial New收集器是针对新生代的收集器，采用的是复制算法Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理Parallel Old（并行）收集器，针对老年代，标记整理CMS收集器，基于标记清理G1收集器：整体上是基于标记 整理 ，局部采用复制 年轻代一般情况下都是用复制算法 老年代采用标记整理算法 full GC触发的条件老年代满System.gc持久带满 thisthis不能在 static方法中使用 所以main方法不能用 MVCModel（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 包装类同类型的进行比较，如Integer 与int，Long与long进行==比较时，会自动拆箱不同类型之间进行比较，如果有一方为非包装类，则会自动拆箱如果两方都为包装类，则不会拆箱，且不能比较，编译会报错 包装类初始默认值为null IntegerintValue()是把Integer对象类型变成int的基础数据类型；parseInt()是把String 变成int的基础数据类型；Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。） 123456789101112public class a &#123; public static void main(String[] args) &#123; Integer i01 = 59; int i02 = 59; Integer i03 =Integer.valueOf(59); Integer i04 = new Integer(59); System.out.println(i01==i04); System.out.println(i01==i03); System.out.println(i02==i04); System.out.println(i03==i04); &#125;&#125; JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象所以前三个同一个对象 第四个单独新对象第一个为false指向不同对象第二个为true 指向同一个对象第三个为true因为i02是基本类型 所以==比较的是数值 i04自动拆箱第四个为false new是新创建的对象 Integer 对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。i1和i2为128，超出范围，所以都需要新建对象，对象比较为false；i5和i6为100，在范围之内，在执行Integer i5=100时，就会直接缓存到内存中，但执行执行Integer i6=100时，就直接从缓存里取，而不需要新建对象，所以为true。 Lambda 表达式 形参列表形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。 箭头（→）必须通过英文中画线和大于符号组成。 代码块如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。 ~n公式-n=n+1可推出n=-n-1，所以~10=-11再加5结果为-6 nullnull 代表的是不确定的对象 为什么先调用 hashCode 再调用equals 因为equals效率低 即使equals相等 hashCode一定相等 管道 进程对管道进行读操作和写操作都可能被阻塞 （因为管道为空，读操作会被阻塞；管道满了，写操作会被阻塞） 可以有多个进程对其读；也可以有多个进程写，只不过不能同时写。 匿名管道只能单向；命名管道可以双向；所以C过于绝对 管道是内存中的 反射Method[] getDeclaredMethods()返回Class对象表示的类或接口的所有已声明的方法数组，但是不包括从父类继承和接口实现的方法。 Method[] getMethods() 返回当前 Class对象表示的类或接口的所有公有成员方法对象数组，** 包括已声明的和从父类继承或实现接口的方法。**]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 7. PageHelper分页]]></title>
    <url>%2F2019%2F06%2F16%2FMybatis-7.-PageHelper%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[PageHelper介绍PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本主流与常用的数据库，例如mysql、oracle、mariaDB、DB2、SQLite、Hsqldb等。本项目在 github 的项目地址：https://github.com/pagehelper/Mybatis-PageHelper本项目在 gitosc 的项目地址：http://git.oschina.net/free/Mybatis_PageHelper PageHelper使用引入分页插件有下面2种方式，推荐使用 Maven 方式。 Jar包可以从下面的地址中下载最新版本的 jar 包https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/由于使用了sql 解析工具，你还需要下载 jsqlparser.jar：http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/ Maven12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 配置Mybatis中配置拦截器插件 123456789101112131415 &lt;!--plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:properties?, settings?,typeAliases?, typeHandlers?,objectFactory?,objectWrapperFactory?,plugins?,environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="param1" value="value1"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 在 Spring 配置文件中配置拦截器插件12345678910111213141516171819&lt;!-- 配制SqlSessionFacatory--&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 传入PageHelper的插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;!-- 传入插件的对象 --&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="helperDialect"&gt;oracle&lt;/prop&gt; &lt;prop key="reasonable"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 插件功能介绍 helperDialect ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver2012 , derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012 ，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect ，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero ：默认值为 false ，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit =0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable ：分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum&lt;=0 时会查询第一页， pageNum&gt;pages （超过总数时），会查询最后一页。默认 false 时，直接根据参数进行查询。 *params *：为了支持 startPage(Object params) 方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable ，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero supportMethodsArguments ：支持通过 Mapper 接口参数来传递分页参数，默认值 false ，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和ArgumentsObjTest 。 ** autoRuntimeDialect** ：默认值为 false 。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择 sqlserver2012 ，只能使用 sqlserver ），用法和注意事项参考下面的场景五。 closeConn ：默认值为 true 。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认 true 关闭，设置为false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 功能演示分页查询功能紧贴查询方法 1234567 @Override public List&lt;Orders&gt; findAll(int page,int pageSize) &#123;// 分页查询 PageHelper.startPage(page,pageSize); return dao.findAll(); &#125; 1234567891011 @RequestMapping("/findAll") public ModelAndView findAll(@RequestParam(name = "page",required = true,defaultValue = "1")int page, @RequestParam(name = "pageSize",required = true,defaultValue = "4")int pageSize)&#123; ModelAndView view = new ModelAndView(); List&lt;Orders&gt; ordersList = service.findAll(page,pageSize);// 将集合封装到PageInfo中 PageInfo&lt;Orders&gt; pageInfo=new PageInfo&lt;&gt;(ordersList); view.addObject("pageInfo",pageInfo); view.setViewName("orders-list"); return view; &#125; 123456789101112131415161718192021222324252627282930313233343536&lt;c:forEach items="$&#123;pageInfo.list&#125;" var="orders"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;$&#123;orders.id &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.orderNum &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.product.productName &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.product.productPrice &#125;&lt;/td&gt; &lt;td&gt;$&#123;orders.orderTimeStr &#125;&lt;/td&gt; &lt;td class="text-center"&gt;$&#123;orders.orderStatusStr &#125;&lt;/td&gt; &lt;td class="text-center"&gt; &lt;button type="button" class="btn bg-olive btn-xs"&gt;订单&lt;/button&gt; &lt;button type="button" class="btn bg-olive btn-xs" onclick="location.href='$&#123;pageContext.request.contextPath&#125;/orders/findById?id=$&#123;orders.id&#125;'"&gt;详情&lt;/button&gt; &lt;button type="button" class="btn bg-olive btn-xs"&gt;编辑&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;div class="box-tools pull-right"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=1&amp;pageSize=$&#123;pageInfo.pageSize&#125;" aria-label="Previous"&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageInfo.prePage&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;c:forEach begin="1" end="$&#123;pageInfo.pages&#125;" var="pageNum"&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;"&gt;$&#123;pageNum&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageInfo.nextPage&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/orders/findAll?page=$&#123;pageInfo.pages&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;" aria-label="Next"&gt;尾页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; PageInfo该类中包含基本功能中所有需要的属性 可以通过该属性在网页端配置翻页功能 功能部分节选 12345678910111213141516171819202122232425262728293031323334353637383940414243private static final long serialVersionUID = 1L; //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中"显示startRow到endRow 共size条数据" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集 private List&lt;T&gt; list; //前一页 private int prePage; //下一页 private int nextPage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //所有导航页号 private int[] navigatepageNums; //导航条上的第一页 private int navigateFirstPage; //导航条上的最后一页 private int navigateLastPage;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo框架下完成的博客]]></title>
    <url>%2F2019%2F06%2F13%2Ftitle_%20Hexo%E6%A1%86%E6%9E%B6%E4%B8%8B%E5%AE%8C%E6%88%90%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天完成了Hexo框架下的博客 并且成功部署到Github上运行成功 以后会慢慢把笔记搬运过来 如果需要Java web Java SE jdbc的基础知识请移步到我的简书]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 2.Mybatis CRUD操作]]></title>
    <url>%2F2019%2F06%2F13%2FMybatis-2.Mybatis-CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Mybatis CRUD操作 注意 所有时间除查询以外都要手动提交事务sqlSession.commit();（因为sqlsession执行通过代理创建对象实现类 所以事务也在这一步进行） 在sql语句只有一个参数情况下例如delete form user where id= #{i}占位符里面的内容随便写 多个不允许 建议domain里面是什么就写什么 模糊查询时 要在提供字符串时添加百分号 String name =&quot;%王%&quot; #{}和${} 区别在于 第一种为PreparedStatement事务处理方式 而第二种为Statement 插入数据以后可以通过select last_insert_id();查询当刚生成的数据的id数(自增长情况下) 并且使用 保存方法以后 user中会赋予id值，而不进行此操作没有 由多个对象组成查询条件进行实际查询 创建QueryVo对象 封装User1234567891011121314/** * 封装对象的类 */public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; UserDao.xml 123&lt;select id="findByVo" parameterType="it.test.domain.QueryVo" resultType="it.test.domain.User"&gt; select * from user where username like #&#123;user.username&#125;&lt;/select&gt; Test类 1234567891011 @Testpublic void findByVo() &#123; QueryVo queryVo = new QueryVo(); User user = new User(); user.setUsername("%王%"); queryVo.setUser(user); List&lt;User&gt; userList = dao.findByVo(queryVo); for (User u : userList) &#123; System.out.println(u); &#125;&#125; 当出现类属性与数据库字段对应不一致(select)12345678910&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="it.test.dao.UserDao"&gt; &lt;resultMap id="userMap" type="it.test.domain.User"&gt;&lt;!-- 主键对应字段 property为java类属性 column为sql对应字段--&gt; &lt;id property="uid" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;/resultMap&gt; 通过这种方法声明java类属性与sql字段对应并在执行语句中resultMap 赋值成id名称 `userMap 完成的Mybatis文件操作过程1 主配置文件 resources下SqlMapConfig.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--主配置文件--&gt;&lt;configuration&gt;&lt;!-- 配置环境--&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;&lt;!-- 注解配置--&gt; &lt;mapper class="it.test.dao.UserDao"&gt;&lt;/mapper&gt;&lt;!-- xml配置--&gt; &lt;mapper resource="it/test/dao/UserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1.1 如果调用xml配置 放在resources下与dao包路径名相同的UserDao.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="it.test.dao.UserDao"&gt; &lt;resultMap id="userMap" type="it.test.domain.User"&gt;&lt;!-- 主键对应字段 property为java类属性 column为sql对应字段--&gt; &lt;id property="uid" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;/resultMap&gt;&lt;!-- 传入参数类型 反射相应的属性 sql语句的参数类型及传入参数类型--&gt; &lt;insert id="saveUser" parameterType="it.test.domain.User"&gt;&lt;!--配置插入操作后 获取插入数据的idkeyColumn数据库中的值 keyProperty实体类属性名 resultType数据类型 order操作执行后运行 --&gt;&lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id();&lt;/selectKey&gt; insert into user (username,address,sex,birthday)values (#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;update id="updateUser" parameterType="it.test.domain.User"&gt; update user set username=#&#123;username&#125;,sex=#&#123;sex&#125; where id=#&#123;id&#125;; &lt;/update&gt; &lt;delete id="deleteUser" parameterType="int"&gt; delete from user where id=#&#123;id&#125;; &lt;/delete&gt; &lt;select id="findById" parameterType="int" resultType="it.test.domain.User"&gt; select * from USER where id =#&#123;uid&#125;; &lt;/select&gt; &lt;!--使用注解开发 --&gt; &lt;!-- &lt;select id="findByName" parameterType="string" resultType="it.test.domain.User"&gt; select * from user where username like #&#123;username&#125;; &lt;/select&gt;--&gt; &lt;select id="findByVo" parameterType="it.test.domain.QueryVo" resultType="it.test.domain.User"&gt; select * from user where username like #&#123;user.username&#125; &lt;/select&gt;&lt;/mapper&gt; 2 User类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package it.test.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private int id; private String username; private String sex; private String address; private Date birthday; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", birthday=" + birthday + '&#125;'; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; 2.1 QueryVo类 12345678910111213141516package it.test.domain;/** * 封装对象的类 */public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 3 UserDao类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package it.test.dao;import it.test.domain.QueryVo;import it.test.domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao &#123; @Select("select* from user ") /** * 查询所有 */ List&lt;User&gt; findAll(); /** * 添加用户 * @param user */ void saveUser(User user); /** * 更新用户 * @param user */ void updateUser(User user); /** * 删除用户 * @param id */ void deleteUser(int id); /** * 通过id查询 * @param id * @return */ User findById(int id); /** * 通过名称模糊查询 * @param name * @return */ @Select(" select * from user where username like #&#123;username&#125;") List&lt;User&gt; findByName(String name); /** * 封装多个实体类组合查询 * @param v * @return */ List&lt;User&gt; findByVo(QueryVo v);&#125; Test类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package it.test.dao;import it.test.domain.QueryVo;import it.test.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class FindTest &#123; InputStream in = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory build = null; SqlSession sqlSession = null; UserDao dao = null; @Before //方法运行前执行 public void init() throws IOException &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml");// 通过SqlSessionFactoryBuilder构建工厂 builder = new SqlSessionFactoryBuilder(); build = builder.build(in);// 通过工厂生产SqlSession对象 功能：动态代理生成实现类 sqlSession = build.openSession(); dao = sqlSession.getMapper(UserDao.class); &#125; @After public void close() throws IOException &#123;// 提交事务 不提交会自动回滚 sqlSession.commit(); in.close(); sqlSession.close(); &#125; @Test /** * 注解配置 */ public void finAll() &#123; List&lt;User&gt; list = dao.findAll(); for (User user : list) &#123; System.out.println(user); &#125; &#125; @Test/** *xml配置 */ public void saveUser() throws IOException &#123; User user = new User(); user.setUsername("于松江"); user.setSex("男"); user.setAddress("吉林省长春市"); user.setBirthday(new Date()); System.out.println("保存以前：" + user); dao.saveUser(user); System.out.println("保存以后：" + user); &#125; /** * 更新操作 * * @throws IOException */ @Test public void updateUser() throws IOException &#123; User user = new User(); user.setUsername("程泽琪"); user.setSex("女"); user.setId(50); dao.updateUser(user); &#125; @Test public void deleteUser() throws IOException &#123; dao.deleteUser(50); &#125; @Test public void findById() throws IOException &#123; User user = dao.findById(48); System.out.println(user.toString()); &#125; @Test public void findByName() &#123; List&lt;User&gt; userList = dao.findByName("%王%"); for (User user : userList) &#123; System.out.println(user); &#125; &#125; @Test public void findByVo() &#123; QueryVo queryVo = new QueryVo(); User user = new User(); user.setUsername("%王%"); queryVo.setUser(user); List&lt;User&gt; userList = dao.findByVo(queryVo); for (User u : userList) &#123; System.out.println(u); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 1.自定义Mybatis框架基本功能]]></title>
    <url>%2F2019%2F06%2F13%2FMybatis-1.%E8%87%AA%E5%AE%9A%E4%B9%89Mybatis%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Mybatis框架的基本使用流程 1234567891011121314151617// 1.创建连接获取配置文件 InputStream in= Resources.getResourceAsStream("sqlMapConfig.xml");// 2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory sessionFactory=builder.build(in);// 3.使用工厂生产SqlSession对象 SqlSession session = sessionFactory.openSession();// 4.使用对象创建Dao接口的代理对象 UserDao dao = session.getMapper(UserDao.class);// 5.使用代理对象执行方法 List&lt;User&gt; users = dao.findAll(); for (User user : users) &#123; System.out.println(user); &#125;// 6.关闭资源 session.close(); in.close(); 其中 创建SqlSessionFactory对象为创造者模式 创建 SqlSession对象为工厂模式 创建UserDao为代理模式 自定义Mybatis准备 public class Resources public class SqlSessionFactoryBuilder public interface SqlSessionFactory public interface SqlSession]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 本地博客转移]]></title>
    <url>%2F2019%2F06%2F07%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo 换电脑 复制博客路径下的如下文件 12345_config.yml package.json scaffolds/ source/ themes/ 新电脑安装Git Node.js 安装Hexo 1npm install hexo-cli -g 将Hexo创建出来到 123hexo init blog进入文件夹npm install 创建Git部署模块 1npm install hexo-deployer-git --save 创建搜索模块 1npm install hexo-generator-searchdb --save hexo clean g d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客网面试错题集 1]]></title>
    <url>%2F2019%2F05%2F31%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E8%AF%95%E9%94%99%E9%A2%98%E9%9B%86-1%2F</url>
    <content type="text"><![CDATA[面向对象的五大基本原则（抽象类原则不是） 单一职责原则（SRP） 开放封闭原则（OCP） 里氏替换原则（LSP） 依赖倒置原则（DIP） 接口隔离原则（ISP） Java语言特性Java致力于检查程序在编译和运行时的错误。Java虚拟机实现了跨平台接口类型检查帮助检查出许多开发早期出现的错误。Java自己操纵内存减少了内存出错的可能性。Java还实现了真数组，避免了覆盖数据的可能。 程序设计语言中，数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，这样的数组称之为“真数组”。实现了真数组为Java语言健壮性的特点之一。 程序运行顺序静态优先 父类优先 类的初始化顺序是： 1、初始化父类中的静态成员变量和静态代码块。 2、初始化子类中的静态成员变量和静态代码块。 3、初始化父类中的普通成员变量和代码块，再执行父类中的构造方法。 4、初始化子类中的普通成员变量和代码块，在执行子类中的构造方法。 ** 默认调用父类空参数构造函数 如果在子类构造函数声明 则不会调用空参数构造函数，调用有参数。 ** 这就是为什么super()写在第一行 静态方法也算静态代码块 如果两个相同等级 则按顺序执行 单例模式基本要点 构造函数私有 唯一实例*静态工厂方法每次产出一个新的实例 * volatile关键字一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。而对该变量的修改，volatile并不提供原子性的保证。** 仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， volatile不能保证复合操作的原子性 ** volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况多线程下计数器必须使用锁保护 volatile关键字用于限定变量只能从内存中读取 值一致保证变量安全但是他不能保证线程安全 Java表达式转型规则Java表达式转型规则由低到高转换：1、所有的byte,short,char型的值将被提升为int型；2、如果有一个操作数是long型，计算结果是long型；3、如果有一个操作数是float型，计算结果是float型；4、如果有一个操作数是double型，计算结果是double型；5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。 byte a1 = 2, a2 = 4, a3; short s = 16; a2 = s; a3 = a1 * a2; 3 4错误 char byte short参与运算会自动转换int需要强转 会在编译期报错如果被final修饰 为常量 可以进行赋值 123byte b1=1;final byte b2=2,b3=4;b1=b2+b3; switchcase中不加 break 终止 则会将下面的程序都运行 多线程线程通过使用synchronized关键字可获得对象的互斥锁定线程调度算法是平台独立的线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度多线程使用异常来使线程停止 Callable类的call()方法可以返回值和抛出异常CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程 调用run() 方法不能启动线程 只是普通方法 join()join()的作用是：** “等待该线程终止” ，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。** join() wait() 都可以释放锁资源 共享数据的所有访问一定要作为临界区，用synchronized标识，这样保证了所有的对共享数据的操作都通过对象锁的机制进行控制。 如果一个类继承了某个类，只能使用Runnable实现线程也可以通过Callable接口实现 多线程wait() sleep() yield()java用监视器机制实现了进程之间的同步执行 yield是thread方法sleep是thread方法wait是object方法sleep终止不会释放线程锁wait会释放线程锁 ** wait()、notify()和notifyAll()是 Object类 中的方法 ** wait()、notify()和notifyAll()方法是本地方法，并且为final方法，无法被重写。 调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁） 调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程； 调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程； ** yield() ** 暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。 ** 为何这三个不是Thread类声明中的方法，而是Object类中声明的方法（当然由于Thread类继承了Object类，所以Thread也可以调用者三个方法）？** 由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。上面已经提到，如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）；notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。同样地，调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。nofityAll()方法能够唤醒所有正在等待该对象的monitor的线程，这一点与notify()方法是不同的。 ** Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。** Condition是个接口，基本的方法就是await()和signal()方法； Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll() 线程安全Vector相当于一个线程安全的ListHashMap是非线程安全的，其对应的线程安全类是HashTableArraylist是非线程安全的，其对应的线程安全类是VectorStringBuffer是线程安全的，相当于一个线程安全的StringBuilderProperties继承了HashTable接口，是线程安全的 ConcurrentHashMap是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同切线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。hastable是对整个代码块加锁，而concurrenthasmap是使用分片锁，粒度较小，不用对整个代码块加锁，提高了读写速率。 ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据 。适用于 读取远远大于写入的操作。 CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。 运行题1234567891011121314public class Example&#123; String str = new String("good"); char[ ] ch = &#123; 'a' , 'b' , 'c' &#125;; public static void main(String args[])&#123; Example ex = new Example(); ex.change(ex.str,ex.ch); System.out.print(ex.str + " and "); System.out.print(ex.ch); &#125; public void change(String str,char ch[ ])&#123; str = "test ok"; ch[0] = 'g'; &#125;&#125; string 是引用型变量 引用地址值 所以当局部变量str引用常量池中test ok 后弹栈 原 str地址值不变 想更改需要将原str进行指定 哪些类能被继承 Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader Thread可以被继承，用于创建新的线程 Number类可以被继承，Integer，Float，Double等都继承自Number类 ClassLoader可以被继承，用户可以自定义类加载器 JSPexception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。 errorPage的实质就是JSP的异常处理机制,发生异常时才会跳转到 errorPage指定的页面，没必要给errorPage再设置一个errorPage。所以当errorPage属性存在时， isErrorPage属性值为false为了使用exception对象 所以将 isErrorPage属性值为true &lt;% expression %&gt; JSP脚本(Scriptlet)，是Java代码块。&lt;%= expression %&gt; JSP表达式(expression)，表达式是一个有返回值的式子，它返回的结果将由out.print()进行输出。 application对象只创建一个 数组复制可以看到是native方法：native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。 可以将native方法比作Java程序同Ｃ程序的接口。 copyOf不是System的方法，而是Arrays的方法，可以看到本质上是调用的arraycopy方法。 重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。原则如下： 方法名一定要相同。 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。 如果参数个数不同，就不管它的参数类型了！ 如果参数个数相同，那么参数的类型或者参数的顺序必须不同。 方法的返回类型、修饰符可以相同，也可不同。编译一个以”.java”为后缀的源文件只能有一个与文件名相同的类，可以包含其他类 当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。 –《Java 编程思想》.class文件 生成多个 为内部类 一个源文件具有几个类和接口 javac编译后就有几个class文件 HashMap HashMap实际上是一个链表散列的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 HashMap的实例有俩个参数影响其性能：初始容量 和 装填因子 HashMap实现不同步，线程不安全。 HashTable线程安全 HashMap中的key-value都是存储在Entry中的 HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性 Hashtable 中， key 和 value 都不允许出现 null 值 HashMap是采用拉链法解决哈希冲突的 如图 SortedMap是接口 继承父类为私有变量 可以继承 但不能对其操作一个子类可以覆盖掉父类的同步方法 网络编程客户端Socket s = new Socket(“127.0.0.1”,6666);服务器 监听端口9000ServerSocket ss = new ServerSocket(6666); 客户端通过new Socket()方法创建通信的Socket对象服务器端通过new ServerSocket()创建TCP连接对象 accept()接纳客户端请求 接口与抽象类抽象方法没有方法体 抽象类特点:1.抽象类中可以构造方法2.抽象类中可以存在普通属性，方法，静态属性和方法。3.抽象类中可以存在抽象方法。4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。6.没有抽象方法的抽象类也不可以实例化 使用此特性创建工具类防止实例化 接口接口 去多继承接口 使用的的extends1.在接口中只有方法的声明，没有方法体。2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final3.在接口中的方法，永远都被public来修饰。4.接口中没有构造方法，也不能实例化接口的对象。5.接口可以实现多继承6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法7.则实现类定义为抽象类。 非抽象类实现接口后 两同两小一大原则：方法名相同，参数类型相同子类返回类型小于等于父类方法返回类型，子类抛出异常小于等于父类方法抛出异常，子类访问权限大于等于父类方法访问权限。 关于抽象类JDK 1.8以前，抽象类的方法默认访问权限为protectedJDK 1.8时，抽象类的方法默认访问权限变为default *关于接口JDK 1.8以前，接口中的方法必须是public的JDK 1.8时，接口中的方法可以是public的，也可以是default修饰的默认方法（如果实现类想要覆盖访问修饰符为public） static修饰的静态方法JDK 1.9时，接口中的方法可以是private的 * 声明的变量为 public static final 为全局常量其实现类可以调用** 接口中所有方法都是抽象方法 但抽象类中可以包含非抽象方法 ** 接口是特殊的抽象类为什么只能用public 修饰 （其前的abstract可以省略）因为接口可以被所有类实现 private不行既然被所有类实现 protected也不行static 修饰没有意义 因为变量是全局变量 方法没实现类 抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native、final访问修饰符修饰原因： private： 抽象方法要被实现 所以用private修饰就不能实现了 static：用static修饰 则可以通过接口调用 方法没有实现 调用没有意义 synchronized：该关键字修饰的方法被static修饰 则使用.class锁 修饰类方法使用this锁 抽象方法没有实体类对象 所以没this锁 修饰没用 锁应归其实现类所有 native ：本地方法 表示其底层用其他语言编写 交给本地执行 所以不行 Java关键字sizeof consestgoto synchronized 内部类静态内部类才可以声明静态方法静态方法不可以使用非静态变量抽象方法不可以有函数体 匿名内部类 ：因为匿名内部类没有名 所以没有办法定义构造器 数组String[] s=new String[10];默认初始化，基本类型是 0 ，布尔类型是 false ，引用类型为null所有 string[0]=null; float []f[] = new float[6][6]; 一种写法 Java内存区域off-heap 非堆内存 JVM进程管理的内存 类所包含的类型变量 实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型 final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象 基础数据类型 基本数据类型（或叫做原生类、内置类型）8种： 整数：byte，short，int，long（默认是int类型） 浮点类型： float，double（默认是double类型） 字符类型：char 布尔类型：boolean 引用数据类型3种：数组，类，接口 1 2 正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。 float 如果是小数时需要添加f 不会自动转化3 boolean类型不能和任何类型进行转换，会报出类型异常错误4 选项中，byte的取值范围是-128—127。报出异常 boolean 在 if语句中可以赋值 123boolean flag = false; if (flag = true) System.out.println("true"); else System.out.println("false"); 输出结果为true 基本数据类型 instanceof 对象类型 会编译不通过不会进行自动装箱低精度和高精度比较 会自动向上转换类型 Iterator支持从源集合中安全地删除对象，只需在** Iterator 上调用 remove()** 即可。这样做的好处是可以避免 ConcurrentModifiedException ，当打开 Iterator 迭代集合时，同时又在对集合进行修改。有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的remove() 方法是个安全的做法。 123for(int i=0;i&lt;list.size();i++)&#123; list.remove(...);&#125; 循环过程中list.size()的大小变化了就导致了错误。i在增加 list在减你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。 静态变量静态变量只能在类中定义 不能在方法中定义静态方法输入类 不属于方法 super.getClass().getName()返回包名+类名 Java语言默认字符集Unicode StringString对象不可变stringbuffer是可变的StringBuffer是线程安全StringBuilder是线程不安全 subString(a,b); 创建new String();截取从第几个开始，往后数b-a个 12String str =&quot;&quot;;System.out.print(str.split(&quot;,&quot;).length); 空字符串可以被分割 长度1 1String classFile = "com.jd.". replaceAll(".", "/") + "MyClass.class"; 由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成&quot;\\.&quot;.字符常量是单引号 字符串常量是双引号 WEB 会话技术当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 12345671）.隐藏表单域：&lt;input type=&quot;hidden&quot;&gt;，非常适合不需要大量数据存储的会话应用。2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话 getParameter()是获取POST/GET传递的参数值；getInitParameter获取Tomcat的server.xml中设置Context的初始化参数getAttribute()是获取对象容器中的数据值；getRequestDispatcher是请求转发。 参数传递一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。一个方法可以改变一个对象参数的状态。一个方法不能让对象参数引用一个新的对象。 enum 枚举123456789101112131415enum AccountType&#123; SAVING, FIXED, CURRENT; private AccountType() &#123; System.out.println(“It is a account type”); &#125;&#125;class EnumOne&#123; public static void main(String[]args) &#123; System.out.println(AccountType.FIXED); &#125;&#125; 因为枚举类里有三个实例 所以调用三次构造方法]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSM 3.管理系统项目知识点]]></title>
    <url>%2F2019%2F05%2F30%2FSSM-3.%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[创建数据库表1234567891011121314151617181920212223CREATE TABLE product(id varchar2(32) default SYS_GUID() PRIMARY KEY, -- 如果没给赋值 则会生成uuid唯一编码productNum VARCHAR2(50) NOT NULL,productName VARCHAR2(50),cityName VARCHAR2(50),DepartureTime timestamp,productPrice Number,productDesc VARCHAR2(500),productStatus INT,CONSTRAINT product UNIQUE (id, productNum))insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values ('676C5BD1D35E429A8C2E114939C5685A', 'itcast-002', '北京三日游', '北京', to_timestamp('10-10-2018 10:10:00.000000', 'dd-mm-yyyy hh24:mi:ss.ff'), 1200, '不错的旅行', 1);insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values ('12B7ABF2A4C544568B0A7C69F36BF8B7', 'itcast-003', '上海五日游', '上海', to_timestamp('25-04-2018 14:30:00.000000', 'dd-mm-yyyy hh24:mi:ss.ff'), 1800, '魔都我来了', 0);insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values ('9F71F01CB448476DAFB309AA6DF9497F', 'itcast-001', '北京三日游', '北京', to_timestamp('10-10-2018 10:10:00.000000', 'dd-mm-yyyy hh24:mi:ss.ff'), 1200, '不错的旅行', 1); spring通过.properties连接数据库1234567&lt;context:property-placeholder location="classpath:druid.properties"&gt;&lt;/context:property-placeholder&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 页面跳转saveOne 跳转到 findAll 123456@RequestMapping(value = &quot;saveOne&quot;) public String saveOne(Product product) &#123; ps.saveOne(product); System.out.println(product); return &quot;redirect:findAll&quot;; &#125; pageHelper搜索博客下文章 spring-security搜索博客下文章 pl/sql developer修改数据select * from 表名 for update点小锁 可以手动更改数据 然后保存提交一个是提交 一个是回滚上一步操作 ##]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM 2.项目错误整合]]></title>
    <url>%2F2019%2F05%2F30%2FSSM-2.%E9%A1%B9%E7%9B%AE%E9%94%99%E8%AF%AF%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[oracle中文乱码问题解决 查看服务器端编码select userenv(‘language’) from dual;我实际查到的结果为:AMERICAN_AMERICA.ZHS16GBK 执行语句 select * from V$NLS_PARAMETERS查看第一行中PARAMETER项中为NLS_LANGUAGE 对应的VALUE项中是否和第一步得到的值一样。如果不是，需要设置环境变量.否则PLSQL客户端使用的编码和服务器端编码不一致,插入中文时就会出现乱码. 设置环境变量计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建设置变量名:NLS_LANG,变量值:第1步查到的值， 我的是 AMERICAN_AMERICA.ZHS16GBK 重新启动PLSQL,插入数据正常]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 1.高级管理]]></title>
    <url>%2F2019%2F05%2F29%2FMaven-1.%E9%AB%98%E7%BA%A7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[jar包 依赖maven工程要导入jar包的坐标，就必须要考虑解决jar包冲突。 maven工程是可以分父子依赖关系的。 凡是依赖别的项目后，拿到的别的项目的依赖包，都属于传递依赖。 比如：当前A项目，被B项目依赖。那么我们A项目中所有jar包都会传递到B项目中。 B项目开发者，如果再在B项目中导入一套ssm框架的jar包，对于B项目是直接依赖。 那么直接依赖的jar包就会把我们A项目传递过去的jar包覆盖掉。 如果B版本低 A版本高 就会造成原有A项目的功能不能正常运行 为了防止以上情况的出现。我们可以把A项目中主要jar包的坐标锁住，那么其他依赖该项目的项目中， 即便是有同名jar包直接依赖，也无法覆盖。 解决jar包冲突的方式一：第一声明优先原则：哪个jar包的坐标在靠上的位置，这个jar包就是先声明的。先声明的jar包坐标下的依赖包，可以优先进入项目中。 maven导入jar包中的一些概念：直接依赖：项目中直接导入的jar包，就是该项目的直接依赖包。传递依赖：项目中没有直接导入的jar包，可以通过项目直接依赖jar包传递到项目中去。 解决jar包冲突的方式二：路径近者优先原则。直接依赖路径比传递依赖路径近，那么最终项目进入的jar包会是路径近的直接依赖包。 解决jar包冲突的方式三【推荐使用】： 直接排除法。当我们要排除某个jar包下依赖包，在配置exclusions标签的时候，内部可以不写版本号。因为此时依赖包使用的版本和默认和本jar包一样。 标准ssm框架格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208&lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt; &lt;/properties&gt; &lt;!-- 锁定jar包版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 项目依赖jar包 --&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 添加tomcat7插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Maven项目模块化工程和模块的区别： 工程不等于完整的项目，模块也不等于完整的项目，一个完整的项目看的是代码，代码完整，就可以说这是一个完整的项目 和此项目是工程和模块没有关系。 工程天生只能使用自己内部资源，工程天生是独立的。后天可以和其他工程或模块建立关联关系。模块天生不是独立的，模块天生是属于父工程的，模块一旦创建，所有父工程的资源都可以使用。 父子工程直接，子模块天生集成父工程，可以使用父工程所有资源。子模块之间天生是没有任何关系的。 父子工程直接不用建立关系，继承关系是先天的，不需要手动建立。平级直接的引用叫依赖，依赖不是先天的，依赖是需要后天建立的]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 2.视图 索引 pl/sql编程语言]]></title>
    <url>%2F2019%2F05%2F28%2FOracle-2.%E8%A7%86%E5%9B%BE-%E7%B4%A2%E5%BC%95-pl-sql%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[视图—视图—视图的概念：视图就是提供一个查询的窗口，所有数据来自于原表。 —查询语句创建表create table emp as select * from scott.emp;select * from emp;—创建视图【必须有dba权限】create view v_emp as select ename, job from emp;—查询视图select * from v_emp;—修改视图[不推荐]update v_emp set job=’CLERK’ where ename=’ALLEN’;commit;—创建只读视图create view v_emp1 as select ename, job from emp with read only;—视图的作用？—第一：视图可以屏蔽掉一些敏感字段。—第二：保证总部和分部数据及时统一。 索引—索引–索引的概念：索引就是在表的列上构建一个二叉树—-达到大幅度提高查询效率的目的，但是索引会影响增删改的效率。—单列索引—创建单列索引create index idx_ename on emp(ename);单列索引触发规则，条件必须是索引列中的原始值。单行函数，模糊查询，都会影响索引的触发。即 索引失效or 如果一个有索引 一个没有索引也导致索引失效 select * from emp where ename=’SCOTT’—复合索引—创建复合索引create index idx_enamejob on emp(ename, job);复合索引中第一列为优先检索列如果要触发复合索引，必须包含有优先检索列中的原始值select * from emp where ename=’SCOTT’ and job=’xx’;—触发复合索引select * from emp where ename=’SCOTT’ or job=’xx’;—不触发索引 可以为每一种都加单列索引select * from emp where ename=’SCOTT’;—触发单列索引。 pl/sql编程语言—pl/sql编程语言—pl/sql编程语言是对sql语言的扩展，使得sql语言具有过程化编程的特性。—pl/sql编程语言比一般的过程化编程语言，更加灵活高效。—pl/sql编程语言主要用来编写存储过程和存储函数等。 —声明方法—赋值操作可以使用:=也可以使用into查询语句赋值declare i number(2) := 10; s varchar2(10) := ‘小明’; ena emp.ename%type;—引用型变量 emprow emp%rowtype;—记录型变量begin dbms_output.put_line(i); dbms_output.put_line(s); select ename into ena from emp where empno = 7788; dbms_output.put_line(ena); select * into emprow from emp where empno = 7788; dbms_output.put_line(emprow.ename || ‘的工作为：’ || emprow.job);end; —pl/sql中的if判断—输入小于18的数字，输出未成年—输入大于18小于40的数字，输出中年人—输入大于40的数字，输出老年人declare i number(3) := &ii;begin if i&lt;18 then dbms_output.put_line(‘未成年’); elsif i&lt;40 then dbms_output.put_line(‘中年人’); else dbms_output.put_line(‘老年人’); end if;end; —pl/sql中的loop循环—用三种方式输出1到10是个数字—while循环declare i number(2) := 1;begin while i&lt;11 loop dbms_output.put_line(i); i := i+1; end loop;end;—exit循环declare i number(2) := 1;begin loop exit when i&gt;10; dbms_output.put_line(i); i := i+1; end loop;end;—for循环declare begin for i in 1..10 loop dbms_output.put_line(i); end loop;end; —游标：可以存放多个对象，多行记录。—输出emp表中所有员工的姓名declare cursor c1 is select * from emp; emprow emp%rowtype;begin open c1; loop fetch c1 into emprow; exit when c1%notfound; dbms_output.put_line(emprow.ename); end loop; close c1;end; —–给指定部门员工涨工资declare cursor c2(eno emp.deptno%type) is select empno from emp where deptno = eno; en emp.empno%type;begin open c2(10); loop fetch c2 into en; exit when c2%notfound; update emp set sal=sal+100 where empno=en; commit; end loop; close c2;end;—-查询10号部门员工信息select * from emp where deptno = 10; 存储过程—存储过程 语法： 12345create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]ASbegin PLSQL 子程序体；End; 或者–存储过程：存储过程就是提前已经编译好的一段pl/sql语言，放置在数据库端——–可以直接被调用。这一段pl/sql一般都是固定步骤的业务。or replace 可以覆盖修改的—-给指定员工涨100块钱create or replace procedure p1(eno emp.empno%type)is begin update emp set sal=sal+100 where empno = eno; commit;end; select * from emp where empno = 7788;—-测试p1declare begin p1(7788);end; 存储函数 语法： 1234567 create or replace function 函数名(Name in type, Name in type, ...) return 数据类型 is 结果变量 数据类型;begin return(结果变量);end 函数名; —-通过存储函数实现计算指定员工的年薪—-存储过程和存储函数的参数都不能带长度—-存储函数的返回值类型不能带长度create or replace function f_yearsal(eno emp.empno%type) return numberis s number(10);begin select sal*12+nvl(comm, 0) into s from emp where empno = eno; return s;end; —-测试f_yearsal—-存储函数在调用的时候，返回值需要接收。declare s number(10);begin s := f_yearsal(7788); dbms_output.put_line(s);end; —out类型参数如何使用—使用存储过程来算年薪create or replace procedure p_yearsal(eno emp.empno%type, yearsal out number)is s number(10); c emp.comm%type;begin select sal*12, nvl(comm, 0) into s, c from emp where empno = eno; yearsal := s+c;end; —测试p_yearsaldeclare yearsal number(10);begin p_yearsal(7788, yearsal); dbms_output.put_line(yearsal);end; —-in和out类型参数的区别是什么？—凡是涉及到into查询语句赋值或者:=赋值操作的参数，都必须使用out来修饰。 存储过程和存储函数的区别—存储过程和存储函数的区别—语法区别：关键字不一样，————存储函数比存储过程多了两个return。—本质区别：存储函数有返回值，而存储过程没有返回值。———-如果存储过程想实现有返回值的业务，我们就必须使用out类型的参数。———-即便是存储过程使用了out类型的参数，起本质也不是真的有了返回值，———-而是在存储过程内部给out类型参数赋值，在执行完毕后，我们直接拿到输出类型参数的值。 —-我们可以使用存储函数有返回值的特性，来自定义函数。—-而存储过程不能用来自定义函数。—-案例需求：查询出员工姓名，员工所在部门名称。—-案例准备工作：把scott用户下的dept表复制到当前用户下。create table dept as select * from scott.dept;—-使用传统方式来实现案例需求select e.ename, d.dnamefrom emp e, dept dwhere e.deptno=d.deptno;—-使用存储函数来实现提供一个部门编号，输出一个部门名称。create or replace function fdna(dno dept.deptno%type) return dept.dname%typeis dna dept.dname%type;begin select dname into dna from dept where deptno = dno; return dna;end;—使用fdna存储函数来实现案例需求：查询出员工姓名，员工所在部门名称。select e.ename, fdna(e.deptno)from emp e; —触发器，就是制定一个规则，在我们做增删改操作的时候，—-只要满足该规则，自动触发，无需调用。—-语句级触发器：不包含有for each row的触发器。—-行级触发器：包含有for each row的就是行级触发器。———–加for each row是为了使用:old或者:new对象或者一行记录。 —语句级触发器—-插入一条记录，输出一个新员工入职create or replace trigger t1afterinserton persondeclare begin dbms_output.put_line(‘一个新员工入职’);end;—触发t1insert into person values (1, ‘小红’);commit;select * from person; —行级别触发器—不能给员工降薪—raise_application_error(-20001~-20999之间, ‘错误提示信息’);create or replace trigger t2beforeupdateon empfor each rowdeclare begin if :old.sal&gt;:new.sal then raise_application_error(-20001, ‘不能给员工降薪’); end if;end;—-触发t2select * from emp where empno = 7788;update emp set sal=sal-1 where empno = 7788;commit; —-触发器实现主键自增。【行级触发器】—分析：在用户做插入操作的之前，拿到即将插入的数据，——给该数据中的主键列赋值。create or replace trigger auidbeforeinserton personfor each rowdeclare begin select s_person.nextval into :new.pid from dual;end;–查询person表数据select * from person;—使用auid实现主键自增insert into person (pname) values (‘a’);commit;insert into person values (1, ‘b’);commit; Java操作oracale 示例—-oracle10g ojdbc14.jar—-oracle11g ojdbc6.jar 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class OracleDemo &#123; @Test public void javaCallOracle() throws Exception &#123; //加载数据库驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //得到Connection连接 Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@192.168.88.6:1521:orcl", "itheima", "itheima"); //得到预编译的Statement对象 PreparedStatement pstm = connection.prepareStatement("select * from emp where empno = ?"); //给参数赋值 pstm.setObject(1, 7788); //执行数据库查询操作 ResultSet rs = pstm.executeQuery(); //输出结果 while(rs.next())&#123; System.out.println(rs.getString("ename")); &#125; //释放资源 rs.close(); pstm.close(); connection.close(); &#125; /** * java调用存储过程 * &#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储函数使用 * &#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储过程使用 * @throws Exception */ @Test public void javaCallProcedure() throws Exception &#123; //加载数据库驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //得到Connection连接 Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@192.168.88.6:1521:orcl", "itheima", "itheima"); //得到预编译的Statement对象 CallableStatement pstm = connection.prepareCall("&#123;call p_yearsal(?, ?)&#125;"); //给参数赋值 pstm.setObject(1, 7788); pstm.registerOutParameter(2, OracleTypes.NUMBER); //执行数据库查询操作 pstm.execute(); //输出结果[第二个参数] System.out.println(pstm.getObject(2)); //释放资源 pstm.close(); connection.close(); &#125; /** * java调用存储函数 * &#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储函数使用 * &#123;call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125; 调用存储过程使用 * @throws Exception */ @Test public void javaCallFunction() throws Exception &#123; //加载数据库驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //得到Connection连接 Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@192.168.88.6:1521:orcl", "itheima", "itheima"); //得到预编译的Statement对象 CallableStatement pstm = connection.prepareCall("&#123;?= call f_yearsal(?)&#125;"); //给参数赋值 pstm.setObject(2, 7788); pstm.registerOutParameter(1, OracleTypes.NUMBER); //执行数据库查询操作 pstm.execute(); //输出结果[第一个参数] System.out.println(pstm.getObject(1)); //释放资源 pstm.close(); connection.close(); &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 1.基本操作]]></title>
    <url>%2F2019%2F05%2F28%2FOracle-1.%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[** Mysql 与Oracle 基本查询方法相同 可以参考 ** Oracle为单独一个数据库 每个用户下有多张表 表分配在表空间中分号不要落下PLSQL Developer DataBase：172.18.139.161:1521/orcl 操作数据库–创建表空间create tablespace testdatafile ‘D:\java\test.dbf’size 100mautoextend onnext 10m;–删除表空间drop tablespace test; –创建用户create user rootidentified by tootdefault tablespace test; –给用户授权–oracle数据库中常用角色connect–连接角色，基本角色resource–开发者角色dba–超级管理员角色–给itheima用户授予dba角色grant dba to root; —切换到itheima用户下 —创建一个person表create table person( pid number(20), pname varchar2(10)); 操作表—修改表结构—添加一列alter table person add (gender number(1));—修改列类型alter table person modify gender char(1);—修改列名称alter table person rename column gender to sex;—删除一列alter table person drop column sex; 操作数据—查询表中记录select * from person;—-添加一条记录insert into person (pid, pname) values (1, ‘小明’);commit;—-修改一条记录update person set pname = ‘小马’ where pid = 1;commit; —-三个删除–删除表中全部记录delete from person;–删除表结构drop table person;–先删除表，再次创建表。效果等同于删除表中全部记录。–在数据量大的情况下，尤其在表中带有索引的情况下，该操作效率高。–索引可以提供查询效率，但是会影响增删改效率。truncate table person; 序列—-序列不真的属于任何一张表，但是可以逻辑和表做绑定。—-序列：默认从1开始，依次递增，主要用来给主键赋值使用。—-dual：虚表，只是为了补全语法，没有任何意义。create sequence s_person;select s_person.nextval from dual;—-添加一条记录insert into person (pid, pname) values (s_person.nextval, ‘小明’);commit;select * from person; 基本函数—-scott用户，密码tiger。–解锁scott用户 需要超级管理员权限alter user scott account unlock;–解锁scott用户的密码【此句也可以用来重置密码】alter user scott identified by tiger;–切换到scott用户下 –单行函数：作用于一行，返回一个值。—字符函数select upper(‘yes’) from dual;–YES 小写变大写select lower(‘YES’) from dual;–yes 大写变小写—-数值函数select round(56.16, -2) from dual;—四舍五入，后面的参数表示保留的位数 -2 小数点向前两位保留 100select trunc(56.16, -1) from dual;—直接截取，不再看后面位数的数字是否大于5. 50select mod(10, 3) from dual;—求余数 1—-日期函数—-查询出emp表中所有员工入职距离现在几天。sysdate系统天数select sysdate-e.hiredate from emp e;—-算出明天此刻select sysdate+1 from dual;—-查询出emp表中所有员工入职距离现在几月。select months_between(sysdate,e.hiredate) from emp e;—-查询出emp表中所有员工入职距离现在几年。select months_between(sysdate,e.hiredate)/12 from emp e;—-查询出emp表中所有员工入职距离现在几周。select round((sysdate-e.hiredate)/7) from emp e;—-转换函数—日期转字符串select to_char(sysdate, ‘fm yyyy-mm-dd hh24:mi:ss’) from dual; – fm 去掉0 4:19:39 hh24 24小时计数法—字符串转日期select to_date(‘2018-6-7 16:39:50’, ‘fm yyyy-mm-dd hh24:mi:ss’) from dual;—-通用函数—算出emp表中所有员工的年薪—-奖金里面有null值，如果null值和任意数字做算术运算，结果都是null。select e.sal*12+nvl(e.comm, 0) from emp e; 条件表达式—条件表达式—条件表达式的通用写法，mysql和oracle通用—给emp表中员工起中文名select e.ename, case e.ename when ‘SMITH’ then ‘曹贼’ when ‘ALLEN’ then ‘大耳贼’ when ‘WARD’ then ‘诸葛小儿’ –else ‘无名’ endfrom emp e;—判断emp表中员工工资，如果高于3000显示高收入，如果高于1500低于3000显示中等收入，—–其余显示低收入select e.sal, case when e.sal&gt;3000 then ‘高收入’ when e.sal&gt;1500 then ‘中等收入’ else ‘低收入’ endfrom emp e;—-oracle中除了起别名，都用单引号。—-oracle专用条件表达式select e.ename, decode(e.ename, ‘SMITH’, ‘曹贼’, ‘ALLEN’, ‘大耳贼’, ‘WARD’, ‘诸葛小儿’, ‘无名’) “中文名”from emp e; 聚合函数–多行函数【聚合函数】：作用于多行，返回一个值。select count(1) from emp;—查询总数量select sum(sal) from emp;—工资总和select max(sal) from emp;—最大工资select min(sal) from emp;—最低工资select avg(sal) from emp;—平均工资 分组查询—分组查询—查询出每个部门的平均工资—分组查询中，出现在group by后面的原始列，才能出现在select后面—没有出现在group by后面的列，想在select后面，必须加上聚合函数。—聚合函数有一个特性，可以把多行记录变成一个值。select e.deptno, avg(e.sal)–, e.enamefrom emp egroup by e.deptno;—查询出平均工资高于2000的部门信息select e.deptno, avg(e.sal) asalfrom emp egroup by e.deptnohaving avg(e.sal)&gt;2000;— 所有条件都不能使用别名来判断。having where 不能用别名–比如下面的条件语句也不能使用别名当条件 where s&gt;1500; 是错的select ename, sal s from emp where sal&gt;1500; —查询出每个部门工资高于800的员工的平均工资select e.deptno, avg(e.sal) asalfrom emp ewhere e.sal&gt;800group by e.deptno;—-where是过滤分组前的数据，having是过滤分组后的数据。—表现形式：where必须在group by之前，having是在group by之后。—查询出每个部门工资高于800的员工的平均工资—然后再查询出平均工资高于2000的部门select e.deptno, avg(e.sal) asalfrom emp ewhere e.sal&gt;800group by e.deptnohaving avg(e.sal)&gt;2000; 多表查询—多表查询中的一些概念—笛卡尔积select * from emp e, dept d;—等值连接select * from emp e, dept dwhere e.deptno=d.deptno;—内连接 和等值连接相同select * from emp e inner join dept don e.deptno = d.deptno;—查询出所有部门，以及部门下的员工信息。【外连接】select * from emp e right join dept don e.deptno=d.deptno;—查询所有员工信息，以及员工所属部门select * from emp e left join dept don e.deptno=d.deptno;—oracle中专用外连接select * from emp e, dept dwhere e.deptno(+) = d.deptno; select * from emp;—查询出员工姓名，员工领导姓名—自连接：自连接其实就是站在不同的角度把一张表看成多张表。select e1.ename, e2.enamefrom emp e1, emp e2where e1.mgr = e2.empno;——查询出员工姓名，员工部门名称，员工领导姓名，员工领导部门名称select e1.ename, d1.dname, e2.ename, d2.dnamefrom emp e1, emp e2, dept d1, dept d2where e1.mgr = e2.empnoand e1.deptno=d1.deptnoand e2.deptno=d2.deptno; 子查询—子查询—子查询返回一个值—查询出工资和SCOTT一样的员工信息 如果子查询条件是主键 确保值唯一 可以使用 = 连接子查询select * from emp where sal in(select sal from emp where ename = ‘SCOTT’)—子查询返回一个集合—查询出工资和10号部门任意员工一样的员工信息select * from emp where sal in(select sal from emp where deptno = 10);—子查询返回一张表—查询出每个部门最低工资，和最低工资员工姓名，和该员工所在部门名称—1，先查询出每个部门最低工资select deptno, min(sal) msalfrom empgroup by deptno;—2，三表联查，得到最终结果。select t.deptno, t.msal, e.ename, d.dnamefrom (select deptno, min(sal) msal from emp group by deptno) t, emp e, dept dwhere t.deptno = e.deptnoand t.msal = e.saland e.deptno = d.deptno; 分页—-oracle中的分页—rownum行号：当我们做select操作的时候，–每查询出一行记录，就会在该行上加上一个行号，–行号从1开始，依次递增，不能跳着走。 —-排序操作会影响rownum的顺序select rownum, e.* from emp e order by e.sal desc—-如果涉及到排序，但是还要使用rownum的话，我们可以再次嵌套查询。select rownum, t.* from(select rownum, e.* from emp e order by e.sal desc) t; —-emp表工资倒叙排列后，每页五条记录，查询第二页。—-rownum行号不能写上大于一个正数。* Oracle分页查询格式 ** select * from( select rownum rn, tt. from( select * from emp order by sal desc ) tt where rownum&lt;11) where rn&gt;5]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM 1.SSM框架整合]]></title>
    <url>%2F2019%2F05%2F27%2FSSM-1.SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[SSM框架整合 将其他框架整合到Spring框架上先测试单独的框架是否可用在进行组合 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;!-- 切入点表达式 事务控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring mvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 声明式事务管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc连接池技术--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Springtest123456789public class AccountTest &#123; @Test public void testFindAll()&#123; ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml"); AccountService service = ac.getBean("accountService", AccountService.class); service.findAll(); &#125;&#125; applicationContext.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 扫描的包 不扫描与spring mvc有关的--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;!-- 不扫描该注解--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; AccountService1234567891011121314@Service(value = "accountService")public class AccountServiceImpl implements AccountService &#123; @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层 查询所有用户运行....."); return null; &#125; @Override public void saveAccount(Account account) &#123; System.out.println("业务层 储存用户运行....."); &#125;&#125; 运行结果证明Spring框架搭建完毕 SpringMVC 及 SpringMVC 整合 SpringSpringMVCspringmvc.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 扫描包 不扫描 只扫描controller注解--&gt; &lt;context:component-scan base-package="it.test"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- 前端控制器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 去除拦截静态资源 --&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;&lt;!-- 配置springmvc 注解支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; AccountController1234567891011@Controller@RequestMapping(value = "/account")public class AccountController &#123; @RequestMapping(value = "/findAll") public String findAll()&#123; System.out.println("表现层 findAll方法运行了....."); return "success"; &#125;&#125; web.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 配置文件加载时间为服务器启动即加载--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置拦截器 编码为utf-8--&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; index success 省略不写SpringMVC 整合 Spring我们在web.xml 中配置了 启动服务器加载springmvc.xml 来实现springmvc的功能但我们如何实现 加载 applicationContext.xml 文件来实现整合呢 servletContext对象只有一个监听器已由spring提供 将其监听器配置到web.xml 监听器 ContextLoaderListenerorg.springframework.web.context.ContextLoaderListener该监听器 只能加载WEB-INF目录下的applicationContext.xml的配置文件配置时应手动提供路径 其类中contextInitialized对应着ServletContext 被创建时启动的监听方法其类中 (配置监听器调用的方法)contextDestroyed对应着ServletContext 被销毁时的监听方法 12345678 &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 配置类路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 配置文件加载时间为服务器启动即加载--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置拦截器 编码为utf-8--&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!-- 配置 Spring监听器--&gt;&lt;!-- ContextLoaderListener （只能加载WEB-INF目录下的applicationContext.xml的配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 配置类路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 123456789101112131415161718@Controller@RequestMapping(value = "/account")public class AccountController &#123; @Autowired private AccountService accountService; public void setService(AccountService service) &#123; this.accountService = service; &#125; @RequestMapping(value = "/findAll") public String findAll()&#123; accountService.findAll(); System.out.println("表现层 findAll方法运行了....."); return "success"; &#125;&#125; Mybatis Spring整合可以看作将SqlMapConfig.xml配置到applicationContext.xml中 通过配置文件方式配置 数据库连接所需要的参数 1234567&lt;context:property-placeholder location="classpath:druid.properties"&gt;&lt;/context:property-placeholder&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 步骤1 整合 配置连接池对象 配置sqlSession工厂 引入连接池 配置映射扫描包 需要我们提供数据库连接池文章中使用Spring提供的DriverManagerDataSource引入SqlSessionFactory对象为Spring提供的SqlSessionFactoryBean引入的映射扫描器对象为Spring提供的 MapperScannerConfigurer 配置连接的目的与SqlMapConfig.xml相同引入SqlSessionFactory对象目的是可以获取到代理相应的dao实现类引入的映射扫描器对象目的 提供扫描的包确定使用的接口 将对象放入spring容器中 代码123456789&lt;!--配置sqlSession工厂 引入连接池--&gt; &lt;bean id="sqlSessionFactory " class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 映射扫描配置--&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;!-- 包名--&gt; &lt;property name="basePackage" value="it.test.dao"&gt;&lt;/property&gt; &lt;/bean&gt; 步骤2 声明式事务控制Mybatis默认需要手动提交事务 所以整合到Spring框架以后 我们可以通过AOP切面编程控制事务详细步骤查看Spring 声明式事务控制文章 代码1234567891011121314151617181920212223&lt;!-- mybatis的增删改操作需要手动提交 所谓我们提供声明式事务控制 来进行操作--&gt;&lt;!-- 配置声明式事务控制--&gt;&lt;!-- 配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置事务通知 引用事务管理器--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt;&lt;!-- ropagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 配置aop切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!-- 建立连接--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 代码汇总pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day03_SSM框架整合&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;Day03_SSM框架整合 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;!-- 切入点表达式 事务控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring mvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 声明式事务管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring jdbc连接池技术--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;Day03_SSM框架整合&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 配置文件加载时间为服务器启动即加载--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置拦截器 编码为utf-8--&gt; &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!-- 配置 Spring监听器--&gt;&lt;!-- ContextLoaderListener （只能加载WEB-INF目录下的applicationContext.xml的配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 配置类路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 扫描的包 不扫描与spring mvc有关的--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;!-- 不扫描该注解--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- 整合 Mybaits--&gt;&lt;!-- 配置连接池对象--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--配置sqlSession工厂 引入连接池--&gt; &lt;bean id="sqlSessionFactory " class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 映射扫描配置--&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;!-- 包名--&gt; &lt;property name="basePackage" value="it.test.dao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- mybatis的增删改操作需要手动提交 所谓我们提供声明式事务控制 来进行操作--&gt;&lt;!-- 配置声明式事务控制--&gt;&lt;!-- 配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置事务通知 引用事务管理器--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt;&lt;!-- ropagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 配置aop切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!-- 建立连接--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; springmvc.xml 123456789101112131415161718192021222324252627282930 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 扫描包 不扫描 只扫描controller注解--&gt; &lt;context:component-scan base-package="it.test"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- 前端控制器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 去除拦截静态资源 --&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;&lt;!-- 配置springmvc 注解支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; Dao123456789101112131415161718192021/** * 通过Mybatis 实现 */@Repositorypublic interface AccountDao &#123; /** * 查询所有用户 * @return List&lt;Account&gt; */ @Select("select * from spring_account") List&lt;Account&gt; findAll(); /** * 储存用户 * @param account */ @Insert("insert into spring_account(name ,money) values (#&#123;name&#125;,#&#123;money&#125;)") void saveAccount(Account account);&#125; service123456789101112131415161718192021222324@Service(value = "accountService")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao dao; public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; @Override public List&lt;Account&gt; findAll() &#123; System.out.println("业务层 查询所有用户运行....."); return dao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println("业务层 储存用户运行....."); dao.saveAccount(account); &#125;&#125; controller123456789101112131415161718192021222324252627282930313233@Controller@RequestMapping(value = "/account")public class AccountController &#123; @Autowired private AccountService accountService; public void setService(AccountService service) &#123; this.accountService = service; &#125; @RequestMapping(value = "/findAll") public String findAll(Model model)&#123; List&lt;Account&gt; accountList = accountService.findAll(); model.addAttribute("accountList",accountList); System.out.println(accountList); return "success"; &#125; @RequestMapping(value = "/saveAccount") public void saveAccount(Account account, HttpServletRequest request, HttpServletResponse response)&#123; accountService.saveAccount(account); System.out.println("表现层 saveAccount方法运行了....."); try &#123;// 重定向跳转页面 response.sendRedirect(request.getContextPath()+"/account/findAll"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; success.jsp123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;success&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;成功查询！&lt;/h2&gt;&lt;c:forEach items="$&#123;accountList&#125;" var="account"&gt; $&#123;account.name&#125; $&#123;account.money&#125;&lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring /与*]]></title>
    <url>%2F2019%2F05%2F26%2FSpring%E9%80%9A%E9%85%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Serlvet&lt; url-pattern&gt;/*&lt;/ url-pattern&gt;/* 会覆盖掉其他所有的servlet，包括servlet容器提供的，例如default servlet 和 the JSP servlet。因为除去精确匹配，优先级排第二的就是路径匹配，它的优先级要比扩展名匹配和缺省匹配优先级高。一般/*只在过滤器中使用。 &lt; url-pattern&gt;/&lt; /url-pattern&gt;/ 不会覆盖其他的servlet。仅仅会取代servlet容器内置的缺省servlet，它通常会触发静态资源和目录，例如CSS/JS/image/ 等文件。servlet容器内置的缺省servlet同时能够处理HTTP缓存请求，媒体文件流（音频、视频）、和文件下载摘要。通常，你最好不要重写内置缺省的servlet，如果要覆盖重写，你必须实现上面列出的任务。这个模式是最后匹配的，jsp文件都是属于扩展名匹配，优先级高于这个缺省匹配。 即 /不会匹配到.jsp .css 静态文件 不会拦截除静态资源外的所有请求 Interceptor不能以/结尾的原因 因为他没这个功能** interceptor 和 servlet匹配机制不同 ** 详细说明Servlet、Filter、Interceptor的url匹配规则]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>通配符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 6.异常处理&拦截器]]></title>
    <url>%2F2019%2F05%2F26%2FSpringMVC-6.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%26%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[异常处理如果不处理 则会将异常显示在页面上 十分不友好 所以我们需要跳转到指定页面 显示错误 异常处理基本流程 需求需要自定义异常处理器 代码controller12345678910111213141516@Controller@RequestMapping(value = "/test")public class ExceptionController &#123; @RequestMapping(value = "/testException") public String testException() throws MyException &#123;// 捕获异常 try &#123; int a=10/0; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new MyException("程序出现错误了(ﾟДﾟ*)ﾉ"); &#125; return "success"; &#125;&#125; MyException12345678910111213141516public class MyException extends Exception &#123; private String message; public MyException(String message) &#123; super(message); this.message=message; &#125; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; MyExceptionResolver1234567891011121314151617181920212223242526/** * 自定义异常处理器 * 在SpringMVC中配置 */public class MyExceptionResolver implements HandlerExceptionResolver &#123; @Override /** * exception e 为捕获到的异常 */ public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;// 如果异常是MyException则强转 MyException exception = null; if (e instanceof MyException) &#123; exception = (MyException) e; &#125; else &#123; exception = new MyException("ヽ(ｏ`皿′ｏ)ﾉ不清楚什么错误呢 请联系管理员！"); &#125;// 设置跳转错误页面 并将消息显示 ModelAndView view = new ModelAndView(); view.addObject("exception",exception.getMessage()); view.setViewName("error"); return view; &#125;&#125; springmvc.xml12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置自定义异常处理器--&gt; &lt;bean id="myExceptionResolver" class="it.test.exception.MyExceptionResolver"&gt;&lt;/bean&gt;&lt;!-- &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; error123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Exception&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;exception&#125;&lt;/body&gt;&lt;/html&gt; 拦截器以servlet为分界前后 前提jdk1.8版本对接口进行了增强 可以拥有静态方法和default方法，所谓default方法既是使用default关键字来修饰的方法。一个接口可以有多个静态方法和default方法，没有个数限制 如果多个接口出现方法名和参数列表相同的defult方法，这个时候就必须要在实现类里面显式重写default的方法，而关于default的方法的重写,我们在实现类中不需要继续出现default关键字也不能出现default关键字。重写的default方法必须的访问权限必须是public 如果使用则直接调用方法默认值 如果需要自己定义 则复写方法 作用功能Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 区别 过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 要求必须实现：HandlerInterceptor 接口。 实现** 要求必须实现：HandlerInterceptor 接口 **springmvc.xml配置拦截器 123456789101112&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt;&lt;mvc:interceptor&gt;&lt;!-- 哪些方法进行拦截 --&gt;&lt;mvc:mapping path="/user/*"/&gt;&lt;!-- 哪些方法不进行拦截&lt;mvc:exclude-mapping path=""/&gt;--&gt;&lt;!-- 注册拦截器对象 --&gt;&lt;bean class="cn.itcast.demo1.MyInterceptor1"/&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器链流程图 HandlerInterceptor接口中的方法 preHandle方法是controller方法执行前拦截的方法,可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 afterCompletion方法是在JSP执行后执行 request或者response不能再跳转页面了 结果显示： 代码MyInterceptor1 MyInterceptor212345678910111213141516171819202122232425262728293031323334/** * 拦截器 作用于servlet */public class MyInterceptor1 implements HandlerInterceptor &#123; @Override /** * consroller执行前执行 如果false则不放行 true放行 可以跳转页面 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("MyInterceptor1 preHandle执行了......."); // 转发 拦截 不会有后续操作// request.getRequestDispatcher("/WEB-INF/pages/happy.jsp").forward(request,response);// return false; return true; &#125; @Override /** * consroller执行后 jsp跳转执行前执行 */ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("MyInterceptor1 postHandle执行了.......");// 转发 会打印success.jsp 但不会跳转// request.getRequestDispatcher("/WEB-INF/pages/happy.jsp").forward(request,response); &#125; @Override /** * jsp执行后执行 */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("MyInterceptor1 afterCompletion执行了........."); &#125;&#125; 12345678910111213141516171819202122232425262728public class MyInterceptor2 implements HandlerInterceptor &#123; @Override /** * consroller执行前执行 如果false则不放行 true放行 可以跳转页面 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("MyInterceptor2 preHandle执行了......."); return true; &#125; @Override /** * consroller执行后 jsp跳转执行前执行 */ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("MyInterceptor2 postHandle执行了.......");// 转发// request.getRequestDispatcher("/WEB-INF/pages/happy.jsp").forward(request,response); &#125; @Override /** * jsp执行后执行 */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("MyInterceptor2 afterCompletion执行了........."); &#125;&#125; MyController1234567891011@Controller@RequestMapping(value = "/test")public class MyController &#123; @RequestMapping(value = "/testInterceptor") public String testInterceptor()&#123; System.out.println("MyController控制器已运行......"); return "success"; &#125;&#125; springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- &lt;mvc:resources location="/js/" mapping="/js/**"/&gt;--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt;&lt;!-- 对哪些方法拦截 对哪些方法不拦截 mvc:exclude-mapping path=""--&gt; &lt;mvc:mapping path="/test/**"/&gt;&lt;!-- 注册拦截对象--&gt; &lt;bean class="it.test.interceptor.MyInterceptor1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/test/**"/&gt; &lt;bean class="it.test.interceptor.MyInterceptor2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 5.文件上传]]></title>
    <url>%2F2019%2F05%2F21%2FSpringMVC-5.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[** 将项目部署到tomcat服务器下 选择 war 将项目部署在项目目录下用war exploded** 传统方式的文件上传文件上传前提 form 表单的 enctype 取值必须是：multipart/form-data(默认值是:application/x-www-form-urlencoded)enctype:是表单请求正文的类型 realPath(&quot;\upload\&quot;): 代表的路径为类路径 即：target下项目目录C:\Users\CZQYY\IdeaProjects\Mybatis_study1\SpringMVC_study\Day02_SpringMVC文件上传\target\Day02_SpringMVC文件上传\upload\ 导入jar包commons-fileuploadcommons-io 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 代码index.jsp1234&lt;form action="test/testOldUpLoad" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="upload"&gt;&lt;br&gt; &lt;input type="submit" value="上传文件"&gt;&lt;/form&gt; Mycontroller.java1234567891011121314151617181920212223242526272829303132333435363738394041@Controller@RequestMapping(value = "test")public class MyController &#123; @RequestMapping(value = "testOldUpLoad") public String testOldUpLoad(HttpServletRequest request) &#123;// 先获取到想要上传的路径 位于类目录下 String path = request.getSession().getServletContext().getRealPath("/upload/"); File file = new File(path); if (!file.exists()) &#123; boolean mkdirs = file.mkdirs(); if (!mkdirs)&#123; throw new RuntimeException("创建上传路径错误"); &#125; &#125;// 创建文件项工厂 DiskFileItemFactory df=new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(df);// 解析request请求 try &#123; List&lt;FileItem&gt; list = fileUpload.parseRequest(request); for (FileItem item : list) &#123;// 如果文件项不是普通的表格 if (!item.isFormField())&#123;// 获取上传文件名字 String fieldName = item.getName();// 为防止覆盖为名称添加UUID 并把其中的-全改 fieldName = UUID.randomUUID().toString().replace("-", "")+"_"+fieldName;// 上传文件 item.write(new File(path,fieldName)); &#125; &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(path); return "success"; &#125;&#125; 结果： SpringMVC文件上传原理文件提交后 通过request请求 被前端控制器拦截将request请求发送给 配置文件解析器CommonsMultipartResolver通过文件解析器解析返回前端控制器上传文件对象前段控制器将上传文件对象 传递给对应方法作为参数使用 需求1234567 &lt;!-- id 的值是固定的--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;!-- 设置上传文件最大不超过5MB--&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt; 方法参数名必须和name一致 代码index.jsp1234567&lt;h3&gt;SpringMVC上传方式&lt;/h3&gt;&lt;form action="test/testNewUpLoad" method="post" enctype="multipart/form-data"&gt; &lt;%-- name 方法参数名必须和name一致--%&gt; &lt;input type="file" name="upload"&gt;&lt;br&gt; &lt;input type="submit" value="上传文件"&gt;&lt;/form&gt; springmvc.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- id 的值是固定的--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;!-- 设置上传文件最大不超过5MB--&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; MyController.java1234567891011121314151617181920212223242526 @RequestMapping(value = "testNewUpLoad") /** * 传入配置文件解析器 */ public String testNewUpLoad(HttpServletRequest request, MultipartFile upload)&#123; // 先获取到想要上传的路径 位于类目录下 String path = request.getSession().getServletContext().getRealPath("/upload/"); File file = new File(path); if (!file.exists()) &#123; boolean mkdirs = file.mkdirs(); if (!mkdirs)&#123; throw new RuntimeException("创建上传路径错误"); &#125; &#125; String fileName = upload.getOriginalFilename(); fileName = UUID.randomUUID().toString().replace("-", "")+"_"+fileName; System.out.println(fileName);// 上传文件 try &#123; upload.transferTo(new File(path,fileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return "success"; &#125;&#125; 跨服务器上传图片服务器的两个端口号要更改 避免端口冲突 需求http://localhost:9090/uploads/ 在其项目文件target下提供uploads文件夹 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; 正常情况下服务器默认不支持写入 要在conf/web.xml中开启 123456789101112131415161718 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;!-- 添加，解决jersey上传服务器403错误 --&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; java实现123456789101112131415161718 @RequestMapping(value = "testNewUpLoad2") public String testNewUpLoad2(MultipartFile upload) throws IOException &#123;// 定义上传服务器路径 String path = "http://localhost:9090/uploads/"; String fileName = upload.getOriginalFilename(); fileName = UUID.randomUUID().toString().replace("-", "") + "_" + fileName; System.out.println(fileName);// 创建客户端对象 Client client = Client.create();// 连接图片服务器// http://localhost:9090/uploads/xxx.png WebResource resource = client.resource(path + fileName);// 上传文件 resource.put(upload.getBytes()); return "success"; &#125; 结果：]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 4.控制器方法返回值分类]]></title>
    <url>%2F2019%2F05%2F20%2FSpringMVC-4.%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[字符串12345678@RequestMapping(value = "testString") public String testString(Model model)&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); model.addAttribute("user",user); return "success"; &#125; 1$&#123;requestScope.user.uname&#125; 1&lt;a href="test/testVoid"&gt;testVoid&lt;/a&gt;&lt;br&gt; voidServlet 原始 API 可以作为控制器中方法的参数但此方法不会调用视图解析器 123456789101112@RequestMapping("/testVoid")public void testVoid(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); String contextPath = request.getServletPath(); System.out.println(contextPath); &#125; catch (ServletException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; ModelAndViewModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值三个常用方法： modelAndView.addObject() 通过调用ModelMap.addAttribute 向Request域中添加键值对 modelAndView.getModelMap()获取ModelMap对象 modelAndView.setViewName()设置视图声明跳转文件名 否则默认为 请求路径与RequestMapping的值保持一致xxx.jsp1234567891011 public ModelAndView testModelAndView()&#123; ModelAndView modelAndView = new ModelAndView(); User user = new User(); user.setUname("于松江"); user.setAge(13); modelAndView.addObject("user",user);// 内部获取ModelMap方法 modelAndView.getModelMap().addAttribute("user",user); modelAndView.setViewName("success");// 声明跳转文件名 否则默认为 请求路径testModelAndView return modelAndView; &#125; 1$&#123;requestScope.user.uname&#125; 结果： ResponseBody 响应 json 数据该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端 json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包 123456789101112131415 &lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 mvc:resources标签配置不过滤 location元素表示webapp目录下的包下的所有文件 mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b 1234&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt; &lt;!-- 样式 --&gt;&lt;mvc:resources location="/images/" mapping="/images/**"/&gt; &lt;!-- 图片 --&gt;&lt;mvc:resources location="/js/" mapping="/js/**"/&gt; &lt;!-- javascript --&gt; 代码index.jsp1234567891011121314151617181920212223242526272829303132333435&lt;%-- User: CZQYY Date: 2019/5/20 Time: 14:58 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;script&gt; $(function () &#123; $("#btn").click(function () &#123; $.post("test/testJson", &#123;uname:"于松江",age:18&#125;, function (user) &#123; alert(user.uname); alert(user.age); &#125;,"json"); &#125;) &#125;)&lt;/script&gt;&lt;body&gt;&lt;a href="test/testVoid"&gt;testVoid&lt;/a&gt;&lt;br&gt;&lt;a href="test/testString"&gt;testString&lt;/a&gt;&lt;br&gt;&lt;a href="test/testModelAndView"&gt;ModelAndView&lt;/a&gt;&lt;br&gt;&lt;button id="btn"&gt;Json请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; web.xml123456789101112131415161718192021222324252627282930&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; success.jsp123456789101112131415161718&lt;%-- User: CZQYY Date: 2019/5/20 Time: 14:57 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; 成功！！！！&lt;/h1&gt;$&#123;requestScope.user.uname&#125;&lt;/body&gt;&lt;/html&gt; CommonAnno123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import it.test.domain.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;@Controller@RequestMapping(value = "/test")public class CommonAnno &#123; /** * 无返回值 */ @RequestMapping("/testVoid") public void testVoid(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); String contextPath = request.getServletPath(); System.out.println(contextPath); &#125; catch (ServletException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @RequestMapping(value = "testString") public String testString(Model model)&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); model.addAttribute("user",user); return "success"; &#125; @RequestMapping(value = "testModelAndView") /** * ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。 */ public ModelAndView testModelAndView()&#123; ModelAndView modelAndView = new ModelAndView(); User user = new User(); user.setUname("于松江"); user.setAge(13); modelAndView.addObject("user",user);// 内部获取ModelMap方法 modelAndView.getModelMap().addAttribute("user",user); modelAndView.setViewName("success");// 声明跳转文件名 否则默认为 请求路径testModelAndView return modelAndView; &#125; @RequestMapping(value = "testJson") public @ResponseBody User testJson( User user)&#123;/* try &#123;// 后台通过 URLDecoder.decode解码 String s = URLDecoder.decode(body, "UTF-8"); System.out.println(s); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;*/ System.out.println(user); user.setUname("程泽琪"); return user; &#125;&#125; springmvc.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置扫描--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt;&lt;!-- 配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 配置忽略解析路径 可以加载静态解析--&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 3.常用注解]]></title>
    <url>%2F2019%2F05%2F15%2FSpringMVC-3.%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Model接口 是将键值对存入request域中取值调用其实现类modelMap 常用注解RequestParam把请求中指定名称的参数给控制器中的形参赋值。作用于参数上value：请求参数中的名称。required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。defaultValue：默认值 如果没有提供 则自定传入默认值@RequestParam(name = &quot;page&quot;, required = true, defaultValue = &quot;1&quot;)例： 如果不用该注解修饰 对应不上则打印null结果： 1&lt;a href="test/testRequestParam?username=于松江"&gt;testRequestParam&lt;/a&gt; 12345@RequestMapping(value = "/testRequestParam") public String testRequestParam(@RequestParam(value = "username") String userName)&#123; System.out.println(userName); return "success"; &#125; RequestBody用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。例：结果： 12345&lt;form action="test/testRequestBody" method="post"&gt; 账号：&lt;input type="text" name="userName"&gt;&lt;br&gt; 密码：&lt;input type="text" name="passWord"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 12345@RequestMapping(value = "/testRequestBody") public String testRequestBody(@RequestBody String spring)&#123; System.out.println(spring); return "success"; &#125; PathVaribale用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。value：用于指定 url 中占位符名称。required：是否必须提供占位符。结果： 12345@RequestMapping(value = "/testPathVariable/&#123;sid&#125;") public String testPathVariable(@PathVariable("sid") int id)&#123; System.out.println(id); return "success"; &#125; 1&lt;a href="test/testPathVariable/10"&gt;pathVariable&lt;/a&gt; RequestHeader用于获取请求消息头。value：提供消息头名称required：是否必须有此消息头结果： 12345@RequestMapping(value = "/testRequestHeader") public String testRequestHeader(@RequestHeader(value = "Accept-Language")String header)&#123; System.out.println(header); return "success"; &#125; 1&lt;a href="test/testRequestHeader"&gt;RequestHeader&lt;/a&gt; CookieValue用于把指定 cookie 名称的值传入控制器方法参数。value：指定 cookie 的名称。required：是否必须有此 cookie。结果： 12345@RequestMapping(value = "/testCookieValue") public String testCookieValue(@CookieValue(value="JSESSIONID") String value)&#123; System.out.println(value); return "success"; &#125; 1&lt;a href="test/testCookieValue"&gt;CookieValue&lt;/a&gt; ModelAttribute出现在方法上 会将返回值保存到Request域中该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。出现在参数上，获取指定的数据给参数赋值。value：用于获取数据的 key。key 可以是 JavaBean 的属性名称，也可以是 map 结构的 key 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。例如：我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。 有返回值： 结果：会覆盖掉原有的值 但没有添加的值 保留 12345&lt;form action="test/testModelAttribute" method="post"&gt; 姓名：&lt;input type="text" name="uname"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 1234567891011121314@RequestMapping(value = "/testModelAttribute") public String testModelAttribute(User user)&#123; System.out.println(user); return "success"; &#125; @ModelAttribute public User createUser()&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); user.setBirthday(new Date()); return user; &#125; 无返回值： 123456789101112131415@RequestMapping(value = "/testModelAttribute") public String testModelAttribute(@ModelAttribute(value = "用户1") User user)&#123; System.out.println(user); return "success"; &#125; @ModelAttribute public void createUser(Map&lt;String,User&gt; map)&#123; User user = new User(); user.setUname("于松江"); user.setAge(13); user.setBirthday(new Date()); map.put("用户1",user); &#125;` SessionAttribute作用在类上用于多次执行控制器方法间的参数共享。value：用于指定存入的属性名称type：用于指定存入的数据类型 结果：清除session后结果： 1234567891011@RequestMapping(value = "/test")@SessionAttributes(value = &#123;"abc"&#125;)public class CommonAnno &#123; @RequestMapping(value = "/testSessionAttributes") public String testSessionAttribute(Model model)&#123;// 会存储到request域中 model.addAttribute("abc","美美"); return "success"; &#125;&#125; 将结果显示到success.jsp页面 12$&#123;requestScope.abc&#125;$&#123;sessionScope&#125; 清除 123456 @RequestMapping(value = "/testRemoveSessionAttributes") public String testRemoveSessionAttributes(SessionStatus status)&#123;// 清除session status.setComplete(); return "success"; &#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 2.组件介绍 RequestMapping 参数绑定]]></title>
    <url>%2F2019%2F05%2F15%2FSpringMVC-2.%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D-RequestMapping-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A1%2F</url>
    <content type="text"><![CDATA[组件介绍DispatcherServlet 前端控制器用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 HandlerMapping 处理器映射器HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式例如：配置文件方式，实现接口方式，注解方式等。 Handler 处理器它就是我们开发中要编写的具体业务控制器。DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 HandlAdapter 处理器适配器通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver 视图解析器View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 &lt;mvc:annotation-driven&gt; 说明在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。使 用 mvc:annotation-driven 自动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用mvc:annotation-driven替代注解处理器和适配器的配置。 RequestMapping用于建立请求 URL 和处理请求方法之间的对应关系。源码头 说明可以作用于类和方法 12345@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping 出现在类上请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。它出现的目的是为了使我们的 URL 可以按照模块化管理 出现在方法上请求 URL 的第二级访问目录属性： value：用于指定请求的 URL。它和 path 属性的作用是一样的。 method：用于指定请求的方式。RequestMethod.POST只支持POST提交方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。例如：params = {“accountName”}，表示请求参数必须有 accountNameparams = {“moeny!100”}，表示请求参数中 money 不能是 100。headers：用于指定限制请求消息头的条件。注意：以上四个属性只要出现 2 个或以上时，他们的关系是与&amp;的关系。 参数绑定解决POST请求参数中文乱码问题 添加过滤器为所有目录下的请求配置UTF-8 web.xml 12345678910111213&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 基本类型和String类型：Controller类：12345@RequestMapping("/testParam") public String testParam(String userName)&#123; System.out.println(userName); return "success"; &#125; JavaBean类型Param.jsp1234567&lt;form action="param/testAccount" method="post"&gt; 账号：&lt;input type="text" name="userName"&gt;&lt;br&gt; 密码：&lt;input type="text" name="passWord"&gt;&lt;br&gt; 姓名：&lt;input type="text" name="user.uname"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="user.age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller类：12345@RequestMapping("/testAccount")public String testAccount(Account account)&#123; System.out.println(account); return "success";&#125; Account类123456public class Account &#123; private String userName; private String passWord; private User user; ... &#125; 集合类型Account类123456puprivate String userName; private String passWord; private Map&lt;String,User&gt; map; private List&lt;User&gt; list; ... &#125; Param.jsp 123456789 &lt;form action="param/testAccount" method="post"&gt; 账号：&lt;input type="text" name="userName"&gt;&lt;br&gt; 密码：&lt;input type="text" name="passWord"&gt;&lt;br&gt; List姓名：&lt;input type="text" name="list[0].uname"&gt;&lt;br&gt; List年龄：&lt;input type="text" name="list[0].age"&gt;&lt;br&gt; Map姓名：&lt;input type="text" name="map['于松江'].uname"&gt;&lt;br&gt; Map年龄：&lt;input type="text" name="map['于松江'].age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 结果显示： 1.实体类中加日期格式化注解12@DateTimeFormat(pattern="yyyy-MM-dd HH:mm")private Date creationTime; 2.属性编辑器spring3.1之前 在Controller类中通过@InitBinder完成 12345678910111213141516171819202122/** * 在controller层中加入一段数据绑定代码 * @param webDataBinder */ @InitBinder public void initBinder(WebDataBinder webDataBinder) throws Exception&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm"); simpleDateFormat.setLenient(false); webDataBinder.registerCustomEditor(Date.class , new CustomDateEditor(simpleDateFormat , true)); &#125; 备注：自定义类型转换器必须实现PropertyEditor接口或者继承PropertyEditorSupport类写一个类 extends propertyEditorSupport（implements PropertyEditor）&#123; public void setAsText(String text)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy -MM-dd hh:mm"); Date date = simpleDateFormat.parse(text); this.setValue(date); &#125; public String getAsTest()&#123; Date date = (Date)this.getValue(); return this.dateFormat.format(date); &#125;&#125; 自定义类型转换器例如日期类 springmvc框架可以转换yyyy/MM/dd 但不能转换yyyy-MM-dd我们就要手动实现这个功能 首先继承Converter&lt;S, T&gt;接口 S:表示接受的类型，T：表示目标类型 自己实现日期转换12345678910111213141516171819202122public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; if (StringUtils.isEmpty(source))&#123; throw new NullPointerException("请输入日期"); &#125; DateFormat format=null; if (source.contains("/")) &#123; format = new SimpleDateFormat("yyyy/MM/dd"); &#125; if (source.contains("-"))&#123; format = new SimpleDateFormat("yyyy-MM-dd"); &#125; try &#123; Date date = format.parse(source); return date; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 在 spring 配置文件中配置类型转换器配置类型转换器工厂 注入自定义类型转换器 在注解支持中引用类型转换器 123456789101112&lt;!-- 配置类型转换器工厂--&gt; &lt;bean id="conversionServiceFactoryBean" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;&lt;!-- 注入自定义类型转换器--&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;!-- 也可以使用array list--&gt;&lt;!-- 配置自定义转换器--&gt; &lt;bean class="it.test.utils.StringToDateConverter"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启mvc注解支持 引用自定义类型转换器--&gt; &lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean"&gt;&lt;/mvc:annotation-driven&gt; 获取原生request response请求方法参数中 之间填入HttpServletRequest HttpServletResponse]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 1.SpringMVC快速入门]]></title>
    <url>%2F2019%2F05%2F14%2FSpringMVC-1.SpringMVC%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[SpringMVC相关基本概念MVC及三层架构基于B/S架构系统标准的三层架构包括：表现层、业务层、持久层MVC 全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写，一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职： Model（模型）：通常指的就是我们的数据模型。作用一般情况下用于封装数据。 View（视图）：通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。 Controller（控制器）：是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。它相对于前两个不是很好理解，这里举个例子：例如：我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充到模型之中。此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做的。当校验失败后，由控制器负责把错误页面展示给使用者。如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。SpringMVC概念 SpringMVC优势 清晰的角色划分：前端控制器（DispatcherServlet）请求到处理器映射（HandlerMapping）处理器适配器（HandlerAdapter）视图解析器（ViewResolver）处理器或页面控制器（Controller）验证器（ Validator）命令对象（Command 请求参数绑定到的对象就叫命令对象）表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。 分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。 强大的 JSP 标签库，使 JSP 编写更容易。还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。SpringMVC入门 基本流程图 配置文件pom.xml除了Spring-context核心以外还要导入spring-web spring-webmvc servlet-api如果使用JSP还需要导入jsp-api 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day01_SpringMVC快速入门&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;Day01_SpringMVC快速入门 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;Day01_SpringMVC快速入门&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 控制器类HelloController 创建该实例并用方法接受请求 返回页面名称 123456789101112@Controllerpublic class HelloController &#123; @RequestMapping(path = "/hello") public String sayHello() &#123; System.out.println("Hello SpringMVC！！");// 返回的是文件名 return "success"; &#125;&#125; springmvc.xml配置该xml文件需要实例化控制器类 并配置视图解析器确定视图所在路径 文件名后缀 并开启mvc注解支持 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置要扫描的包--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt;&lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;!-- 包路径--&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt;&lt;!-- 文件后缀名--&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启mvc注解支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; web.xml配置前端控制器拦截访问路径并配置servle初始化参数，t创建时会加载springmvc.xml文件否则不被使用 无法启动功能 12345678910111213141516171819202122232425&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt;&lt;!-- 配置前端控制器拦截请求--&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置dispatcherServlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置servlet启动时加载对象 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp 12345678910 &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="hello"&gt;hello&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 9.声明式事务控制]]></title>
    <url>%2F2019%2F05%2F14%2FSpring-9.Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[声明式事务控制 TransactionManager接口需要引入tx 即Spring事务控制部分 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 由Spring框架给出的事务控制（事务管理器） 不需要自己手动实现使用的实现类DataSourceTransactionManager 1.配置事务管理器因为是数据库连接池事务管理器 事务主要为手动提交 回滚 和关闭连接所以配置时要注入DataSource 123&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; 2.配置事务通知创建一个事务通知 并给事务通知一个管理器引用 并向其中配置属性 由&lt;tx:advice&gt;进行配置 配置事务属性&lt;tx:advice&gt; 内部嵌套 &lt;tx:attributes&gt; 内部嵌套 &lt;tx:method&gt; isolation :用于指定事务隔离级别 默认值DEFAULT 表示使用数据库的默认隔离级别 no-rollback-for：用于指定一个异常 出现异常不回滚 其他异常回滚 没有默认值 表示任何异常回滚 propagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS read-only:用于指定是否只读 查询方法设置为true 其他为false rollback-for：用于指定一个异常 出现异常回滚 其他异常不回滚 没有默认值 表示任何异常回滚 timeout：用于指定超时时间 默认-1 表示永远不超时 指定数值以S作单位1234567 &lt;tx:attributes&gt;&lt;!-- 配置所有指定范围内方法--&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt;&lt;!-- 配置以find开头的方法--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 3.配置AOP切面装载通知建立事务通知和切入点表达式的联系&lt;aop:advisor&gt; 12345 &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!--3.1建立事务通知和切入点表达式的联系--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 代码pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day06_Spring声明式事务控制&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; bean.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;!-- aop 切面增强 tx 声明式事务控制--&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="accountService" class="it.test.service.impl.AccountServiceImpl"&gt; &lt;property name="dao" ref="accountDao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--声明式事务控制--&gt;&lt;!--1.配置事务管理器 因为需要connection 配置事务 所以注入DataSource--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--2.配置事务通知 给事务通知一个管理器引用--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;!--2.1配置事务属性 isolation :用于指定事务隔离级别 默认值DEFAULT 表示使用数据库的默认隔离级别 no-rollback-for：用于指定一个异常 出现异常不回滚 其他异常回滚 没有默认值 表示任何异常回滚 propagation：用于事务传播行为 REQUIRED 表示存在事务 用于增删改 查询为SUPPORTS read-only:用于指定是否只读 查询方法设置为true 其他为false rollback-for：用于指定一个异常 出现异常回滚 其他异常不回滚 没有默认值 表示任何异常回滚 timeout：用于指定超时时间 默认-1 表示永远不超时 指定数值以S作单位 --&gt; &lt;tx:attributes&gt;&lt;!-- 配置所有指定范围内方法--&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false" /&gt;&lt;!-- 配置以find开头的方法--&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!--3.配置AOP切面--&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* it.test.service.impl.*.*(..))"/&gt;&lt;!--3.1建立事务通知和切入点表达式的联系--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; AccountDao12345678910111213141516171819202122/** * 实现类 继承JdbcDaoSupport */public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; @Override public List&lt;Account&gt; findAll() &#123; return getJdbcTemplate().query("select * from spring_account",new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); &#125; @Override public Account findByName(String name) &#123; String sql ="select * from spring_account where name = ?"; Account account = getJdbcTemplate().query(sql,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),name).get(0); return account; &#125; @Override public void update(Account account) &#123; String sql ="update spring_account set money = ? where id = ?"; getJdbcTemplate().update(sql,account.getMoney(),account.getId()); &#125;&#125; AccountService1234567891011121314151617181920212223242526272829303132333435363738394041public class AccountServiceImpl implements AccountService &#123;// set注入 private AccountDao dao; public void setDao(AccountDao dao) &#123; this.dao = dao; &#125; @Override public List&lt;Account&gt; findAll() &#123; return dao.findAll(); &#125; /** * 每天都是单独的事务控制 进行操作 出现问题没有办法没有办法回滚 * 所以开启手动提交 * 为线程安全问题 为每个线程指定单独的connection对象 * @param fromName * @param toName * @param money */ @Override public void transferByName(String fromName, String toName, double money) &#123;// 1.查询转账用户名字 Account fromUser= dao.findByName(fromName);// 2.查询接收用户名字 Account toUser = dao.findByName(toName);// 3.转账用户减钱 fromUser.setMoney(fromUser.getMoney()-money);// 4.接收用户加钱 toUser.setMoney(toUser.getMoney()+money);// 5.更新转账用户 dao.update(fromUser); int i =1/0;// 6.更新接收用户 dao.update(toUser); &#125;&#125; Test12345678910111213141516171819202122@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:bean.xml")public class Test &#123; @Autowired private AccountService accountService; @org.junit.Test public void accountTest() &#123; List&lt;Account&gt; accountList = accountService.findAll(); for (Account account : accountList) &#123; System.out.println(account); &#125; &#125; @org.junit.Test public void accountTest1() &#123; accountService.transferByName("于松江", "程泽琪", 200); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 8.SpringAOP注解开发&JDBCTemplate]]></title>
    <url>%2F2019%2F05%2F13%2FSpring-8.SpringAOP%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[SpringAOP注解开发如果使用SpringAOP注解通知 则使用环绕通知一般情况下 最终通知会优先于后置通知先执行 是一种错误最好使用XML配置 LogFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 模拟日志功能 并通过aop xml配置添加前置通知 */@Component("log")@Aspect //表示当前为切面类public class LogFactory &#123; @Pointcut("execution(* it.test.service.impl.*.*(..))") public void log()&#123;&#125; @Before("log()") public void beforePrintLog() &#123; System.out.println("前置通知日志信息开始记录："); &#125; @AfterReturning("log()") public void afterReturningPrintLog() &#123; System.out.println("后置通知日志信息开始记录："); &#125; @AfterThrowing("log()") public void afterThrowingPrintLog() &#123; System.out.println("异常通知日志信息开始记录："); &#125; @After("log()") public void afterPrintLog() &#123; System.out.println("最终通知日志信息开始记录："); &#125; /** * 类似于动态代理的方式手动实现通知配置 * 通知方法可以换成上面的方法 * * @param point * @return */ public Object aroundPrintLog(ProceedingJoinPoint point) &#123; Object revalue = null; Object[] args = point.getArgs();//获取方法参数 try &#123; System.out.println("前置通知"); revalue = point.proceed(args); //切入点方法运行 System.out.println("后置通知"); &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125; finally &#123; System.out.println("最终通知"); &#125; return revalue; &#125;&#125; AccountServiceImpl123456789101112131415161718@Service("accountService")public class AccountServiceImpl implements AccountService &#123; @Override public void updateAccount(int i) &#123; System.out.println("更新了账户"+i); &#125; @Override public void findAll() &#123; System.out.println("查询到了所有账户"); &#125; @Override public int count() &#123; System.out.println("查询到了a条记录"); return 0; &#125;&#125; bean.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; JDBCTemplate数据库连接池工具此文中使用的数据库连接池DriverManagerDataSource为Spring内置连接池技术需要加载的类为 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; JdbcDaoSupportdao层如果有多个文件处理 则需要整合重复代码public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao当类继承jdbcDaoSupport则可以使用其内部方法 123&lt;bean id="accountDao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; 当我们为相应子类注入时 因为是继承关系 所以自动调用父类方法进行注入获取到JDBCTemplate实例我们也可以直接注入DataSource 在该里中也存在如下方法 123456public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; 所谓如果使用xml的方法配置文件 我们可以通过这种方法提高复用 pom.xml1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ### bean.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; AccountDaoImpl1234567891011public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; @Override public List&lt;Account&gt; findByName(String name) &#123; System.out.println(super.getDataSource()); List&lt;Account&gt; accountList = super.getJdbcTemplate().query("select * from spring_account where name like ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), "%" + name + "%"); return accountList; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 7.Spring面向切面编程AOP]]></title>
    <url>%2F2019%2F05%2F11%2FSpring-7.Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP%2F</url>
    <content type="text"><![CDATA[** 单独配置环绕配置 或者组合配置 ** AOP编程术语 连接点 ：业务层与增强方法中共同拥有的方法 即业务层实现的方法 切入点 ：被增强过的方法。（如果一个方法没有被增强过。过程 产生结果均相同 则不是切入点） 通知 ：业务层的公共方法 进行封装 统一处理成为通知（例如：事务操作类就是通知 将所有事务操作方法提取出来 封装成 ServiceFactory类进行处理） 环绕通知：动态代理中invoke方法实现的就是环绕通知 通知种类：按照环绕通知中明确的切入点调用划分 （执行操作方法method.invoke(dao, args)） 前置通知：代理方法中执行前的通知方法 （例如开启手动提交） 后置通知：代理方法执行后的通知方法（例如提交事务） 异常通知：代理方法出现异常时进行的通知方法 （例如回滚事务） 最终通知：无论代理方法是否正常执行都会执行的通知方法 (connection释放资源) 目标对象：被代理的对象 AOP两个阶段 1. 开发阶段 编写核心业务代码(开发主线) 要求熟悉业务需求 把公用代码抽取出来，做成通知（开发阶段后期操作） 在配置文件中 声明切入点和通知的关系 即切面 ** 2.运行阶段（Spring框架完成）** Spring框架监控切入点的方法执行。一旦监控到切入点方法被执行 使用代理机制 动态创建目标对象的代理对象，根据通知种类，在代理对象的对应位置 将通知对应功能织入 完成完整代码逻辑 SpringAOP XML配置标签 把通知对象交给Spring进行管理1&lt;bean id="logFactory" class="it.test.factory.LogFactory"&gt;&lt;/bean&gt; ** 以下标签均为嵌套使用 ** 使用aop:config 标签表明开始配置AOP 使用aop:aspect标签表明配置切面 id属性：给切面提供唯一标识 ref属性：提供切面的通知对象实例 四种标签对应四种通知种类 aop:before 前置通知 aop:after-returning 后置通知 aop:after-throwing 异常通知 aop:after 最终通知 四种标签内部值：(以前置通知为例)method：用于指定通知对象实例中哪个方法作为前置通知 pointcut切入点表达式及其配置12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; 以上代码可以解析切入点表达式pointcut：指定切入点表达式 该表达式含义是指对业务成哪些方法进行增强 格式为execution（关键字 返回值 全类名.方法名(参数类型)）标准表达式:public void it.test.service.AccountService.findAll()省略形式： 关键字可以省略 返回值可以使用*作为通配符代替 包名可以用*.表示一级包的通配*..表示当前包及其子包通配 类名和方法名可以用 * 通配 参数列表 基础类名可以直接写名称int 全类名写引用类型java.jang.String 可以使用(..)表示任意类型有无参数 * 实际应用 切换到业务层实现所有方法 ** ` it.test.service.impl..(..)` 例： 1&lt;aop:before method="printLog" pointcut="execution( public void it.test.service.AccountService.findAll())"&gt;&lt;/aop:before&gt; 当出现多条通知时 可以在aop:aspect配置 作用于为当前切面 1&lt;aop:pointcut id="service" expression="execution(* it.test.service.impl.*.*(..)))"/&gt; 并通过pointcut-ref引入 1&lt;aop:after method="afterPrintLog" pointcut-ref="service"&gt;&lt;/aop:after&gt; ** 如果向作用于整个aop 将aop:pointcut写在所有aop:aspect之前 ** 环绕通知 aop：around 当我们配置环绕通知以后 切入点方法没有执行 环绕通知执行了 通过对比动态代理中的环绕通知代码 发现其中存在切入点方法的调用 而我们的配置中没有 解决：将ProceedingJoinPoint作为参数传入环绕方法中。该接口有一个方法proceed();此方法就相当于明确切入点方法 程序执行时 Spring框架会为我们提供此接口的实现类使用 12345678910111213141516171819202122/** * 类似于动态代理的方式手动实现通知配置 * 通知方法可以换成上面的方法 * @param point * @return */public Object aroundPrintLog(ProceedingJoinPoint point)&#123; Object revalue =null; Object[] args = point.getArgs();//获取方法参数 try &#123; System.out.println("前置通知"); revalue = point.proceed(args); //切入点方法运行 System.out.println("后置通知"); &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; return revalue; &#125; pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day05_SpringAop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 解析切入点表达式配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt; junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; bean.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 创建AccountServiceImpl对象--&gt; &lt;bean id="accountService" class="it.test.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt; &lt;!-- 创建logFactory对象--&gt; &lt;bean id="logFactory" class="it.test.factory.LogFactory"&gt;&lt;/bean&gt; &lt;!--配置切面 指定通知和切入点之间的关系--&gt; &lt;aop:config&gt; &lt;!-- 指定通过哪个类中方法配置通知 并命名--&gt; &lt;aop:aspect id="log" ref="logFactory"&gt; &lt;!-- 配置前置通知方法 指定切入点(要增强的方法)--&gt; &lt;!-- &lt;aop:before method="printLog" pointcut="execution( public void it.test.service.AccountService.findAll())"&gt;&lt;/aop:before&gt;--&gt; &lt;!-- 前置通知--&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="service"&gt;&lt;/aop:before&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after-returning method="afterReturningPrintLog" pointcut-ref="service"&gt;&lt;/aop:after-returning&gt; &lt;!-- 异常通知--&gt; &lt;aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="service"&gt;&lt;/aop:after-throwing&gt; &lt;!-- 最终通知 --&gt; &lt;aop:after method="afterPrintLog" pointcut-ref="service"&gt;&lt;/aop:after&gt; &lt;aop:around method="aroundPrintLog" pointcut-ref="service"&gt;&lt;/aop:around&gt;&lt;!-- 整合pointcut--&gt; &lt;aop:pointcut id="service" expression="execution(* it.test.service.impl.*.*(..)))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; AccountServiceImpl123456789101112131415161718192021package it.test.service.impl;import it.test.service.AccountService;public class AccountServiceImpl implements AccountService &#123; @Override public void updateAccount(int i) &#123; System.out.println("更新了账户"+i); &#125; @Override public void findAll() &#123; System.out.println("查询到了所有账户"); &#125; @Override public int count() &#123; System.out.println("查询到了a条记录"); return 0; &#125;&#125; LogFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445 package it.test.factory;import org.aspectj.lang.ProceedingJoinPoint;/** * 模拟日志功能 并通过aop xml配置添加前置通知 */public class LogFactory &#123; public void beforePrintLog()&#123; System.out.println("前置通知日志信息开始记录："); &#125; public void afterReturningPrintLog()&#123; System.out.println("后置通知日志信息开始记录："); &#125; public void afterThrowingPrintLog()&#123; System.out.println("异常通知日志信息开始记录："); &#125; public void afterPrintLog()&#123; System.out.println("最终通知日志信息开始记录："); &#125; /** * 类似于动态代理的方式手动实现通知配置 * 通知方法可以换成上面的方法 * @param point * @return */ public Object aroundPrintLog(ProceedingJoinPoint point)&#123; Object revalue =null; Object[] args = point.getArgs();//获取方法参数 try &#123; System.out.println("前置通知"); revalue = point.proceed(args); //切入点方法运行 System.out.println("后置通知"); &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); throwable.printStackTrace(); &#125;finally &#123; System.out.println("最终通知"); &#125; return revalue; &#125;&#125; Test1234567891011121314151617import it.test.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; @org.junit.Test public void test1() &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("bean.xml"); AccountService service = ac.getBean("accountService", AccountService.class); service.findAll(); System.out.println("----------------------"); service.count(); System.out.println("----------------------"); service.updateAccount(1); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 5.Spring案例注解]]></title>
    <url>%2F2019%2F05%2F09%2FSpring-5.Spring%E6%A1%88%E4%BE%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[案例需求 使用Spring开发Dao层 Service层 实现数据库功能 需要dbunits c3p0 spring-test 注解配置不需要通过set方法 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day03_Spring案例注解&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt; mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; UserTest.java 应用程序的入口：main方法junit单元测试中 没有main方法也能执行该方法就会判断当前测试类中哪些方法有@Test注解junit就让有注解的方法执行 Spring 整合junit配置 导入spring整合junit的jar 使用Junit提供的一个注解把原main方法替换改成Spring提供的注解：@Runwith:替换main方法提供@ContextConfiguration：告知Spring运行器 Springioc基于xml还是注解配置并且无需通过代码指定注入文件locations：指定xml文件位置 加上classpath表示在类路径下classes：指定注解位置 12345678910111213141516171819202122232425@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class UserTest &#123; @Autowired UserServiceImpl service=null; @Test public void findAll() &#123;// ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);// service = ac.getBean("userService", UserServiceImpl.class); List&lt;User&gt; userList = service.findAll(); for (User user : userList) &#123; System.out.println(user); &#125; &#125; @Test public void findOne() &#123;// ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);// service = ac.getBean("userService", UserServiceImpl.class); User one = service.findOne(51); System.out.println(one); &#125;&#125; configSpringConfiguration该类是配置类 作用和bean.xml效果一样 @Configuration:指定该文件是一个配置类 被注解的类作为AnnotationConfigApplicationContext对象创建参数时 该注解可以不写@ComponentScan：spring创建容器时要扫描的范围 basePackages和value一样就是配置扫描范围@Bean:用于把当前方法的返回值作为bean对象存入spring容器中 不存入容器无法注入name默认为当前方法名会查找是否有相关属性的配置 如果出现多个则按照方法名和name名是否匹配查找@Import:用于导入其他的配置类 作为被该注解修饰类的子配置类@Qualifier:在方法参数时可以直接使用 指定匹配的id 1234567@Configuration@ComponentScan(basePackages = "it.test")@Import(value = JdbcConfig.class)@PropertySource(value = "classpath:jdbc.properties")public class SpringConfiguration &#123;&#125; jdbcConfig** @Value:**:将数据库的值通过EL表达式形式注入 (普通类型 String类型) 12345678910111213141516171819202122232425262728293031public class JdbcConfig &#123;// @Value将数据库的值通过EL表达式形式注入 (普通类型 String类型) @Value("$&#123;driver&#125;") private String driver; @Value("$&#123;url&#125;") private String url; @Value("$&#123;user&#125;") private String user; @Value("$&#123;password&#125;") private String passWord; // 为保证线程安全 数据库连接池创建多例对象 每个线程独有 @Bean(name = "queryRunner") //返回结果值到Spring容器 连接UserDaoImpl @Scope(value = "prototype") public QueryRunner getQueryRunner(@Qualifier(value = "dataSource") DataSource dataSource) &#123; return new QueryRunner(dataSource); &#125; @Bean(name = "dataSource") public DataSource getDataSoure() &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); try &#123; ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(user); ds.setPassword(passWord); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; return ds; &#125;&#125; Dao层UserDao12345public interface UserDao &#123; List&lt;User&gt; findAll(); User findOne(int id);&#125; UserDaoImpl12345678910111213141516171819202122232425262728293031@Repository("userDao")public class UserDaoImpl implements UserDao &#123;// 通过JdbcConfig文件创建的Spring容器中的实例注入 @Resource(name = "queryRunner") private QueryRunner queryRunner; /* public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125;*/ @Override public List&lt;User&gt; findAll() &#123; try &#123; return queryRunner.query("select * from user", new BeanListHandler&lt;User&gt;(User.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; public User findOne(int id) &#123; try &#123; return queryRunner.query("select * from user where id = ?", new BeanHandler&lt;User&gt;(User.class), id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; Service层UserService1234public interface UserService &#123; List&lt;User&gt; findAll(); User findOne(int id);&#125; UserServiceImpl123456789101112131415161718192021222324252627@Service(value = "userService")public class UserServiceImpl implements UserService &#123; /** * 自动注入 * @Autowired：注入默认 默认为bean对象类名首字母小写 * 将id为userDao的userDao类注入 * */ @Resource(name = "userDao") private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public List&lt;User&gt; findAll() &#123; return userDao.findAll(); &#125; public User findOne(int id) &#123; return userDao.findOne(id); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 6.Spring银行案例事务处理]]></title>
    <url>%2F2019%2F05%2F09%2FSpring-6.Spring%E9%93%B6%E8%A1%8C%E6%A1%88%E4%BE%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[** connection 存在多线程安全问题 如果为单例对象 那么事务操作 一个线程开启事务 一个线程提交 会造成结果影响** ** 连接工具类：实现数据源中获取一个连接 并实现和线程绑定Spring通过ThreadLocal将现有状态的变量（如Connection等）本地线程化， 达到另一个层面是的“线程无关”，从而实现线程安全。** 动态代理 在不修改源码的基础上对方法进行增强 基于接口的动态代理 import java.lang.reflect.Proxy; 顾客通过代理商购买厂商产品 12345678910111213141516171819202122232425262728293031 /** * 买产品 */public class Buyer &#123; public static void main(String[] args) &#123; /** 动态代理：不修改源码的情况下对方法进行增强 */ final ProducerImpl producerImpl = new ProducerImpl();// 需要用其接口类型接收 Producer newProducer = (Producer) Proxy.newProxyInstance( producerImpl.getClass().getClassLoader(), producerImpl.getClass().getInterfaces(), new InvocationHandler() &#123; Object invoke = null; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; double money = (double) args[0]; if ("sell".equals(method.getName())) &#123;// 方法调用需要被代理类对象 和方法参数 invoke = method.invoke(producerImpl, money * 0.8); &#125; return invoke; &#125; &#125;);// 调用代理对象方法实现功能 newProducer.sell(10000); &#125;&#125; Producer接口 1234public interface Producer &#123; void sell(double money);&#125; 实现类 123456 public class ProducerImpl implements Producer &#123; @Override public void sell(double money) &#123; System.out.println("厂商销售 获取："+money); &#125;&#125; 事务分析12345678910111213141516 @Override public void transferByName(String fromName, String toName, double money) &#123;// 1.查询转账用户名字 Account fromUser= dao.findByName(fromName);// 2.查询接收用户名字 Account toUser = dao.findByName(toName);// 3.转账用户减钱 fromUser.setMoney(fromUser.getMoney()-money);// 4.接收用户加钱 toUser.setMoney(toUser.getMoney()+money);// 5.更新转账用户 dao.update(fromUser); int i =1/0;// 6.更新接收用户 dao.update(toUser); &#125; 如代码所示 如果转账操作中出现错误 那不利用事务回滚会造成 数据不准确 而为了数据安全 我们将dbuntils声明为 多例对象 此时运行每一个功能，产生多个connection 即使开启手动提交事务 也无法回滚。 所以此时我们应将同一线程下保持相同的connection对象,即多个功能方法使用的同一个connection对象 可以回滚事务。即通过ThreadLocal&lt;connectnion&gt;来获取连接对象 保证了同一线程的唯一性 ConnectionUtils工具类获取connection封装到本地线程中 并对清除jdbc资源事务的对象提供解绑功能 并重新获取 123456789101112131415161718192021222324252627282930313233343536373839/** * 连接工具类：实现数据源中获取一个连接 并实现和线程绑定 * Spring通过ThreadLocal将现有状态的变量（如Connection等）本地线程化， * 达到另一个层面是的“线程无关”，从而实现线程安全。 */public class ConnectionUtils &#123; private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;();// c3p0获取数据库连接池 private DataSource dataSource; public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; // 获取当前线程上的连接 public Connection getConnection() &#123; Connection connection = threadLocal.get(); if (connection == null) &#123;// 如果为null则从数据库连接池中获取一个连接 try &#123;// 获取connection 将connection加入ThreadLocal connection = dataSource.getConnection(); threadLocal.set(connection); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return connection; &#125; public void close() &#123;// 解绑已经close掉的connection对象 重新获取 threadLocal.remove(); &#125;&#125; TransactionManager事务管理工具类管理事务 通过ConnectionUtils方法获取当前线程上的connection 并通过获取到的connection管理当前线程上的事务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TransactionManager &#123; private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 开启事务 */ public void beginTransaction() &#123; try &#123; connectionUtils.getConnection().setAutoCommit(false); System.out.println("开启手动提交"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 回滚事务 */ public void rollBack() &#123; try &#123; connectionUtils.getConnection().rollback(); System.out.println("回滚事务"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ public void commit() &#123; try &#123; connectionUtils.getConnection().commit(); System.out.println("提交事务"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 释放资源 */ public void release() &#123; try &#123;// 关闭以后 线程上还有连接 只不过该connection对象已经被放回连接池中了(消除事务和jdbc连接) 无法使用了// 所以需要解除绑定 重新从连接池中获取一个存在jdbc连接的connection对象 connectionUtils.getConnection().close(); connectionUtils.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; serviceFactory 动态代理增强service方法增强accountService类中的每一个方法该类中提供getAccountService返回增强后的类实例为每一个原类中的方法提供事务控制 并返回新的proxyAccountService进行实例调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class serviceFactory &#123; /** * 注入 */ private AccountService dao; private TransactionManager tm; public void setTm(TransactionManager tm) &#123; this.tm = tm; &#125; public final void setDao(AccountService dao) &#123; this.dao = dao; &#125; public AccountService getAccountService() &#123; return (AccountService) Proxy.newProxyInstance(dao.getClass().getClassLoader(), dao.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// 开启事务 Object invoke = null; try &#123;// 开启手动提交 tm.beginTransaction();// 执行操作 System.out.println("运行方法名为："+method.getName()); invoke = method.invoke(dao, args);// 提交事务 tm.commit();// 返回结果 return invoke; &#125; catch (Exception e) &#123;// 回滚事务 tm.rollBack(); throw new RuntimeException(e); &#125; finally &#123;// 释放连接 tm.release(); &#125; &#125; &#125;); &#125;&#125; AccountDaoImpl 去除原来queryRunner中的connection为每一个功能手动添加同一线程下的connection方法 保证多个功能使用同一数据库连接 才能回滚 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class AccountDaoImpl implements AccountDao &#123; //set注入 private QueryRunner queryRunner; private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; @Override public List&lt;Account&gt; findAll() &#123; try &#123; return queryRunner.query(connectionUtils.getConnection(),"select * from spring_account", new BeanListHandler&lt;Account&gt;(Account.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override public Account findByName(String name) &#123; String sql="select * from spring_account where name = ?"; List&lt;Account&gt; accountList = null; try &#123; accountList = queryRunner.query(connectionUtils.getConnection(),sql, new BeanListHandler&lt;Account&gt;(Account.class), name); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; if (accountList==null ||accountList.size()==0)&#123; return null; &#125; if (accountList.size()&gt;1)&#123; throw new RuntimeException("结果不唯一"); &#125; Account account = accountList.get(0); return account; &#125; @Override public void update(Account account) &#123; try &#123; queryRunner.update(connectionUtils.getConnection(),"update spring_account set money = ? where id = ?", account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Test为方法指定增强后的service实例 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations ="classpath:bean.xml" )public class AccountTest &#123; @Qualifier("proxyAccountService") @Autowired private AccountService service = null; @Test public void findAll()&#123; List&lt;Account&gt; accounts = service.findAll(); for (Account account : accounts) &#123; System.out.println(account); &#125; &#125; @Test public void transferByName()&#123; service.transferByName("于松江","程泽琪",500); &#125;&#125; bean.xml部署类实例创建和相关注入 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;!-- 由工厂方法提供新的accountService对象--&gt; &lt;bean id="proxyAccountService" factory-bean="serviceFactory" factory-method="getAccountService"&gt;&lt;/bean&gt; &lt;bean id="accountService" class="it.test.service.impl.AccountServiceImpl"&gt; &lt;property name="dao" ref="dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="dao" class="it.test.dao.impl.AccountDaoImpl"&gt; &lt;property name="queryRunner" ref="queryRunner"&gt;&lt;/property&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="connectionUtils" class="it.test.utils.ConnectionUtils"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="it.test.utils.TransactionManager"&gt; &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="serviceFactory" class="it.test.factory.serviceFactory"&gt; &lt;property name="dao" ref="accountService"&gt;&lt;/property&gt; &lt;property name="tm" ref="transactionManager"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;It.test&lt;/groupId&gt; &lt;artifactId&gt;Day04_Spring事务&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 4.Spring案例XML]]></title>
    <url>%2F2019%2F05%2F09%2FSpring-4.Spring%E6%A1%88%E4%BE%8BXML%2F</url>
    <content type="text"><![CDATA[案例需求 使用Spring开发Dao层 Service层 实现数据库功能 需要dbunits c3p0 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day03_Spring案例&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;!-- Spring框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt; 5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; UserTest.java1234567891011121314public class UserTest &#123; @Test public void findAll() &#123;// 扫描bean.xml 创建所需实体类对象 并载入Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");// 获取Spring容器中的UserServiceImpl UserServiceImpl service = ac.getBean("userService", UserServiceImpl.class); List&lt;User&gt; userList = service.findAll(); for (User user : userList) &#123; System.out.println(user); &#125; &#125;&#125; Bean.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=&quot;dateSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置queryRunner--&gt; &lt;bean id=&quot;queryRunner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot;&gt; &lt;!-- 注入数据源--&gt; &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dateSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;it.test.dao.impl.UserDaoImpl&quot;&gt;&lt;!-- 创建数据库连接池--&gt; &lt;property name=&quot;queryRunner&quot; ref=&quot;queryRunner&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;it.test.service.impl.UserServiceImpl&quot;&gt;&lt;!-- 创建该类所需要的UserDaoImpl对象--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Dao层UserDao.java1234public interface UserDao &#123; List&lt;User&gt; findAll();&#125; UserDaoImpl.java1234567891011121314151617public class UserDaoImpl implements UserDao &#123;// bean.xml 通过set注入实体类 private QueryRunner queryRunner; public void setQueryRunner(QueryRunner queryRunner) &#123; this.queryRunner = queryRunner; &#125; public List&lt;User&gt; findAll() &#123; try &#123; return queryRunner.query("select * from user",new BeanListHandler&lt;User&gt;(User.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; Service层UserService123public interface UserService &#123; List&lt;User&gt; findAll();&#125; UserServiceImpl1234567891011121314151617public class UserServiceImpl implements UserService &#123; private UserDao userDao; /** * Spring配置userDao方法 * * @param userDao */ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public List&lt;User&gt; findAll() &#123; return userDao.findAll(); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 1.Spring入门思想 Bean]]></title>
    <url>%2F2019%2F05%2F06%2FSpring%201.Spring%E5%85%A5%E9%97%A8%E6%80%9D%E6%83%B3%20Bean%2F</url>
    <content type="text"><![CDATA[Spring 体系结构Spring简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ![](https://i.loli.net/2019/05/06/5ccfe88cdd826.png) Core Container Spring核心容器 IOC 耦合耦合：类或者方法之间存在编译依赖数据库连接：DriverManager.registerDriver(new com.mysql.jdbc.Driver())如果不添加驱动 则会报出编译时异常 证明了类之间的依赖关系很大如果使用Class.forName()注册驱动 则可以降低程序间耦合 解耦解耦思想： ** 降低程序间的依赖关系** 实际开发中应做到：*编译期不依赖 运行期依赖 *类之间耦合通过反射来创建对象 避免出现new关键字通过读取配置文件来获取创建的对象的全限定类名 在之间的旅游网项目中 三层架构的逻辑处理方式 界面层 通过new调用 业务逻辑层 业务逻辑层 通过new调用 数据访问层 存在类之间的耦合 解耦方法 模拟Spring 通过工厂模式 解耦 在静态代码块中完成创建properties 通过获取键值对将 每一个对象创建出来并将名称和实例存储到准备好的Map&lt;String,Object&gt;集合中 通过getInstance(String s)方法获取到调用者需要的key将value 即已保存好的实例返回给外界调用者保证了调用者调用的是唯一的实例化对象 （单例）单例存在线程问题 所以尽量不要定义类成员变量 Bean：在计算机英语中 有可重用组件的含义 IOC控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。 作用： 削减计算机程序的耦合（解除我们代码中的依赖关系） pom.xml 配置spring-context spring配置文件标题 查看 Spring FrameWork官方文档 core中的xmlns123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt; 类视图： 核心容器的两个接口引发的问题： ApplicationContext： 单例对象适用他在构建核心容器时，创建对象采取的策略是采取立即加载的形式。也就是说只要一读取完配置文件马上就常见配置文件中配置的对象 BeanFactory：多例对象适用他在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说什么时候根据id获取对象 什么时候创建对象 ApplicationContext的三个常用实现类： ClassPathXmlApplicationContext:可以加载类路径下的配置文件要求配置文件必须在类路径下 FileSystemXmlApplicationContext：可以加载磁盘任意路径下的配置文件（需要有访问权限） AnnotationConfigApplicationContext：用于读取注解创建的容器 获取对象的三种配置 默认构造函数配置 123&lt;!-- 默认构造函数配置 即无参构造函数--&gt;&lt;bean id="UserServiceImpl" class="it.test.service.impl.UserServiceImpl"&gt;&lt;/bean&gt; 工厂方法获取配置 12345 &lt;!-- 使用普通工厂中的方法创建对象(使用某个类中的方法创建并存入Spring容器) factory-bean 工厂来源 factory-method工厂方法--&gt; &lt;bean id="UserServiceFactory" class="it.test.factory.UserServiceFactory"&gt;&lt;/bean&gt; &lt;bean id="getUserServiceImpl" factory-bean="UserServiceFactory" factory-method="getUserServiceImpl"&gt;&lt;/bean&gt; 静态工厂方法获取配置 123&lt;!--静态工厂方法创建对象--&gt; &lt;bean id="getUserServiceImpl" class="it.test.factory.StaitcUserServiceFactory" factory-method="getUserServiceImpl"&gt;&lt;/bean&gt; 程序：UserServlet 12345678910111213public class UserServlet &#123; public static void main(String[] args) &#123; ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml");// 获取实例方式 二选一 UserService userService = (UserServiceImpl) ac.getBean("getUserServiceImpl");// UserServiceImpl userServiceImpl1 = ac.getBean("UserServiceImpl", UserServiceImpl.class); userService.getUser(); String s="Java程序员"; System.out.println(s.getBytes().length); &#125;&#125; UserService 12345678package it.test.service;public interface UserService &#123; /** * 模拟获取User(); */ void getUser();&#125; UserServiceImpl 12345678910111213package it.test.service.impl;import it.test.service.UserService;public class UserServiceImpl implements UserService &#123; public UserServiceImpl() &#123; System.out.println("UserServiceImpl方法被创建了"); &#125; public void getUser() &#123; System.out.println("获取User"); &#125;&#125; UserServiceFactory 123456789101112package it.test.factory;import it.test.service.impl.UserServiceImpl;/** * 模拟工厂模式获取UserServiceImpl jar中方法 不可更改 */public class UserServiceFactory &#123; public UserServiceImpl getUserServiceImpl()&#123; return new UserServiceImpl(); &#125;&#125; StaitcUserServiceFactory 123456789101112package it.test.factory;import it.test.service.impl.UserServiceImpl;/** * 模拟工厂模式静态获取UserServiceImpl jar中方法 不可更改 */public class StaitcUserServiceFactory &#123; public static UserServiceImpl getUserServiceImpl()&#123; return new UserServiceImpl(); &#125;&#125; Bean标签作用范围bean标签的scope属性 作用：指定bean作用范围 取值：常用单例多例 singleton(单例模式 默认值) prototype 多例 不调用不创建 request web项目的请求 session web项目会话范围 global-session 作用于集群环境的会话技术(全局会话技术) 不是集群环境是 为session1&lt;bean id="UserServiceImpl" class="it.test.service.impl.UserServiceImpl" scope="prototype"&gt;&lt;/bean&gt; 123UserService userService1 = (UserServiceImpl) ac.getBean("UserServiceImpl"); UserService userService2 = ac.getBean("UserServiceImpl", UserServiceImpl.class); userService1.getUser(); System.out.println(userService1==userService2); 最后结果为 创建两个对象 Bean对象声明周期bean标签下可以使用init-method destroy-method开启 生成对象时调用方法 销毁对象时调用方法 ApplicationContext没有关闭容器方法 其子类ClassPathXmlApplicationContext有 单例对象 出生：当核心容器创建时对象出生 活着：当核心容器还在 对象就一直活着 死亡：容器销毁 对象消亡 总结：单例对象的生命周期和容器相同 多例对象 出生：使用对象时spring为我们创建 活着：对象只要是在使用过程中就一直活着 死亡：java垃圾回收]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 3.Spring注解开发]]></title>
    <url>%2F2019%2F05%2F06%2FSpring-3.Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[@Component用于将当前类实例存储到Spring容器中 value 值为xml文件中bean的id 如果不配置默认为类名首字母小写 @Controller:用于表现层 @Service：用于业务层 @Repository：用于持久层 以上三个注解和@Component 一样 用于三层架构的每一层 @Autowired 自动类型注入 会查询Spring容器中的值(容器以Map形式封装数据)进行连接 如果发现值有相同时 在查找和变量名相同的键值 图解： @Qualifier 确定注入的对象 (不能单独工作需要和Autowired一起) 单独使用时可以指定@Bean对应id @Resource 可以使用 @Resource(name = “userDao1”) 指定bean的id 需要配置 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt; javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 以上三个注入只能注入其他bean类型的数据 基本类型String不法使用 集合类型只能通过xml实现 @Value 可以添加基本数据类型的值 @Scopevalue改变作用范围 单例多例 代码pom.xml 12345678910111213141516&lt;groupId&gt;it.test&lt;/groupId&gt; &lt;artifactId&gt;Day02_Spring常用注解&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt; javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; bean.xml 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置所需要的标签不是在beans的约束中在名为context名称空间和约束中 context:component-scan 告知Spring在创建容器时要扫描的包--&gt; &lt;context:component-scan base-package="it.test"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; UserServlet 1234567891011public class UserServlet &#123; public static void main(String[] args) &#123; ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml");// 获取实例方式 二选一 UserService userService = ac.getBean("userServiceImpl", UserServiceImpl.class); userService.getUser(); &#125;&#125; UserServiceImpl 12345678910111213141516171819202122232425package it.test.service.impl;import it.test.dao.UserDao;import it.test.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.ImportResource;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component@Scope(value = "singleton")public class UserServiceImpl implements UserService &#123;// @Autowired //自动类型注入// @Qualifier("userDao2") @Resource(name = "userDao1") private UserDao dao = null; public void getUser() &#123; dao.getUser(); &#125;&#125; UserService 123456public interface UserService &#123; /** * 模拟获取User(); */ void getUser();&#125; UserDao 123public interface UserDao &#123; void getUser();&#125; UserDaoImpl 12345678910import it.test.dao.UserDao;import org.springframework.stereotype.Component;@Component("userDao1")public class UserDaoImpl implements UserDao &#123; public void getUser() &#123; System.out.println("UserDaoImpl获取User"); &#125;&#125; UserDaoImpl2 12345678910import it.test.dao.UserDao;import org.springframework.stereotype.Component;@Component("userDao2")public class UserDaoImpl2 implements UserDao &#123; public void getUser() &#123; System.out.println("UserDaoImpl2获取User"); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 2.Spring注入]]></title>
    <url>%2F2019%2F05%2F06%2FSpring-2.Spring%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Spring注入在反射实例化时调用方法(构造方法 或者set方法赋值) 构造函数注入 构造函数注入： 使用标签：constructor-arg 标签出现的位置 bean标签内部 标签中属性： type:指定要注入的数据类型 该类型也是构造函数中某个或者某些参数类型 index：指定注入数据的索引从0开始 name：用于给构造函数中指定名称的参数赋值(构造函数形参 不是属性) value：基本数据类型 和String类型 ref：用于指定其他bean类型数据 指定在springIOC容器中出现过的bean对象 123456789private String name;private int age;private Date birthday;public UserServiceImpl(String name, int age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday;&#125; xml配置 1234567&lt;bean id="birthday" class="java.util.Date"&gt;&lt;/bean&gt;&lt;bean id="UserServiceImpl" class="it.test.service.impl.UserServiceImpl"&gt; &lt;constructor-arg name="name" value="瓜皮"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="13"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="birthday"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 结果： set注入set注入 使用标签：property 标签出现的位置：bean标签内部 标签中属性： name：用于set方法属性 (不是成员变量) value：基本数据类型 和String类型 ref：用于指定其他bean类型数据 指定在springIOC容器中出现过的bean对象 优势：可以调用空参构造函数劣势: 可能存在调用默认构造函数时 对象已经用完销毁没有注入xml 1234567&lt;bean id="birthday" class="java.util.Date"&gt;&lt;/bean&gt; &lt;bean id="UserServiceImpl2" class="it.test.service.impl.UserServiceImpl2"&gt; &lt;property name="name" value="程大傻"&gt;&lt;/property&gt; &lt;property name="age" value="15"&gt;&lt;/property&gt; &lt;property name="birthday" ref="birthday"&gt;&lt;/property&gt; &lt;/bean&gt; UserServiceImpl2 1234567891011121314private String name; private int age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; 结果： 集合注入同结构集合 标签可以互换 12345678910111213141516171819202122232425262728293031323334private String[] myArray; private List&lt;String&gt; myList; private Set&lt;Date&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProperties; public void setMyArray(String[] myArray) &#123; this.myArray = myArray; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;Date&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProperties(Properties myProperties) &#123; this.myProperties = myProperties; &#125; public void getUser() &#123; System.out.println(Arrays.toString(myArray)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProperties); &#125; xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;/bean&gt; &lt;bean id="UserServiceImpl3" class="it.test.service.impl.UserServiceImpl3"&gt; &lt;property name="myArray"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="myList"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="mySet"&gt; &lt;set&gt; &lt;ref bean="birthday"&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="myMap"&gt; &lt;map&gt; &lt;entry key="aaa" value="bbbb"&gt;&lt;/entry&gt; &lt;entry key="ccc" value="dddd"&gt;&lt;/entry&gt; &lt;entry key="eee" value="ffff"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="myProperties"&gt; &lt;props&gt; &lt;prop key="aaa"&gt;bbb&lt;/prop&gt; &lt;prop key="ccc"&gt;bbb&lt;/prop&gt; &lt;prop key="ddd"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 结果：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 6.Mybatis注解开发]]></title>
    <url>%2F2019%2F05%2F06%2FMybatis-6.Mybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[注解开发补充 如果存在实体类和数据库名称不统一时 使用以下方式Results中id指定唯一标识 其他方法引用 可以使用@ResultMap引用id即可 多表查询及延迟加载延迟加载不用在主配置文件配置 FetchType中声明即可@Result注解中有one和many属性 一对一选择one 一对多选择many@one注解中有个FetchType枚举 LAZY EAGER 分别是延迟加载和立即加载column 对应通过account的哪个属性作为第二个查找方法的值select对应方法的全限定方法名 二级缓存主配置文件中进行配置 1&lt;setting name="cacheEnabled" value="true"/&gt; 通过其他方法 获取封装1234567@Select("select * from orders where id = #&#123;id&#125;") @Results(value = &#123; @Result(column = "productId",property = "product",javaType = Product.class,one = @One(select = "it.test.dao.ProductDao.findById")), @Result(column = "memberId",property = "member",javaType = Member.class,one = @One(select = "it.test.dao.MemberDao.findById")), @Result(column = "id",property = "travellers",javaType = List.class,many = @Many(select = "it.test.dao.TravellerDao.findByOrdersId")) &#125;) Orders findById(String id);]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 5.Mybatis延迟加载，缓存]]></title>
    <url>%2F2019%2F05%2F05%2FMybatis-5.Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[延迟加载与立即加载延迟加载：在真正使用数据时发起查询 不用时不查询 按需加载(懒查询)立即加载：不管用不用 调用方法时立即加载 在四种对应关系中：一对多 多对多 通常情况下采取延迟加载多对一 一对一 通常情况下使用立即加载 一对一延迟加载UserDao.xml方法中添加根据id查询信息的方法 123&lt;select id="findById" parameterType="int" resultType="user"&gt; select * from user where id =#&#123;id&#125; &lt;/select&gt; 在AccountDao.xml更改为 1234567891011121314 &lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt;&lt;!-- select 属性指定内容 查询用户的唯一标识 column 为在account表中 用户查询id所需要的值 对应account表中的uid--&gt; &lt;association property="user" column="uid" javaType="user" select="it.test.dao.UserDao.findById"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findByOneToOne" resultMap="accountUserMap"&gt; select * from account &lt;/select&gt; 此时就是立即加载 123456789public void findByOneToOne()&#123; List&lt;Account&gt; list = dao.findByOneToOne(); /* for (Account account : list) &#123; System.out.println("============================="); System.out.println(account); System.out.println(account.getUser()); &#125;*/&#125; 无论我们是否查询逐条数据 只要加载 就会全部查询在主配置文件中添加如下配置 12345 &lt;settings&gt;&lt;!-- 开启延迟加载功能 并关闭按需加载--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt; 结果为延迟加载 注释后 只运行了查询account操作 多对一和一对一方法相同UserDao.xml 1234567&lt;collection property="accounts" ofType="account" column="id" select="it.test.dao.AccountDao.findById"&gt; &lt;id property="id" column="aid"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt; Mybatis缓存概念：存在于内存中的临时数据使用缓存的原因：减少和数据库的交互次数 提高执行效率适用于缓存： 经常查询并且不经常改变的 数据的正确与否与最终结果影响不大的 不适用于缓存： 经常改变的数据 数据的正确与否对最终结果影响很大的例如 银行汇率 股市数据 Mybatis一级缓存指在Mybatis中Sqlsession对象中的缓存当我们执行查询疑惑 查询的结果会同时存入到SqlSession为我们提供一块区域中该区域的结构是一个Map 当我们再次查询同样的数据 Mybaits会先去SqlSession中查询是否有 有的话直接调用当SqlSession对象消失时,Mybatis一级缓存也会消失 通过Sqlsession创建两个对象进行查询方法两个对象相同 因为第二次从缓存中获取关闭后重新获取 对象不同 因为缓存消失调用sqlSession.clearCache();方法清空缓存效果相同 操作数据操作数据后 调用数据SqlSession的修改，添加，删除commit();提交，关闭操作时，清空一级缓存 所有重新执行Sql语句查询 Mybatis二级缓存Mybatis中SqlSessionFactory中对象的缓存 由同一个SqlSessionFactory对象创建的SqlSession共享其缓存(数据缓存) sqlSession创建新对象 但共享数据 步骤 让Mybaits框架支持二级缓存（SqlMapConfig.xml中配置）settings中设置属性cacheEnabled 为true 让当前映射文件支持二级缓存（userDao.xml中配置）&lt;Mapper&gt;标签下添加&lt;cacahe/&gt; 让当前操作支持二级缓存&lt;select&gt;标签中添加useCache=&quot;true&quot;属性 缓存效果 映射语句文件中的所有 SELECT 语句将会配缓存。映射语句文件中的所有 INSERT、UPDATE、DELETE 语句会刷新缓存。 缓存会使用 Least Recently Used （LRU，最近最少使用的）算法来回收。 根据时间表（如 no Flush Interval，没有刷新时间），缓存不会以任何时间顺序来刷新。 缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024个引用。 缓存会被视为 read/write（可读/可写）的，意味着对象检索不是共享的，而且可以安全的被调用者修改，而不干扰其他调用者或线程所做的潜在修改。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 4.Mybatis中连接池以及事务控制，多表操作]]></title>
    <url>%2F2019%2F05%2F04%2FMybatis-4.Mybatis%E4%B8%AD%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[SQL语句中如果出现同名字段 在配置文件中 通过起别名处理 防止匹配不正确容器是一个集合 线程安全 所以添加同步 Mybatis连接池的三种配置Mybatis连接池提供了3种方式的配置 配置位置：主配置文件SqlMapConfig.xml中的DataSource标签 type表示的就是采用何种连接池方式连接 type取值： POOLED 采用传统的javax.sql.DataSource规范中的连接池。Mybatis中有针对的规范实现 对应PooledDataSource UNPOOLED 采用传统的获取连接的方式,虽然也实现了Javax.sql.DataSource接口，但没有使用池的思想 对应UnPooledDataSource JNDI 采用服务器提供的JNDI技术实现来获取DataSource对象 不同的服务器所能拿到的DataSource是不一样的 如果不是web或maven的war工程，是不能使用的 tomcat采用的连接池是dbcp连接池下图为mybatis中pooled连接方法原理 事务提交在SqlSessionFactory中的OpenSession(true)可以开启事务自动提交 Mybatis映射文件中的动态sql条件查询**在判断条件test中 使用 and 禁止使用 &amp;&amp; 符号(不支持) ** 1234select * from user where 1=1&lt;if test="username!=null"&gt; and username=#&#123;username&#125; &lt;/if&gt; 判断条件或传入参数要和java中domain包下的属性名保持一致sql语句中可以不注意大小写(window)， 实体类中不可以如果在if标签外添加&lt;where&gt;标签 就不需要 where 1=1 UserDao.xml 123456789101112&lt;!-- 动态sql--&gt; &lt;select id="findAll" parameterType="User" resultType="User"&gt; select * from user &lt;where&gt; &lt;if test="username!=null"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test="sex!=null and sex='男'"&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; UserDao.java 1List&lt;User&gt; findAll(User user); Test 12345678910public void finAll() &#123; User user1 = new User(); user1.setUsername("老王"); user1.setSex("男"); List&lt;User&gt; list = dao.findAll(user1); for (User user : list) &#123; System.out.println(user); &#125; &#125; 范围查询 collection 集合 open 语句起始close 语句末尾 item 内部填充元素 separator 隔断元素 #{} java填充数据 与item中元素名保持一致 123&lt;foreach collection="list" open="and id in (" close=")" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; UserDao.xml 1234567891011&lt;select id="findByIds" parameterType="list" resultType="User"&gt; select * from user &lt;where&gt; &lt;if test="list!=null and list.size()&gt;0"&gt; &lt;foreach collection="list" open="and id in (" close=")" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; UserDao 1List&lt;User&gt; findByIds(List&lt;Integer&gt; list); Test 1234567891011@Testpublic void findByIds() &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(46); list.add(45); list.add(48); List&lt;User&gt; userList = dao.findByIds(list); for (User u : userList) &#123; System.out.println(u); &#125;&#125; 多表查询Mybatis中的关系：一对多多对一一对一多对多 一对一 一对多一个用户可以有多个账号 建立两张表 一张用户表一张账号表 即连接两张表在账号表中添加外键 建立两个实体类 用户类 账号类 并且让他们之间体现一对多关系 建立两张配置文件 当我们查询用户时 可以获取用户下所包含的账号信息当我们查询账号时 可以获取账户所属的用户信息 配置文件：SqlMapConfig.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--主配置文件--&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;!-- 默认是类名小写--&gt; &lt;package name="it.test.domain"/&gt; &lt;/typeAliases&gt; &lt;environments default="sql"&gt; &lt;environment id="sql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;&lt;!-- 配置包 可以加载所有的xml类配置文件--&gt; &lt;package name="it.test.dao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 一对一Account.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package it.test.domain;public class Account &#123; private int id; private int uid; private int money; private User user; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + ", user=" + user + '&#125;'; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public int getMoney() &#123; return money; &#125; public void setMoney(int money) &#123; this.money = money; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; AccountDao.java 123456789package it.test.dao;import it.test.domain.Account;import java.util.List;public interface AccountDao &#123; List&lt;Account&gt; findByOneToOne();&#125; AccountDao.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="it.test.dao.AccountDao"&gt; &lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;association property="user" column="uid"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findByOneToOne" resultMap="accountUserMap"&gt; select * from user,account where user.id = account.uid; &lt;/select&gt;&lt;/mapper&gt; AccountDaoTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package it.test.dao;import it.test.domain.Account;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class AccountDaoTest &#123; InputStream in = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory build = null; SqlSession sqlSession = null; AccountDao dao = null; @Before //方法运行前执行 public void init() throws IOException &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml");// 通过SqlSessionFactoryBuilder构建工厂 builder = new SqlSessionFactoryBuilder(); build = builder.build(in);// 通过工厂生产SqlSession对象 功能：动态代理生成实现类 sqlSession = build.openSession(); dao = sqlSession.getMapper(AccountDao.class); &#125; @After public void close() throws IOException &#123;// 提交事务 不提交会自动回滚 sqlSession.commit(); in.close(); sqlSession.close(); &#125; @Test public void findByOneToOne()&#123; List&lt;Account&gt; list = dao.findByOneToOne(); for (Account account : list) &#123; System.out.println("============================="); System.out.println(account); System.out.println(account.getUser()); &#125; &#125;&#125; 一对多User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package it.test.domain;import java.util.Date;import java.util.List;public class User &#123; private int id; private String userName; private String sex; private String address; private Date birthday; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", userName='" + userName + '\'' + ", sex='" + sex + '\'' + ", address='" + address + '\'' + ", birthday=" + birthday + '&#125;'; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; UserDao.java 123456789package it.test.dao;import it.test.domain.User;import java.util.List;public interface UserDao &#123; List&lt;User&gt; finaOneToMore();&#125; UserDao.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;it.test.dao.UserDao&quot;&gt; &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;finaOneToMore&quot; resultMap=&quot;userAccountMap&quot;&gt; select * ,account.id as aid from user left outer join account on user.id = account.uid &lt;/select&gt;&lt;/mapper&gt; UserDaoTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package it.test.dao;import it.test.domain.Account;import it.test.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class UserDaoTest &#123; InputStream in = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory build = null; SqlSession sqlSession = null; UserDao dao = null; @Before //方法运行前执行 public void init() throws IOException &#123; in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);// 通过SqlSessionFactoryBuilder构建工厂 builder = new SqlSessionFactoryBuilder(); build = builder.build(in);// 通过工厂生产SqlSession对象 功能：动态代理生成实现类 sqlSession = build.openSession(); dao = sqlSession.getMapper(UserDao.class); &#125; @After public void close() throws IOException &#123;// 提交事务 不提交会自动回滚 sqlSession.commit(); in.close(); sqlSession.close(); &#125; @Test public void finaOneToMore()&#123; List&lt;User&gt; list = dao.finaOneToMore(); for (User u : list) &#123; System.out.println(&quot;=============================&quot;); System.out.println(u); System.out.println(u.getAccounts()); &#125; &#125;&#125; 多对多一个用户可以有多个角色一个角色可以赋予给多个用户 建立两张表 用户表 角色表让用户表和角色表形成多对多的关系 需要中间表 中间表中包含各自的主键 在中间表中是外键 建立两个实体类 用户类和角色类 两个配置文件 当我们查询用户时 可以同时得到用户下所包含的账户信息当我们查询账户时 可以同时得到账户的所属信息 Role.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="it.test.dao.RoleDao"&gt; &lt;resultMap id="RoleUserMap" type="role"&gt; &lt;id property="id" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="ROLE_NAME"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="ROLE_DESC"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="userName" column="username"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findMoreToMore" resultMap="RoleUserMap"&gt; SELECT u.* ,r.id AS rid,r.role_name,r.role_desc FROM role r LEFT OUTER JOIN user_role ON r.`ID` = user_role.rid LEFT OUTER JOIN USER u ON user_role.`UID` = u.`id` &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 3.实现Dao层开发]]></title>
    <url>%2F2019%2F05%2F03%2FMybatis-3.%E5%AE%9E%E7%8E%B0Dao%E5%B1%82%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[源码流程分析 insert delete update三个方法在DefaultSession中 最后都调用的是update方法，所以在session方法中可以使用update实现CUD操作 使用动态代理会先创建代理实例，根据方法和sql语句判断执行哪一种方法 sqlSession.insert delete update select将获取到的结果，作为方法的返回值传递出去。 配置功能优化 properties属性： 主配置中定义属性标签 可以在标签内配置连接数据库信息 也可以通过属性引用外部配置文件 resource属性：用于指定配置文件位置 是按照类路径的写法来写,并且必须存在于类路径下 url属性：统一资源定位符 唯一表示资源位置 写法 协议 主机 端口 uri http://localhost:8080/mybase/index.html uri :统一资源标识符 应用中可以确定资源的唯一位置 file开头为文件协议 Window系统有省略 1234 &lt;properties resource="JdbcConfig.properties"&gt;&lt;!-- &lt;properties url="file:///C:/Users/CZQYY/IdeaProjects/Mybatis_study1/Day03_MybatisDao%E5%B1%82%E6%93%8D%E4%BD%9C/src/main/resources/JdbcConfig.properties"&gt;--&gt; &lt;/properties&gt; 配置环境中的代码更改为 1234567891011&lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 使用typeAlias配置别名 他只能配置domain中类的别名通过包配置 可以省略包括子配置文件中的全类名 别名为全小写类名 123&lt;typeAliases&gt; &lt;package name="it.test.domain"/&gt; &lt;/typeAliases&gt; UserDaoImpl类 12345678910111213141516171819202122232425262728package it.test.impl;import it.test.dao.UserDao;import it.test.domain.User;import org.apache.ibatis.session.SqlSession;import java.util.List;public class UserDaoImpl implements UserDao &#123; SqlSession session=null; public UserDaoImpl(SqlSession session) &#123; this.session = session; &#125; public List&lt;User&gt; findAll() &#123;// 参数是获取配置信息的key nameSpace.id List&lt;User&gt; list = session.selectList("it.test.dao.UserDao.findAll"); return list; &#125;// insert delete update @Override public int count() &#123; Object o = session.selectOne("it.test.dao.UserDao.count"); return (int) o; &#125;&#125; JdbcConfig.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/testusername=rootpassword=root SqlMapConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--主配置文件--&gt;&lt;configuration&gt; &lt;!--主配置中定义属性标签--&gt; &lt;!--可以在标签内配置连接数据库信息 也可以通过属性引用外部配置文件 resource属性：用于指定配置文件位置 是按照类路径的写法来写,并且必须存在于类路径下 url属性：统一资源定位符 唯一表示资源位置 写法 协议 主机 端口 uri http://localhost:8080/mybase/index.html uri :统一资源标识符 应用中可以确定资源的唯一位置 file开头为文件协议 Window系统有省略--&gt; &lt;properties resource="JdbcConfig.properties"&gt;&lt;!-- &lt;properties url="file:///C:/Users/CZQYY/IdeaProjects/Mybatis_study1/Day03_MybatisDao%E5%B1%82%E6%93%8D%E4%BD%9C/src/main/resources/JdbcConfig.properties"&gt;--&gt; &lt;/properties&gt;&lt;!-- 使用typeAlias配置别名 他只能配置domain中类的别名通过包配置 可以省略包括子配置文件中的全类名 只是用类名即可--&gt; &lt;typeAliases&gt; &lt;package name="it.test.domain"/&gt; &lt;/typeAliases&gt;&lt;!-- 配置环境--&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt;&lt;!-- 注解配置--&gt; &lt;mapper class="it.test.dao.UserDao"&gt;&lt;/mapper&gt;&lt;!-- xml配置--&gt; &lt;mapper resource="it/test/dao/UserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置]]></title>
    <url>%2F2019%2F05%2F03%2FHexo%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[首先 学会Hexo下的MarkDown的语法 因为MarkDown下的语法和Hexo框架下支持的语法有所差别，所以对Hexo进行相关语言的了解 语法： https://www.jianshu.com/p/5e9af02c36b3更改默认头信息位于该目录D:\java\blog\scaffolds下的post.md文中 使用HexoEditor编辑 坚持使用Hexo记笔记！！！！！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
